// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/sip.js/lib/platform/web/modifiers/modifiers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMidLines = addMidLines;
exports.cleanJitsiSdpImageattr = cleanJitsiSdpImageattr;
exports.holdModifier = holdModifier;
exports.stripG722 = stripG722;
exports.stripRtpPayload = stripRtpPayload;
exports.stripTcpCandidates = stripTcpCandidates;
exports.stripTelephoneEvent = stripTelephoneEvent;
exports.stripVideo = stripVideo;

var stripPayload = function stripPayload(sdp, payload) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var mediaDescs = [];
  var lines = sdp.split(/\r\n/); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var currentMediaDesc;

  for (var i = 0; i < lines.length;) {
    var line = lines[i];

    if (/^m=(?:audio|video)/.test(line)) {
      currentMediaDesc = {
        index: i,
        stripped: []
      };
      mediaDescs.push(currentMediaDesc);
    } else if (currentMediaDesc) {
      var rtpmap = /^a=rtpmap:(\d+) ([^/]+)\//.exec(line);

      if (rtpmap && payload === rtpmap[2]) {
        lines.splice(i, 1);
        currentMediaDesc.stripped.push(rtpmap[1]);
        continue; // Don't increment 'i'
      }
    }

    i++;
  }

  for (var _i = 0, _mediaDescs = mediaDescs; _i < _mediaDescs.length; _i++) {
    var mediaDesc = _mediaDescs[_i];
    var mline = lines[mediaDesc.index].split(" "); // Ignore the first 3 parameters of the mline. The codec information is after that

    for (var j = 3; j < mline.length;) {
      if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {
        mline.splice(j, 1);
        continue;
      }

      j++;
    }

    lines[mediaDesc.index] = mline.join(" ");
  }

  return lines.join("\r\n");
};

var stripMediaDescription = function stripMediaDescription(sdp, description) {
  var descriptionRegExp = new RegExp("m=" + description + ".*$", "gm");
  var groupRegExp = new RegExp("^a=group:.*$", "gm");

  if (descriptionRegExp.test(sdp)) {
    var midLineToRemove;
    sdp = sdp.split(/^m=/gm).filter(function (section) {
      if (section.substr(0, description.length) === description) {
        midLineToRemove = section.match(/^a=mid:.*$/gm);

        if (midLineToRemove) {
          var step = midLineToRemove[0].match(/:.+$/g);

          if (step) {
            midLineToRemove = step[0].substr(1);
          }
        }

        return false;
      }

      return true;
    }).join("m=");
    var groupLine = sdp.match(groupRegExp);

    if (groupLine && groupLine.length === 1) {
      var groupLinePortion = groupLine[0]; // eslint-disable-next-line no-useless-escape

      var groupRegExpReplace = new RegExp("\ *" + midLineToRemove + "[^\ ]*", "g");
      groupLinePortion = groupLinePortion.replace(groupRegExpReplace, "");
      sdp = sdp.split(groupRegExp).join(groupLinePortion);
    }
  }

  return sdp;
};
/**
 * Modifier.
 * @public
 */


function stripTcpCandidates(description) {
  description.sdp = (description.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
  return Promise.resolve(description);
}
/**
 * Modifier.
 * @public
 */


function stripTelephoneEvent(description) {
  description.sdp = stripPayload(description.sdp || "", "telephone-event");
  return Promise.resolve(description);
}
/**
 * Modifier.
 * @public
 */


function cleanJitsiSdpImageattr(description) {
  description.sdp = (description.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:");
  return Promise.resolve(description);
}
/**
 * Modifier.
 * @public
 */


function stripG722(description) {
  description.sdp = stripPayload(description.sdp || "", "G722");
  return Promise.resolve(description);
}
/**
 * Modifier.
 * @public
 */


function stripRtpPayload(payload) {
  return function (description) {
    description.sdp = stripPayload(description.sdp || "", payload);
    return Promise.resolve(description);
  };
}
/**
 * Modifier.
 * @public
 */


function stripVideo(description) {
  description.sdp = stripMediaDescription(description.sdp || "", "video");
  return Promise.resolve(description);
}
/**
 * Modifier.
 * @public
 */


function addMidLines(description) {
  var sdp = description.sdp || "";

  if (sdp.search(/^a=mid.*$/gm) === -1) {
    var mlines = sdp.match(/^m=.*$/gm);
    var sdpArray = sdp.split(/^m=.*$/gm);

    if (mlines) {
      mlines.forEach(function (elem, idx) {
        mlines[idx] = elem + "\na=mid:" + idx;
      });
    }

    sdpArray.forEach(function (elem, idx) {
      if (mlines && mlines[idx]) {
        sdpArray[idx] = elem + mlines[idx];
      }
    });
    sdp = sdpArray.join("");
    description.sdp = sdp;
  }

  return Promise.resolve(description);
}
/**
 * The modifier that should be used when the session would like to place the call on hold.
 * @param description - The description that will be modified.
 */


function holdModifier(description) {
  if (!description.sdp || !description.type) {
    throw new Error("Invalid SDP");
  }

  var sdp = description.sdp;
  var type = description.type;

  if (sdp) {
    if (!/a=(sendrecv|sendonly|recvonly|inactive)/.test(sdp)) {
      sdp = sdp.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n");
    } else {
      sdp = sdp.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n");
      sdp = sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n");
    }
  }

  return Promise.resolve({
    sdp: sdp,
    type: type
  });
}
},{}],"node_modules/sip.js/lib/platform/web/modifiers/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _modifiers = require("./modifiers");

Object.keys(_modifiers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _modifiers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modifiers[key];
    }
  });
});
},{"./modifiers":"node_modules/sip.js/lib/platform/web/modifiers/modifiers.js"}],"node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultMediaStreamFactory = defaultMediaStreamFactory;

/**
 * Function which returns a MediaStreamFactory.
 * @public
 */
function defaultMediaStreamFactory() {
  return function (constraints) {
    // if no audio or video, return a media stream without tracks
    if (!constraints.audio && !constraints.video) {
      return Promise.resolve(new MediaStream());
    } // getUserMedia() is a powerful feature which can only be used in secure contexts; in insecure contexts,
    // navigator.mediaDevices is undefined, preventing access to getUserMedia(). A secure context is, in short,
    // a page loaded using HTTPS or the file:/// URL scheme, or a page loaded from localhost.
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Privacy_and_security


    if (navigator.mediaDevices === undefined) {
      return Promise.reject(new Error("Media devices not available in insecure contexts."));
    }

    return navigator.mediaDevices.getUserMedia.call(navigator.mediaDevices, constraints);
  };
}
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultPeerConnectionConfiguration = defaultPeerConnectionConfiguration;

/**
 * Function which returns an RTCConfiguration.
 * @public
 */
function defaultPeerConnectionConfiguration() {
  var configuration = {
    bundlePolicy: "balanced",
    certificates: undefined,
    iceCandidatePoolSize: 0,
    iceServers: [{
      urls: "stun:stun.l.google.com:19302"
    }],
    iceTransportPolicy: "all",
    peerIdentity: undefined,
    rtcpMuxPolicy: "require"
  };
  return configuration;
}
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionDescriptionHandler = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A base class implementing a WebRTC session description handler for sip.js.
 * @remarks
 * It is expected/intended to be extended by specific WebRTC based applications.
 * @privateRemarks
 * So do not put application specific implementation in here.
 * @public
 */
var SessionDescriptionHandler = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param logger - A logger
   * @param mediaStreamFactory - A factory to provide a MediaStream
   * @param options - Options passed from the SessionDescriptionHandleFactory
   */
  function SessionDescriptionHandler(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {
    _classCallCheck(this, SessionDescriptionHandler);

    logger.debug("SessionDescriptionHandler.constructor");
    this.logger = logger;
    this.mediaStreamFactory = mediaStreamFactory;
    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;
    this._localMediaStream = new MediaStream();
    this._remoteMediaStream = new MediaStream();
    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);
    this.initPeerConnectionEventHandlers();
  }
  /**
   * The local media stream currently being sent.
   *
   * @remarks
   * The local media stream initially has no tracks, so the presence of tracks
   * should not be assumed. Furthermore, tracks may be added or removed if the
   * local media changes - for example, on upgrade from audio only to a video session.
   * At any given time there will be at most one audio track and one video track
   * (it's possible that this restriction may not apply to sub-classes).
   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
   * to detect when a new track becomes available:
   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
   */


  _createClass(SessionDescriptionHandler, [{
    key: "localMediaStream",
    get: function get() {
      return this._localMediaStream;
    }
    /**
     * The remote media stream currently being received.
     *
     * @remarks
     * The remote media stream initially has no tracks, so the presence of tracks
     * should not be assumed. Furthermore, tracks may be added or removed if the
     * remote media changes - for example, on upgrade from audio only to a video session.
     * At any given time there will be at most one audio track and one video track
     * (it's possible that this restriction may not apply to sub-classes).
     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event
     * to detect when a new track becomes available:
     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack
     */

  }, {
    key: "remoteMediaStream",
    get: function get() {
      return this._remoteMediaStream;
    }
    /**
     * The data channel. Undefined before it is created.
     */

  }, {
    key: "dataChannel",
    get: function get() {
      return this._dataChannel;
    }
    /**
     * The peer connection. Undefined if peer connection has closed.
     *
     * @remarks
     * While access to the underlying `RTCPeerConnection` is provided, note that
     * using methods with modify it may break the operation of this class.
     * In particular, this class depends on exclusive access to the
     * event handler properties. If you need access to the peer connection
     * events, either register for events using `addEventListener()` on
     * the `RTCPeerConnection` or set the `peerConnectionDelegate` on
     * this `SessionDescriptionHandler`.
     */

  }, {
    key: "peerConnection",
    get: function get() {
      return this._peerConnection;
    }
    /**
     * A delegate which provides access to the peer connection event handlers.
     *
     * @remarks
     * Setting the peer connection event handlers directly is not supported
     * and may break this class. As this class depends on exclusive access
     * to them, a delegate may be set which provides alternative access to
     * the event handlers in a fashion which is supported.
     */

  }, {
    key: "peerConnectionDelegate",
    get: function get() {
      return this._peerConnectionDelegate;
    },
    set: function set(delegate) {
      this._peerConnectionDelegate = delegate;
    } // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack

  }, {
    key: "close",
    value:
    /**
     * Stop tracks and close peer connection.
     */
    function close() {
      this.logger.debug("SessionDescriptionHandler.close");

      if (this._peerConnection === undefined) {
        return;
      }

      this._peerConnection.getReceivers().forEach(function (receiver) {
        receiver.track && receiver.track.stop();
      });

      this._peerConnection.getSenders().forEach(function (sender) {
        sender.track && sender.track.stop();
      });

      if (this._dataChannel) {
        this._dataChannel.close();
      }

      this._peerConnection.close();

      this._peerConnection = undefined;
    }
    /**
     * Creates an offer or answer.
     * @param options - Options bucket.
     * @param modifiers - Modifiers.
     */

  }, {
    key: "getDescription",
    value: function getDescription(options, modifiers) {
      var _this = this;

      var _a, _b;

      this.logger.debug("SessionDescriptionHandler.getDescription");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      } // Callback on data channel creation


      this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // ICE will restart upon applying an offer created with the iceRestart option

      var iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart; // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used

      var iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;
      return this.getLocalMediaStream(options).then(function () {
        return _this.updateDirection(options);
      }).then(function () {
        return _this.createDataChannel(options);
      }).then(function () {
        return _this.createLocalOfferOrAnswer(options);
      }).then(function (sessionDescription) {
        return _this.applyModifiers(sessionDescription, modifiers);
      }).then(function (sessionDescription) {
        return _this.setLocalSessionDescription(sessionDescription);
      }).then(function () {
        return _this.waitForIceGatheringComplete(iceRestart, iceTimeout);
      }).then(function () {
        return _this.getLocalSessionDescription();
      }).then(function (sessionDescription) {
        return {
          body: sessionDescription.sdp,
          contentType: "application/sdp"
        };
      }).catch(function (error) {
        _this.logger.error("SessionDescriptionHandler.getDescription failed - " + error);

        throw error;
      });
    }
    /**
     * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.
     * @param contentType - The content type that is in the SIP Message.
     */

  }, {
    key: "hasDescription",
    value: function hasDescription(contentType) {
      this.logger.debug("SessionDescriptionHandler.hasDescription");
      return contentType === "application/sdp";
    }
    /**
     * Send DTMF via RTP (RFC 4733).
     * Returns true if DTMF send is successful, false otherwise.
     * @param tones - A string containing DTMF digits.
     * @param options - Options object to be used by sendDtmf.
     */

  }, {
    key: "sendDtmf",
    value: function sendDtmf(tones, options) {
      this.logger.debug("SessionDescriptionHandler.sendDtmf");

      if (this._peerConnection === undefined) {
        this.logger.error("SessionDescriptionHandler.sendDtmf failed - peer connection closed");
        return false;
      }

      var senders = this._peerConnection.getSenders();

      if (senders.length === 0) {
        this.logger.error("SessionDescriptionHandler.sendDtmf failed - no senders");
        return false;
      }

      var dtmfSender = senders[0].dtmf;

      if (!dtmfSender) {
        this.logger.error("SessionDescriptionHandler.sendDtmf failed - no DTMF sender");
        return false;
      }

      var duration = options === null || options === void 0 ? void 0 : options.duration;
      var interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;

      try {
        dtmfSender.insertDTMF(tones, duration, interToneGap);
      } catch (e) {
        this.logger.error(e);
        return false;
      }

      this.logger.log("SessionDescriptionHandler.sendDtmf sent via RTP: " + tones.toString());
      return true;
    }
    /**
     * Sets an offer or answer.
     * @param sdp - The session description.
     * @param options - Options bucket.
     * @param modifiers - Modifiers.
     */

  }, {
    key: "setDescription",
    value: function setDescription(sdp, options, modifiers) {
      var _this2 = this;

      this.logger.debug("SessionDescriptionHandler.setDescription");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      } // Callback on data channel creation


      this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // SDP type

      var type = this._peerConnection.signalingState === "have-local-offer" ? "answer" : "offer";
      return this.getLocalMediaStream(options).then(function () {
        return _this2.applyModifiers({
          sdp: sdp,
          type: type
        }, modifiers);
      }).then(function (sessionDescription) {
        return _this2.setRemoteSessionDescription(sessionDescription);
      }).catch(function (error) {
        _this2.logger.error("SessionDescriptionHandler.setDescription failed - " + error);

        throw error;
      });
    }
    /**
     * Applies modifiers to SDP prior to setting the local or remote description.
     * @param sdp - SDP to modify.
     * @param modifiers - Modifiers to apply.
     */

  }, {
    key: "applyModifiers",
    value: function applyModifiers(sdp, modifiers) {
      var _this3 = this;

      this.logger.debug("SessionDescriptionHandler.applyModifiers");

      if (!modifiers || modifiers.length === 0) {
        return Promise.resolve(sdp);
      }

      return modifiers.reduce(function (cur, next) {
        return cur.then(next);
      }, Promise.resolve(sdp)).then(function (modified) {
        _this3.logger.debug("SessionDescriptionHandler.applyModifiers - modified sdp");

        if (!modified.sdp || !modified.type) {
          throw new Error("Invalid SDP.");
        }

        return {
          sdp: modified.sdp,
          type: modified.type
        };
      });
    }
    /**
     * Create a data channel.
     * @remarks
     * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.
     * Only creates a data channel if creating a local offer.
     * Only if one does not already exist.
     * @param options - Session description handler options.
     */

  }, {
    key: "createDataChannel",
    value: function createDataChannel(options) {
      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      } // only create a data channel if requested


      if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {
        return Promise.resolve();
      } // do not create a data channel if we already have one


      if (this._dataChannel) {
        return Promise.resolve();
      }

      switch (this._peerConnection.signalingState) {
        case "stable":
          // if we are stable, assume we are creating a local offer so create a data channel
          this.logger.debug("SessionDescriptionHandler.createDataChannel - creating data channel");

          try {
            this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || "", options === null || options === void 0 ? void 0 : options.dataChannelOptions);

            if (this.onDataChannel) {
              this.onDataChannel(this._dataChannel);
            }

            return Promise.resolve();
          } catch (error) {
            return Promise.reject(error);
          }

        case "have-remote-offer":
          return Promise.resolve();

        case "have-local-offer":
        case "have-local-pranswer":
        case "have-remote-pranswer":
        case "closed":
        default:
          return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
      }
    }
    /**
     * Depending on current signaling state, create a local offer or answer.
     * @param options - Session description handler options.
     */

  }, {
    key: "createLocalOfferOrAnswer",
    value: function createLocalOfferOrAnswer(options) {
      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      }

      switch (this._peerConnection.signalingState) {
        case "stable":
          // if we are stable, assume we are creating a local offer
          this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer");
          return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);

        case "have-remote-offer":
          // if we have a remote offer, assume we are creating a local answer
          this.logger.debug("SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer");
          return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);

        case "have-local-offer":
        case "have-local-pranswer":
        case "have-remote-pranswer":
        case "closed":
        default:
          return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
      }
    }
    /**
     * Get a media stream from the media stream factory and set the local media stream.
     * @param options - Session description handler options.
     */

  }, {
    key: "getLocalMediaStream",
    value: function getLocalMediaStream(options) {
      var _this4 = this;

      this.logger.debug("SessionDescriptionHandler.getLocalMediaStream");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      }

      var constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints); // if we already have a local media stream...

      if (this.localMediaStreamConstraints) {
        // ignore constraint "downgrades"
        constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;
        constraints.video = constraints.video || this.localMediaStreamConstraints.video; // if constraints have not changed, do not get a new media stream

        if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {
          return Promise.resolve();
        }
      } else {
        // if no constraints have been specified, default to audio for initial media stream
        if (constraints.audio === undefined && constraints.video === undefined) {
          constraints = {
            audio: true
          };
        }
      }

      this.localMediaStreamConstraints = constraints;
      return this.mediaStreamFactory(constraints, this).then(function (mediaStream) {
        return _this4.setLocalMediaStream(mediaStream);
      });
    }
    /**
     * Sets the peer connection's sender tracks and local media stream tracks.
     *
     * @remarks
     * Only the first audio and video tracks of the provided MediaStream are utilized.
     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
     *
     * @param stream - Media stream containing tracks to be utilized.
     */

  }, {
    key: "setLocalMediaStream",
    value: function setLocalMediaStream(stream) {
      var _this5 = this;

      this.logger.debug("SessionDescriptionHandler.setLocalMediaStream");

      if (!this._peerConnection) {
        throw new Error("Peer connection undefined.");
      }

      var pc = this._peerConnection;
      var localStream = this._localMediaStream;
      var trackUpdates = [];

      var updateTrack = function updateTrack(newTrack) {
        var kind = newTrack.kind;

        if (kind !== "audio" && kind !== "video") {
          throw new Error("Unknown new track kind ".concat(kind, "."));
        }

        var sender = pc.getSenders().find(function (sender) {
          return sender.track && sender.track.kind === kind;
        });

        if (sender) {
          trackUpdates.push(new Promise(function (resolve) {
            _this5.logger.debug("SessionDescriptionHandler.setLocalMediaStream - replacing sender ".concat(kind, " track"));

            resolve();
          }).then(function () {
            return sender.replaceTrack(newTrack).then(function () {
              var oldTrack = localStream.getTracks().find(function (localTrack) {
                return localTrack.kind === kind;
              });

              if (oldTrack) {
                oldTrack.stop();
                localStream.removeTrack(oldTrack);
                SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);
              }

              localStream.addTrack(newTrack);
              SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);
            }).catch(function (error) {
              _this5.logger.error("SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ".concat(kind, " track"));

              throw error;
            });
          }));
        } else {
          trackUpdates.push(new Promise(function (resolve) {
            _this5.logger.debug("SessionDescriptionHandler.setLocalMediaStream - adding sender ".concat(kind, " track"));

            resolve();
          }).then(function () {
            // Review: could make streamless tracks a configurable option?
            // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes
            try {
              pc.addTrack(newTrack, localStream);
            } catch (error) {
              _this5.logger.error("SessionDescriptionHandler.setLocalMediaStream - failed to add sender ".concat(kind, " track"));

              throw error;
            }

            localStream.addTrack(newTrack);
            SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);
          }));
        }
      }; // update peer connection audio tracks


      var audioTracks = stream.getAudioTracks();

      if (audioTracks.length) {
        updateTrack(audioTracks[0]);
      } // update peer connection video tracks


      var videoTracks = stream.getVideoTracks();

      if (videoTracks.length) {
        updateTrack(videoTracks[0]);
      }

      return trackUpdates.reduce(function (p, x) {
        return p.then(function () {
          return x;
        });
      }, Promise.resolve());
    }
    /**
     * Gets the peer connection's local session description.
     */

  }, {
    key: "getLocalSessionDescription",
    value: function getLocalSessionDescription() {
      this.logger.debug("SessionDescriptionHandler.getLocalSessionDescription");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      }

      var sdp = this._peerConnection.localDescription;

      if (!sdp) {
        return Promise.reject(new Error("Failed to get local session description"));
      }

      return Promise.resolve(sdp);
    }
    /**
     * Sets the peer connection's local session description.
     * @param sessionDescription - sessionDescription The session description.
     */

  }, {
    key: "setLocalSessionDescription",
    value: function setLocalSessionDescription(sessionDescription) {
      this.logger.debug("SessionDescriptionHandler.setLocalSessionDescription");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      }

      return this._peerConnection.setLocalDescription(sessionDescription);
    }
    /**
     * Sets the peer connection's remote session description.
     * @param sessionDescription - The session description.
     */

  }, {
    key: "setRemoteSessionDescription",
    value: function setRemoteSessionDescription(sessionDescription) {
      this.logger.debug("SessionDescriptionHandler.setRemoteSessionDescription");

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      }

      var sdp = sessionDescription.sdp;
      var type;

      switch (this._peerConnection.signalingState) {
        case "stable":
          // if we are stable assume this is a remote offer
          type = "offer";
          break;

        case "have-local-offer":
          // if we made an offer, assume this is a remote answer
          type = "answer";
          break;

        case "have-local-pranswer":
        case "have-remote-offer":
        case "have-remote-pranswer":
        case "closed":
        default:
          return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
      }

      if (!sdp) {
        this.logger.error("SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp");
        return Promise.reject(new Error("SDP is undefined"));
      }

      return this._peerConnection.setRemoteDescription({
        sdp: sdp,
        type: type
      });
    }
    /**
     * Sets a remote media stream track.
     *
     * @remarks
     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.
     *
     * @param track - Media stream track to be utilized.
     */

  }, {
    key: "setRemoteTrack",
    value: function setRemoteTrack(track) {
      this.logger.debug("SessionDescriptionHandler.setRemoteTrack");
      var remoteStream = this._remoteMediaStream;

      if (remoteStream.getTrackById(track.id)) {
        this.logger.debug("SessionDescriptionHandler.setRemoteTrack - have remote ".concat(track.kind, " track"));
      } else if (track.kind === "audio") {
        this.logger.debug("SessionDescriptionHandler.setRemoteTrack - adding remote ".concat(track.kind, " track"));
        remoteStream.getAudioTracks().forEach(function (track) {
          track.stop();
          remoteStream.removeTrack(track);
          SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);
        });
        remoteStream.addTrack(track);
        SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);
      } else if (track.kind === "video") {
        this.logger.debug("SessionDescriptionHandler.setRemoteTrack - adding remote ".concat(track.kind, " track"));
        remoteStream.getVideoTracks().forEach(function (track) {
          track.stop();
          remoteStream.removeTrack(track);
          SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);
        });
        remoteStream.addTrack(track);
        SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);
      }
    }
    /**
     * Depending on the current signaling state and the session hold state, update transceiver direction.
     * @param options - Session description handler options.
     */

  }, {
    key: "updateDirection",
    value: function updateDirection(options) {
      var _this6 = this;

      if (this._peerConnection === undefined) {
        return Promise.reject(new Error("Peer connection closed."));
      } // 4.2.3.  setDirection
      //
      //    The setDirection method sets the direction of a transceiver, which
      //    affects the direction property of the associated "m=" section on
      //    future calls to createOffer and createAnswer.  The permitted values
      //    for direction are "recvonly", "sendrecv", "sendonly", and "inactive",
      //    mirroring the identically named direction attributes defined in
      //    [RFC4566], Section 6.
      //
      //    When creating offers, the transceiver direction is directly reflected
      //    in the output, even for re-offers.  When creating answers, the
      //    transceiver direction is intersected with the offered direction, as
      //    explained in Section 5.3 below.
      //
      //    Note that while setDirection sets the direction property of the
      //    transceiver immediately (Section 4.2.4), this property does not
      //    immediately affect whether the transceiver's RtpSender will send or
      //    its RtpReceiver will receive.  The direction in effect is represented
      //    by the currentDirection property, which is only updated when an
      //    answer is applied.
      //
      // 4.2.4.  direction
      //
      //    The direction property indicates the last value passed into
      //    setDirection.  If setDirection has never been called, it is set to
      //    the direction the transceiver was initialized with.
      //
      // 4.2.5.  currentDirection
      //
      //    The currentDirection property indicates the last negotiated direction
      //    for the transceiver's associated "m=" section.  More specifically, it
      //    indicates the direction attribute [RFC3264] of the associated "m="
      //    section in the last applied answer (including provisional answers),
      //    with "send" and "recv" directions reversed if it was a remote answer.
      //    For example, if the direction attribute for the associated "m="
      //    section in a remote answer is "recvonly", currentDirection is set to
      //    "sendonly".
      //
      //    If an answer that references this transceiver has not yet been
      //    applied or if the transceiver is stopped, currentDirection is set to
      //    "null".
      //  https://tools.ietf.org/html/rfc8829#section-4.2.3
      //
      // *  A direction attribute, determined by applying the rules regarding
      //    the offered direction specified in [RFC3264], Section 6.1, and
      //    then intersecting with the direction of the associated
      //    RtpTransceiver.  For example, in the case where an "m=" section is
      //    offered as "sendonly" and the local transceiver is set to
      //    "sendrecv", the result in the answer is a "recvonly" direction.
      // https://tools.ietf.org/html/rfc8829#section-5.3.1
      //
      // If a stream is offered as sendonly, the corresponding stream MUST be
      // marked as recvonly or inactive in the answer.  If a media stream is
      // listed as recvonly in the offer, the answer MUST be marked as
      // sendonly or inactive in the answer.  If an offered media stream is
      // listed as sendrecv (or if there is no direction attribute at the
      // media or session level, in which case the stream is sendrecv by
      // default), the corresponding stream in the answer MAY be marked as
      // sendonly, recvonly, sendrecv, or inactive.  If an offered media
      // stream is listed as inactive, it MUST be marked as inactive in the
      // answer.
      // https://tools.ietf.org/html/rfc3264#section-6.1


      switch (this._peerConnection.signalingState) {
        case "stable":
          // if we are stable, assume we are creating a local offer
          this.logger.debug("SessionDescriptionHandler.updateDirection - setting offer direction");
          {
            // determine the direction to offer given the current direction and hold state
            var directionToOffer = function directionToOffer(currentDirection) {
              switch (currentDirection) {
                case "inactive":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";

                case "recvonly":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";

                case "sendonly":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";

                case "sendrecv":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";

                case "stopped":
                  return "stopped";

                default:
                  throw new Error("Should never happen");
              }
            }; // set the transceiver direction to the offer direction


            this._peerConnection.getTransceivers().forEach(function (transceiver) {
              if (transceiver.direction
              /* guarding, but should always be true */
              ) {
                var offerDirection = directionToOffer(transceiver.direction);

                if (transceiver.direction !== offerDirection) {
                  transceiver.direction = offerDirection;
                }
              }
            });
          }
          break;

        case "have-remote-offer":
          // if we have a remote offer, assume we are creating a local answer
          this.logger.debug("SessionDescriptionHandler.updateDirection - setting answer direction"); // FIXME: This is not the correct way to determine the answer direction as it is only
          // considering first match in the offered SDP and using that to determine the answer direction.
          // While that may be fine for our current use cases, it is not a generally correct approach.

          {
            // determine the offered direction
            var offeredDirection = function () {
              var description = _this6._peerConnection.remoteDescription;

              if (!description) {
                throw new Error("Failed to read remote offer");
              }

              var searchResult = /a=sendrecv\r\n|a=sendonly\r\n|a=recvonly\r\n|a=inactive\r\n/.exec(description.sdp);

              if (searchResult) {
                switch (searchResult[0]) {
                  case "a=inactive\r\n":
                    return "inactive";

                  case "a=recvonly\r\n":
                    return "recvonly";

                  case "a=sendonly\r\n":
                    return "sendonly";

                  case "a=sendrecv\r\n":
                    return "sendrecv";

                  default:
                    throw new Error("Should never happen");
                }
              }

              return "sendrecv";
            }(); // determine the answer direction based on the offered direction and our hold state


            var answerDirection = function () {
              switch (offeredDirection) {
                case "inactive":
                  return "inactive";

                case "recvonly":
                  return "sendonly";

                case "sendonly":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "inactive" : "recvonly";

                case "sendrecv":
                  return (options === null || options === void 0 ? void 0 : options.hold) ? "sendonly" : "sendrecv";

                default:
                  throw new Error("Should never happen");
              }
            }(); // set the transceiver direction to the answer direction


            this._peerConnection.getTransceivers().forEach(function (transceiver) {
              if (transceiver.direction
              /* guarding, but should always be true */
              ) {
                if (transceiver.direction !== "stopped" && transceiver.direction !== answerDirection) {
                  transceiver.direction = answerDirection;
                }
              }
            });
          }
          break;

        case "have-local-offer":
        case "have-local-pranswer":
        case "have-remote-pranswer":
        case "closed":
        default:
          return Promise.reject(new Error("Invalid signaling state " + this._peerConnection.signalingState));
      }

      return Promise.resolve();
    }
    /**
     * Called when ICE gathering completes and resolves any waiting promise.
     */

  }, {
    key: "iceGatheringComplete",
    value: function iceGatheringComplete() {
      this.logger.debug("SessionDescriptionHandler.iceGatheringComplete"); // clear timer if need be

      if (this.iceGatheringCompleteTimeoutId !== undefined) {
        this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - clearing timeout");
        clearTimeout(this.iceGatheringCompleteTimeoutId);
        this.iceGatheringCompleteTimeoutId = undefined;
      } // resolve and cleanup promise if need be


      if (this.iceGatheringCompletePromise !== undefined) {
        this.logger.debug("SessionDescriptionHandler.iceGatheringComplete - resolving promise");
        this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();
        this.iceGatheringCompletePromise = undefined;
        this.iceGatheringCompleteResolve = undefined;
        this.iceGatheringCompleteReject = undefined;
      }
    }
    /**
     * Wait for ICE gathering to complete.
     * @param restart - If true, waits if current state is "complete" (waits for transition to "complete").
     * @param timeout - Milliseconds after which waiting times out. No timeout if 0.
     */

  }, {
    key: "waitForIceGatheringComplete",
    value: function waitForIceGatheringComplete() {
      var _this7 = this;

      var restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete");

      if (this._peerConnection === undefined) {
        return Promise.reject("Peer connection closed.");
      } // guard already complete


      if (!restart && this._peerConnection.iceGatheringState === "complete") {
        this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - already complete");
        return Promise.resolve();
      } // only one may be waiting, reject any prior


      if (this.iceGatheringCompletePromise !== undefined) {
        this.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise");
        this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error("Promise superseded."));
        this.iceGatheringCompletePromise = undefined;
        this.iceGatheringCompleteResolve = undefined;
        this.iceGatheringCompleteReject = undefined;
      }

      this.iceGatheringCompletePromise = new Promise(function (resolve, reject) {
        _this7.iceGatheringCompleteResolve = resolve;
        _this7.iceGatheringCompleteReject = reject;

        if (timeout > 0) {
          _this7.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in " + timeout);

          _this7.iceGatheringCompleteTimeoutId = setTimeout(function () {
            _this7.logger.debug("SessionDescriptionHandler.waitForIceGatheringToComplete - timeout");

            _this7.iceGatheringComplete();
          }, timeout);
        }
      });
      return this.iceGatheringCompletePromise;
    }
    /**
     * Initializes the peer connection event handlers
     */

  }, {
    key: "initPeerConnectionEventHandlers",
    value: function initPeerConnectionEventHandlers() {
      var _this8 = this;

      this.logger.debug("SessionDescriptionHandler.initPeerConnectionEventHandlers");
      if (!this._peerConnection) throw new Error("Peer connection undefined.");
      var peerConnection = this._peerConnection;

      peerConnection.onconnectionstatechange = function (event) {
        var _a;

        var newState = peerConnection.connectionState;

        _this8.logger.debug("SessionDescriptionHandler.onconnectionstatechange ".concat(newState));

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {
          _this8._peerConnectionDelegate.onconnectionstatechange(event);
        }
      };

      peerConnection.ondatachannel = function (event) {
        var _a;

        _this8.logger.debug("SessionDescriptionHandler.ondatachannel");

        _this8._dataChannel = event.channel;

        if (_this8.onDataChannel) {
          _this8.onDataChannel(_this8._dataChannel);
        }

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {
          _this8._peerConnectionDelegate.ondatachannel(event);
        }
      };

      peerConnection.onicecandidate = function (event) {
        var _a;

        _this8.logger.debug("SessionDescriptionHandler.onicecandidate");

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {
          _this8._peerConnectionDelegate.onicecandidate(event);
        }
      };

      peerConnection.onicecandidateerror = function (event) {
        var _a;

        _this8.logger.debug("SessionDescriptionHandler.onicecandidateerror");

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {
          _this8._peerConnectionDelegate.onicecandidateerror(event);
        }
      };

      peerConnection.oniceconnectionstatechange = function (event) {
        var _a;

        var newState = peerConnection.iceConnectionState;

        _this8.logger.debug("SessionDescriptionHandler.oniceconnectionstatechange ".concat(newState));

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {
          _this8._peerConnectionDelegate.oniceconnectionstatechange(event);
        }
      };

      peerConnection.onicegatheringstatechange = function (event) {
        var _a;

        var newState = peerConnection.iceGatheringState;

        _this8.logger.debug("SessionDescriptionHandler.onicegatheringstatechange ".concat(newState));

        if (newState === "complete") {
          _this8.iceGatheringComplete(); // complete waiting for ICE gathering to complete

        }

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {
          _this8._peerConnectionDelegate.onicegatheringstatechange(event);
        }
      };

      peerConnection.onnegotiationneeded = function (event) {
        var _a;

        _this8.logger.debug("SessionDescriptionHandler.onnegotiationneeded");

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {
          _this8._peerConnectionDelegate.onnegotiationneeded(event);
        }
      };

      peerConnection.onsignalingstatechange = function (event) {
        var _a;

        var newState = peerConnection.signalingState;

        _this8.logger.debug("SessionDescriptionHandler.onsignalingstatechange ".concat(newState));

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {
          _this8._peerConnectionDelegate.onsignalingstatechange(event);
        }
      };

      peerConnection.onstatsended = function (event) {
        var _a;

        _this8.logger.debug("SessionDescriptionHandler.onstatsended");

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {
          _this8._peerConnectionDelegate.onstatsended(event);
        }
      };

      peerConnection.ontrack = function (event) {
        var _a;

        var kind = event.track.kind;
        var enabled = event.track.enabled ? "enabled" : "disabled";

        _this8.logger.debug("SessionDescriptionHandler.ontrack ".concat(kind, " ").concat(enabled));

        _this8.setRemoteTrack(event.track);

        if ((_a = _this8._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {
          _this8._peerConnectionDelegate.ontrack(event);
        }
      };
    }
  }], [{
    key: "dispatchAddTrackEvent",
    value: function dispatchAddTrackEvent(stream, track) {
      stream.dispatchEvent(new MediaStreamTrackEvent("addtrack", {
        track: track
      }));
    } // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack

  }, {
    key: "dispatchRemoveTrackEvent",
    value: function dispatchRemoveTrackEvent(stream, track) {
      stream.dispatchEvent(new MediaStreamTrackEvent("removetrack", {
        track: track
      }));
    }
  }]);

  return SessionDescriptionHandler;
}();

exports.SessionDescriptionHandler = SessionDescriptionHandler;
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultSessionDescriptionHandlerFactory = defaultSessionDescriptionHandlerFactory;

var _mediaStreamFactoryDefault = require("./media-stream-factory-default");

var _peerConnectionConfigurationDefault = require("./peer-connection-configuration-default");

var _sessionDescriptionHandler = require("./session-description-handler");

/**
 * Function which returns a SessionDescriptionHandlerFactory.
 * @remarks
 * See {@link defaultPeerConnectionConfiguration} for the default peer connection configuration.
 * The ICE gathering timeout defaults to 5000ms.
 * @param mediaStreamFactory - MediaStream factory.
 * @public
 */
function defaultSessionDescriptionHandlerFactory(mediaStreamFactory) {
  return function (session, options) {
    // provide a default media stream factory if need be
    if (mediaStreamFactory === undefined) {
      mediaStreamFactory = (0, _mediaStreamFactoryDefault.defaultMediaStreamFactory)();
    } // make sure we allow `0` to be passed in so timeout can be disabled


    var iceGatheringTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) !== undefined ? options === null || options === void 0 ? void 0 : options.iceGatheringTimeout : 5000; // merge passed factory options into default session description configuration

    var sessionDescriptionHandlerConfiguration = {
      iceGatheringTimeout: iceGatheringTimeout,
      peerConnectionConfiguration: Object.assign(Object.assign({}, (0, _peerConnectionConfigurationDefault.defaultPeerConnectionConfiguration)()), options === null || options === void 0 ? void 0 : options.peerConnectionConfiguration)
    };
    var logger = session.userAgent.getLogger("sip.SessionDescriptionHandler");
    return new _sessionDescriptionHandler.SessionDescriptionHandler(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration);
  };
}
},{"./media-stream-factory-default":"node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js","./peer-connection-configuration-default":"node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js","./session-description-handler":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js"}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/session-description-handler/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mediaStreamFactoryDefault = require("./media-stream-factory-default");

Object.keys(_mediaStreamFactoryDefault).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamFactoryDefault[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamFactoryDefault[key];
    }
  });
});

var _mediaStreamFactory = require("./media-stream-factory");

Object.keys(_mediaStreamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamFactory[key];
    }
  });
});

var _peerConnectionConfigurationDefault = require("./peer-connection-configuration-default");

Object.keys(_peerConnectionConfigurationDefault).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _peerConnectionConfigurationDefault[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _peerConnectionConfigurationDefault[key];
    }
  });
});

var _peerConnectionDelegate = require("./peer-connection-delegate");

Object.keys(_peerConnectionDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _peerConnectionDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _peerConnectionDelegate[key];
    }
  });
});

var _sessionDescriptionHandlerConfiguration = require("./session-description-handler-configuration");

Object.keys(_sessionDescriptionHandlerConfiguration).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerConfiguration[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerConfiguration[key];
    }
  });
});

var _sessionDescriptionHandlerFactoryDefault = require("./session-description-handler-factory-default");

Object.keys(_sessionDescriptionHandlerFactoryDefault).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerFactoryDefault[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerFactoryDefault[key];
    }
  });
});

var _sessionDescriptionHandlerFactoryOptions = require("./session-description-handler-factory-options");

Object.keys(_sessionDescriptionHandlerFactoryOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerFactoryOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerFactoryOptions[key];
    }
  });
});

var _sessionDescriptionHandlerFactory = require("./session-description-handler-factory");

Object.keys(_sessionDescriptionHandlerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerFactory[key];
    }
  });
});

var _sessionDescriptionHandlerOptions = require("./session-description-handler-options");

Object.keys(_sessionDescriptionHandlerOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerOptions[key];
    }
  });
});

var _sessionDescriptionHandler = require("./session-description-handler");

Object.keys(_sessionDescriptionHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandler[key];
    }
  });
});
},{"./media-stream-factory-default":"node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory-default.js","./media-stream-factory":"node_modules/sip.js/lib/platform/web/session-description-handler/media-stream-factory.js","./peer-connection-configuration-default":"node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-configuration-default.js","./peer-connection-delegate":"node_modules/sip.js/lib/platform/web/session-description-handler/peer-connection-delegate.js","./session-description-handler-configuration":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-configuration.js","./session-description-handler-factory-default":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-default.js","./session-description-handler-factory-options":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory-options.js","./session-description-handler-factory":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-factory.js","./session-description-handler-options":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler-options.js","./session-description-handler":"node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js"}],"node_modules/sip.js/lib/grammar/parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parameters = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * @internal
 */
var Parameters = /*#__PURE__*/function () {
  function Parameters(parameters) {
    _classCallCheck(this, Parameters);

    this.parameters = {}; // for in is required here as the Grammar parser is adding to the prototype chain

    for (var param in parameters) {
      // eslint-disable-next-line no-prototype-builtins
      if (parameters.hasOwnProperty(param)) {
        this.setParam(param, parameters[param]);
      }
    }
  }

  _createClass(Parameters, [{
    key: "setParam",
    value: function setParam(key, value) {
      if (key) {
        this.parameters[key.toLowerCase()] = typeof value === "undefined" || value === null ? null : value.toString();
      }
    }
  }, {
    key: "getParam",
    value: function getParam(key) {
      if (key) {
        return this.parameters[key.toLowerCase()];
      }
    }
  }, {
    key: "hasParam",
    value: function hasParam(key) {
      return !!(key && this.parameters[key.toLowerCase()] !== undefined);
    }
  }, {
    key: "deleteParam",
    value: function deleteParam(key) {
      key = key.toLowerCase();

      if (this.hasParam(key)) {
        var value = this.parameters[key];
        delete this.parameters[key];
        return value;
      }
    }
  }, {
    key: "clearParams",
    value: function clearParams() {
      this.parameters = {};
    }
  }]);

  return Parameters;
}();

exports.Parameters = Parameters;
},{}],"node_modules/sip.js/lib/grammar/name-addr-header.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NameAddrHeader = void 0;

var _parameters = require("./parameters");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Name Address SIP header.
 * @public
 */
var NameAddrHeader = /*#__PURE__*/function (_Parameters) {
  _inherits(NameAddrHeader, _Parameters);

  var _super = _createSuper(NameAddrHeader);

  /**
   * Constructor
   * @param uri -
   * @param displayName -
   * @param parameters -
   */
  function NameAddrHeader(uri, displayName, parameters) {
    var _this;

    _classCallCheck(this, NameAddrHeader);

    _this = _super.call(this, parameters);
    _this.uri = uri;
    _this._displayName = displayName;
    return _this;
  }

  _createClass(NameAddrHeader, [{
    key: "friendlyName",
    get: function get() {
      return this.displayName || this.uri.aor;
    }
  }, {
    key: "displayName",
    get: function get() {
      return this._displayName;
    },
    set: function set(value) {
      this._displayName = value;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
    }
  }, {
    key: "toString",
    value: function toString() {
      var body = this.displayName || this.displayName === "0" ? '"' + this.displayName + '" ' : "";
      body += "<" + this.uri.toString() + ">";

      for (var parameter in this.parameters) {
        // eslint-disable-next-line no-prototype-builtins
        if (this.parameters.hasOwnProperty(parameter)) {
          body += ";" + parameter;

          if (this.parameters[parameter] !== null) {
            body += "=" + this.parameters[parameter];
          }
        }
      }

      return body;
    }
  }]);

  return NameAddrHeader;
}(_parameters.Parameters);

exports.NameAddrHeader = NameAddrHeader;
},{"./parameters":"node_modules/sip.js/lib/grammar/parameters.js"}],"node_modules/sip.js/lib/grammar/uri.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.URI = void 0;
exports.equivalentURI = equivalentURI;

var _parameters = require("./parameters");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * URI.
 * @public
 */
var URI = /*#__PURE__*/function (_Parameters) {
  _inherits(URI, _Parameters);

  var _super = _createSuper(URI);

  /**
   * Constructor
   * @param scheme -
   * @param user -
   * @param host -
   * @param port -
   * @param parameters -
   * @param headers -
   */
  function URI() {
    var _this;

    var scheme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "sip";
    var user = arguments.length > 1 ? arguments[1] : undefined;
    var host = arguments.length > 2 ? arguments[2] : undefined;
    var port = arguments.length > 3 ? arguments[3] : undefined;
    var parameters = arguments.length > 4 ? arguments[4] : undefined;
    var headers = arguments.length > 5 ? arguments[5] : undefined;

    _classCallCheck(this, URI);

    _this = _super.call(this, parameters || {});
    _this.headers = {}; // Checks

    if (!host) {
      throw new TypeError('missing or invalid "host" parameter');
    }

    for (var header in headers) {
      // eslint-disable-next-line no-prototype-builtins
      if (headers.hasOwnProperty(header)) {
        _this.setHeader(header, headers[header]);
      }
    } // Raw URI


    _this.raw = {
      scheme: scheme,
      user: user,
      host: host,
      port: port
    }; // Normalized URI

    _this.normal = {
      scheme: scheme.toLowerCase(),
      user: user,
      host: host.toLowerCase(),
      port: port
    };
    return _this;
  }

  _createClass(URI, [{
    key: "scheme",
    get: function get() {
      return this.normal.scheme;
    },
    set: function set(value) {
      this.raw.scheme = value;
      this.normal.scheme = value.toLowerCase();
    }
  }, {
    key: "user",
    get: function get() {
      return this.normal.user;
    },
    set: function set(value) {
      this.normal.user = this.raw.user = value;
    }
  }, {
    key: "host",
    get: function get() {
      return this.normal.host;
    },
    set: function set(value) {
      this.raw.host = value;
      this.normal.host = value.toLowerCase();
    }
  }, {
    key: "aor",
    get: function get() {
      return this.normal.user + "@" + this.normal.host;
    }
  }, {
    key: "port",
    get: function get() {
      return this.normal.port;
    },
    set: function set(value) {
      this.normal.port = this.raw.port = value === 0 ? value : value;
    }
  }, {
    key: "setHeader",
    value: function setHeader(name, value) {
      this.headers[this.headerize(name)] = value instanceof Array ? value : [value];
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      if (name) {
        return this.headers[this.headerize(name)];
      }
    }
  }, {
    key: "hasHeader",
    value: function hasHeader(name) {
      // eslint-disable-next-line no-prototype-builtins
      return !!name && !!this.headers.hasOwnProperty(this.headerize(name));
    }
  }, {
    key: "deleteHeader",
    value: function deleteHeader(header) {
      header = this.headerize(header); // eslint-disable-next-line no-prototype-builtins

      if (this.headers.hasOwnProperty(header)) {
        var value = this.headers[header];
        delete this.headers[header];
        return value;
      }
    }
  }, {
    key: "clearHeaders",
    value: function clearHeaders() {
      this.headers = {};
    }
  }, {
    key: "clone",
    value: function clone() {
      return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
    }
  }, {
    key: "toRaw",
    value: function toRaw() {
      return this._toString(this._raw);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._toString(this._normal);
    }
  }, {
    key: "_normal",
    get: function get() {
      return this.normal;
    }
  }, {
    key: "_raw",
    get: function get() {
      return this.raw;
    }
  }, {
    key: "_toString",
    value: function _toString(uri) {
      var uriString = uri.scheme + ":"; // add slashes if it's not a sip(s) URI

      if (!uri.scheme.toLowerCase().match("^sips?$")) {
        uriString += "//";
      }

      if (uri.user) {
        uriString += this.escapeUser(uri.user) + "@";
      }

      uriString += uri.host;

      if (uri.port || uri.port === 0) {
        uriString += ":" + uri.port;
      }

      for (var parameter in this.parameters) {
        // eslint-disable-next-line no-prototype-builtins
        if (this.parameters.hasOwnProperty(parameter)) {
          uriString += ";" + parameter;

          if (this.parameters[parameter] !== null) {
            uriString += "=" + this.parameters[parameter];
          }
        }
      }

      var headers = [];

      for (var header in this.headers) {
        // eslint-disable-next-line no-prototype-builtins
        if (this.headers.hasOwnProperty(header)) {
          // eslint-disable-next-line @typescript-eslint/no-for-in-array
          for (var idx in this.headers[header]) {
            // eslint-disable-next-line no-prototype-builtins
            if (this.headers[header].hasOwnProperty(idx)) {
              headers.push(header + "=" + this.headers[header][idx]);
            }
          }
        }
      }

      if (headers.length > 0) {
        uriString += "?" + headers.join("&");
      }

      return uriString;
    }
    /*
     * Hex-escape a SIP URI user.
     * @private
     * @param {String} user
     */

  }, {
    key: "escapeUser",
    value: function escapeUser(user) {
      var decodedUser; // FIXME: This is called by toString above which should never throw, but
      // decodeURIComponent can throw and I've seen one case in production where
      // it did throw resulting in a cascading failure. This class should be
      // fixed so that decodeURIComponent is not called at this point (in toString).
      // The user should be decoded when the URI is constructor or some other
      // place where we can catch the error before the URI is created or somesuch.
      // eslint-disable-next-line no-useless-catch

      try {
        decodedUser = decodeURIComponent(user);
      } catch (error) {
        throw error;
      } // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).


      return encodeURIComponent(decodedUser).replace(/%3A/ig, ":").replace(/%2B/ig, "+").replace(/%3F/ig, "?").replace(/%2F/ig, "/");
    }
  }, {
    key: "headerize",
    value: function headerize(str) {
      var exceptions = {
        "Call-Id": "Call-ID",
        "Cseq": "CSeq",
        "Min-Se": "Min-SE",
        "Rack": "RAck",
        "Rseq": "RSeq",
        "Www-Authenticate": "WWW-Authenticate"
      };
      var name = str.toLowerCase().replace(/_/g, "-").split("-");
      var parts = name.length;
      var hname = "";

      for (var part = 0; part < parts; part++) {
        if (part !== 0) {
          hname += "-";
        }

        hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
      }

      if (exceptions[hname]) {
        hname = exceptions[hname];
      }

      return hname;
    }
  }]);

  return URI;
}(_parameters.Parameters);
/**
 * Returns true if URIs are equivalent per RFC 3261 Section 19.1.4.
 * @param a URI to compare
 * @param b URI to compare
 *
 * @remarks
 * 19.1.4 URI Comparison
 * Some operations in this specification require determining whether two
 * SIP or SIPS URIs are equivalent.
 *
 * https://tools.ietf.org/html/rfc3261#section-19.1.4
 * @internal
 */


exports.URI = URI;

function equivalentURI(a, b) {
  // o  A SIP and SIPS URI are never equivalent.
  if (a.scheme !== b.scheme) {
    return false;
  } // o  Comparison of the userinfo of SIP and SIPS URIs is case-
  //    sensitive.  This includes userinfo containing passwords or
  //    formatted as telephone-subscribers.  Comparison of all other
  //    components of the URI is case-insensitive unless explicitly
  //    defined otherwise.
  //
  // o  The ordering of parameters and header fields is not significant
  //    in comparing SIP and SIPS URIs.
  //
  // o  Characters other than those in the "reserved" set (see RFC 2396
  //    [5]) are equivalent to their ""%" HEX HEX" encoding.
  //
  // o  An IP address that is the result of a DNS lookup of a host name
  //    does not match that host name.
  //
  // o  For two URIs to be equal, the user, password, host, and port
  //    components must match.
  //
  // A URI omitting the user component will not match a URI that
  // includes one.  A URI omitting the password component will not
  // match a URI that includes one.
  //
  // A URI omitting any component with a default value will not
  // match a URI explicitly containing that component with its
  // default value.  For instance, a URI omitting the optional port
  // component will not match a URI explicitly declaring port 5060.
  // The same is true for the transport-parameter, ttl-parameter,
  // user-parameter, and method components.
  //
  // Defining sip:user@host to not be equivalent to
  // sip:user@host:5060 is a change from RFC 2543.  When deriving
  // addresses from URIs, equivalent addresses are expected from
  // equivalent URIs.  The URI sip:user@host:5060 will always
  // resolve to port 5060.  The URI sip:user@host may resolve to
  // other ports through the DNS SRV mechanisms detailed in [4].
  // FIXME: TODO:
  // - character compared to hex encoding is not handled
  // - password does not exist on URI currently


  if (a.user !== b.user || a.host !== b.host || a.port !== b.port) {
    return false;
  } // o  URI uri-parameter components are compared as follows:


  function compareParameters(a, b) {
    //  -  Any uri-parameter appearing in both URIs must match.
    var parameterKeysA = Object.keys(a.parameters);
    var parameterKeysB = Object.keys(b.parameters);
    var intersection = parameterKeysA.filter(function (x) {
      return parameterKeysB.includes(x);
    });

    if (!intersection.every(function (key) {
      return a.parameters[key] === b.parameters[key];
    })) {
      return false;
    } //  -  A user, ttl, or method uri-parameter appearing in only one
    //     URI never matches, even if it contains the default value.


    if (!["user", "ttl", "method", "transport"].every(function (key) {
      return a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key);
    })) {
      return false;
    } //  -  A URI that includes an maddr parameter will not match a URI
    //     that contains no maddr parameter.


    if (!["maddr"].every(function (key) {
      return a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key);
    })) {
      return false;
    } //  -  All other uri-parameters appearing in only one URI are
    //     ignored when comparing the URIs.


    return true;
  }

  if (!compareParameters(a, b)) {
    return false;
  } // o  URI header components are never ignored.  Any present header
  //    component MUST be present in both URIs and match for the URIs
  //    to match.  The matching rules are defined for each header field
  //    in Section 20.


  var headerKeysA = Object.keys(a.headers);
  var headerKeysB = Object.keys(b.headers); // No need to check if no headers

  if (headerKeysA.length !== 0 || headerKeysB.length !== 0) {
    // Must have same number of headers
    if (headerKeysA.length !== headerKeysB.length) {
      return false;
    } // Must have same headers


    var intersection = headerKeysA.filter(function (x) {
      return headerKeysB.includes(x);
    });

    if (intersection.length !== headerKeysB.length) {
      return false;
    } // FIXME: Not to spec. But perhaps not worth fixing?
    // Must have same header values
    // It seems too much to consider multiple headers with same name.
    // It seems too much to compare two header params according to the rule of each header.
    // We'll assume a single header and compare them string to string...


    if (!intersection.every(function (key) {
      return a.headers[key].length && b.headers[key].length && a.headers[key][0] === b.headers[key][0];
    })) {
      return false;
    }
  }

  return true;
}
},{"./parameters":"node_modules/sip.js/lib/grammar/parameters.js"}],"node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = exports.SyntaxError = void 0;

var _nameAddrHeader = require("../../name-addr-header");

var _uri = require("../../uri");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var SyntaxError = /*#__PURE__*/function (_Error) {
  _inherits(SyntaxError, _Error);

  var _super = _createSuper(SyntaxError);

  function SyntaxError(message, expected, found, location) {
    var _this;

    _classCallCheck(this, SyntaxError);

    _this = _super.call(this);
    _this.message = message;
    _this.expected = expected;
    _this.found = found;
    _this.location = location;
    _this.name = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_assertThisInitialized(_this), SyntaxError);
    }

    return _this;
  }

  _createClass(SyntaxError, null, [{
    key: "buildMessage",
    value: function buildMessage(expected, found) {
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, "\\\"").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return "\\x" + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return "\\x" + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        switch (expectation.type) {
          case "literal":
            return "\"" + literalEscape(expectation.text) + "\"";

          case "class":
            var escapedParts = expectation.parts.map(function (part) {
              return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";

          case "any":
            return "any character";

          case "end":
            return "end of input";

          case "other":
            return expectation.description;
        }
      }

      function describeExpected(expected1) {
        var descriptions = expected1.map(describeExpectation);
        var i;
        var j;
        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found1) {
        return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
  }]);

  return SyntaxError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.SyntaxError = SyntaxError;

function peg$parse(input, options) {
  options = options !== undefined ? options : {};
  var peg$FAILED = {};
  var peg$startRuleIndices = {
    Contact: 119,
    Name_Addr_Header: 156,
    Record_Route: 176,
    Request_Response: 81,
    SIP_URI: 45,
    Subscription_State: 186,
    Supported: 191,
    Require: 182,
    Via: 194,
    absoluteURI: 84,
    Call_ID: 118,
    Content_Disposition: 130,
    Content_Length: 135,
    Content_Type: 136,
    CSeq: 146,
    displayName: 122,
    Event: 149,
    From: 151,
    host: 52,
    Max_Forwards: 154,
    Min_SE: 213,
    Proxy_Authenticate: 157,
    quoted_string: 40,
    Refer_To: 178,
    Replaces: 179,
    Session_Expires: 210,
    stun_URI: 217,
    To: 192,
    turn_URI: 223,
    uuid: 226,
    WWW_Authenticate: 209,
    challenge: 158,
    sipfrag: 230,
    Referred_By: 231
  };
  var peg$startRuleIndex = 119;
  var peg$consts = ["\r\n", peg$literalExpectation("\r\n", false), /^[0-9]/, peg$classExpectation([["0", "9"]], false, false), /^[a-zA-Z]/, peg$classExpectation([["a", "z"], ["A", "Z"]], false, false), /^[0-9a-fA-F]/, peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false), /^[\0-\xFF]/, peg$classExpectation([["\0", "\xFF"]], false, false), /^["]/, peg$classExpectation(["\""], false, false), " ", peg$literalExpectation(" ", false), "\t", peg$literalExpectation("\t", false), /^[a-zA-Z0-9]/, peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false), ";", peg$literalExpectation(";", false), "/", peg$literalExpectation("/", false), "?", peg$literalExpectation("?", false), ":", peg$literalExpectation(":", false), "@", peg$literalExpectation("@", false), "&", peg$literalExpectation("&", false), "=", peg$literalExpectation("=", false), "+", peg$literalExpectation("+", false), "$", peg$literalExpectation("$", false), ",", peg$literalExpectation(",", false), "-", peg$literalExpectation("-", false), "_", peg$literalExpectation("_", false), ".", peg$literalExpectation(".", false), "!", peg$literalExpectation("!", false), "~", peg$literalExpectation("~", false), "*", peg$literalExpectation("*", false), "'", peg$literalExpectation("'", false), "(", peg$literalExpectation("(", false), ")", peg$literalExpectation(")", false), "%", peg$literalExpectation("%", false), function () {
    return " ";
  }, function () {
    return ':';
  }, /^[!-~]/, peg$classExpectation([["!", "~"]], false, false), /^[\x80-\uFFFF]/, peg$classExpectation([["\x80", "\uFFFF"]], false, false), /^[\x80-\xBF]/, peg$classExpectation([["\x80", "\xBF"]], false, false), /^[a-f]/, peg$classExpectation([["a", "f"]], false, false), "`", peg$literalExpectation("`", false), "<", peg$literalExpectation("<", false), ">", peg$literalExpectation(">", false), "\\", peg$literalExpectation("\\", false), "[", peg$literalExpectation("[", false), "]", peg$literalExpectation("]", false), "{", peg$literalExpectation("{", false), "}", peg$literalExpectation("}", false), function () {
    return "*";
  }, function () {
    return "/";
  }, function () {
    return "=";
  }, function () {
    return "(";
  }, function () {
    return ")";
  }, function () {
    return ">";
  }, function () {
    return "<";
  }, function () {
    return ",";
  }, function () {
    return ";";
  }, function () {
    return ":";
  }, function () {
    return "\"";
  }, /^[!-']/, peg$classExpectation([["!", "'"]], false, false), /^[*-[]/, peg$classExpectation([["*", "["]], false, false), /^[\]-~]/, peg$classExpectation([["]", "~"]], false, false), function (contents) {
    return contents;
  }, /^[#-[]/, peg$classExpectation([["#", "["]], false, false), /^[\0-\t]/, peg$classExpectation([["\0", "\t"]], false, false), /^[\x0B-\f]/, peg$classExpectation([["\x0B", "\f"]], false, false), /^[\x0E-\x7F]/, peg$classExpectation([["\x0E", "\x7F"]], false, false), function () {
    options = options || {
      data: {}
    };
    options.data.uri = new _uri.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
    delete options.data.scheme;
    delete options.data.user;
    delete options.data.host;
    delete options.data.host_type;
    delete options.data.port;
  }, function () {
    options = options || {
      data: {}
    };
    options.data.uri = new _uri.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
    delete options.data.scheme;
    delete options.data.user;
    delete options.data.host;
    delete options.data.host_type;
    delete options.data.port;
    delete options.data.uri_params;

    if (options.startRule === 'SIP_URI') {
      options.data = options.data.uri;
    }
  }, "sips", peg$literalExpectation("sips", true), "sip", peg$literalExpectation("sip", true), function (uri_scheme) {
    options = options || {
      data: {}
    };
    options.data.scheme = uri_scheme;
  }, function () {
    options = options || {
      data: {}
    };
    options.data.user = decodeURIComponent(text().slice(0, -1));
  }, function () {
    options = options || {
      data: {}
    };
    options.data.password = text();
  }, function () {
    options = options || {
      data: {}
    };
    options.data.host = text();
    return options.data.host;
  }, function () {
    options = options || {
      data: {}
    };
    options.data.host_type = 'domain';
    return text();
  }, /^[a-zA-Z0-9_\-]/, peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false), /^[a-zA-Z0-9\-]/, peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false), function () {
    options = options || {
      data: {}
    };
    options.data.host_type = 'IPv6';
    return text();
  }, "::", peg$literalExpectation("::", false), function () {
    options = options || {
      data: {}
    };
    options.data.host_type = 'IPv6';
    return text();
  }, function () {
    options = options || {
      data: {}
    };
    options.data.host_type = 'IPv4';
    return text();
  }, "25", peg$literalExpectation("25", false), /^[0-5]/, peg$classExpectation([["0", "5"]], false, false), "2", peg$literalExpectation("2", false), /^[0-4]/, peg$classExpectation([["0", "4"]], false, false), "1", peg$literalExpectation("1", false), /^[1-9]/, peg$classExpectation([["1", "9"]], false, false), function (port) {
    options = options || {
      data: {}
    };
    port = parseInt(port.join(''));
    options.data.port = port;
    return port;
  }, "transport=", peg$literalExpectation("transport=", true), "udp", peg$literalExpectation("udp", true), "tcp", peg$literalExpectation("tcp", true), "sctp", peg$literalExpectation("sctp", true), "tls", peg$literalExpectation("tls", true), function (transport) {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};
    options.data.uri_params['transport'] = transport.toLowerCase();
  }, "user=", peg$literalExpectation("user=", true), "phone", peg$literalExpectation("phone", true), "ip", peg$literalExpectation("ip", true), function (user) {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};
    options.data.uri_params['user'] = user.toLowerCase();
  }, "method=", peg$literalExpectation("method=", true), function (method) {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};
    options.data.uri_params['method'] = method;
  }, "ttl=", peg$literalExpectation("ttl=", true), function (ttl) {
    options = options || {
      data: {}
    };
    if (!options.data.params) options.data.params = {};
    options.data.params['ttl'] = ttl;
  }, "maddr=", peg$literalExpectation("maddr=", true), function (maddr) {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};
    options.data.uri_params['maddr'] = maddr;
  }, "lr", peg$literalExpectation("lr", true), function () {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};
    options.data.uri_params['lr'] = undefined;
  }, function (param, value) {
    options = options || {
      data: {}
    };
    if (!options.data.uri_params) options.data.uri_params = {};

    if (value === null) {
      value = undefined;
    } else {
      value = value[1];
    }

    options.data.uri_params[param.toLowerCase()] = value;
  }, function (hname, hvalue) {
    hname = hname.join('').toLowerCase();
    hvalue = hvalue.join('');
    options = options || {
      data: {}
    };
    if (!options.data.uri_headers) options.data.uri_headers = {};

    if (!options.data.uri_headers[hname]) {
      options.data.uri_headers[hname] = [hvalue];
    } else {
      options.data.uri_headers[hname].push(hvalue);
    }
  }, function () {
    options = options || {
      data: {}
    }; // lots of tests fail if this isn't guarded...

    if (options.startRule === 'Refer_To') {
      options.data.uri = new _uri.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
      delete options.data.scheme;
      delete options.data.user;
      delete options.data.host;
      delete options.data.host_type;
      delete options.data.port;
      delete options.data.uri_params;
    }
  }, "//", peg$literalExpectation("//", false), function () {
    options = options || {
      data: {}
    };
    options.data.scheme = text();
  }, peg$literalExpectation("SIP", true), function () {
    options = options || {
      data: {}
    };
    options.data.sip_version = text();
  }, "INVITE", peg$literalExpectation("INVITE", false), "ACK", peg$literalExpectation("ACK", false), "VXACH", peg$literalExpectation("VXACH", false), "OPTIONS", peg$literalExpectation("OPTIONS", false), "BYE", peg$literalExpectation("BYE", false), "CANCEL", peg$literalExpectation("CANCEL", false), "REGISTER", peg$literalExpectation("REGISTER", false), "SUBSCRIBE", peg$literalExpectation("SUBSCRIBE", false), "NOTIFY", peg$literalExpectation("NOTIFY", false), "REFER", peg$literalExpectation("REFER", false), "PUBLISH", peg$literalExpectation("PUBLISH", false), function () {
    options = options || {
      data: {}
    };
    options.data.method = text();
    return options.data.method;
  }, function (status_code) {
    options = options || {
      data: {}
    };
    options.data.status_code = parseInt(status_code.join(''));
  }, function () {
    options = options || {
      data: {}
    };
    options.data.reason_phrase = text();
  }, function () {
    options = options || {
      data: {}
    };
    options.data = text();
  }, function () {
    var idx, length;
    options = options || {
      data: {}
    };
    length = options.data.multi_header.length;

    for (idx = 0; idx < length; idx++) {
      if (options.data.multi_header[idx].parsed === null) {
        options.data = null;
        break;
      }
    }

    if (options.data !== null) {
      options.data = options.data.multi_header;
    } else {
      options.data = -1;
    }
  }, function () {
    var header;
    options = options || {
      data: {}
    };
    if (!options.data.multi_header) options.data.multi_header = [];

    try {
      header = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
      delete options.data.uri;
      delete options.data.displayName;
      delete options.data.params;
    } catch (e) {
      header = null;
    }

    options.data.multi_header.push({
      'position': peg$currPos,
      'offset': location().start.offset,
      'parsed': header
    });
  }, function (displayName) {
    displayName = text().trim();

    if (displayName[0] === '\"') {
      displayName = displayName.substring(1, displayName.length - 1);
    }

    options = options || {
      data: {}
    };
    options.data.displayName = displayName;
  }, "q", peg$literalExpectation("q", true), function (q) {
    options = options || {
      data: {}
    };
    if (!options.data.params) options.data.params = {};
    options.data.params['q'] = q;
  }, "expires", peg$literalExpectation("expires", true), function (expires) {
    options = options || {
      data: {}
    };
    if (!options.data.params) options.data.params = {};
    options.data.params['expires'] = expires;
  }, function (delta_seconds) {
    return parseInt(delta_seconds.join(''));
  }, "0", peg$literalExpectation("0", false), function () {
    return parseFloat(text());
  }, function (param, value) {
    options = options || {
      data: {}
    };
    if (!options.data.params) options.data.params = {};

    if (value === null) {
      value = undefined;
    } else {
      value = value[1];
    }

    options.data.params[param.toLowerCase()] = value;
  }, "render", peg$literalExpectation("render", true), "session", peg$literalExpectation("session", true), "icon", peg$literalExpectation("icon", true), "alert", peg$literalExpectation("alert", true), function () {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Content_Disposition') {
      options.data.type = text().toLowerCase();
    }
  }, "handling", peg$literalExpectation("handling", true), "optional", peg$literalExpectation("optional", true), "required", peg$literalExpectation("required", true), function (length) {
    options = options || {
      data: {}
    };
    options.data = parseInt(length.join(''));
  }, function () {
    options = options || {
      data: {}
    };
    options.data = text();
  }, "text", peg$literalExpectation("text", true), "image", peg$literalExpectation("image", true), "audio", peg$literalExpectation("audio", true), "video", peg$literalExpectation("video", true), "application", peg$literalExpectation("application", true), "message", peg$literalExpectation("message", true), "multipart", peg$literalExpectation("multipart", true), "x-", peg$literalExpectation("x-", true), function (cseq_value) {
    options = options || {
      data: {}
    };
    options.data.value = parseInt(cseq_value.join(''));
  }, function (expires) {
    options = options || {
      data: {}
    };
    options.data = expires;
  }, function (event_type) {
    options = options || {
      data: {}
    };
    options.data.event = event_type.toLowerCase();
  }, function () {
    options = options || {
      data: {}
    };
    var tag = options.data.tag;
    options.data = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);

    if (tag) {
      options.data.setParam('tag', tag);
    }
  }, "tag", peg$literalExpectation("tag", true), function (tag) {
    options = options || {
      data: {}
    };
    options.data.tag = tag;
  }, function (forwards) {
    options = options || {
      data: {}
    };
    options.data = parseInt(forwards.join(''));
  }, function (min_expires) {
    options = options || {
      data: {}
    };
    options.data = min_expires;
  }, function () {
    options = options || {
      data: {}
    };
    options.data = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
  }, "digest", peg$literalExpectation("Digest", true), "realm", peg$literalExpectation("realm", true), function (realm) {
    options = options || {
      data: {}
    };
    options.data.realm = realm;
  }, "domain", peg$literalExpectation("domain", true), "nonce", peg$literalExpectation("nonce", true), function (nonce) {
    options = options || {
      data: {}
    };
    options.data.nonce = nonce;
  }, "opaque", peg$literalExpectation("opaque", true), function (opaque) {
    options = options || {
      data: {}
    };
    options.data.opaque = opaque;
  }, "stale", peg$literalExpectation("stale", true), "true", peg$literalExpectation("true", true), function () {
    options = options || {
      data: {}
    };
    options.data.stale = true;
  }, "false", peg$literalExpectation("false", true), function () {
    options = options || {
      data: {}
    };
    options.data.stale = false;
  }, "algorithm", peg$literalExpectation("algorithm", true), "md5", peg$literalExpectation("MD5", true), "md5-sess", peg$literalExpectation("MD5-sess", true), function (algorithm) {
    options = options || {
      data: {}
    };
    options.data.algorithm = algorithm.toUpperCase();
  }, "qop", peg$literalExpectation("qop", true), "auth-int", peg$literalExpectation("auth-int", true), "auth", peg$literalExpectation("auth", true), function (qop_value) {
    options = options || {
      data: {}
    };
    options.data.qop || (options.data.qop = []);
    options.data.qop.push(qop_value.toLowerCase());
  }, function (rack_value) {
    options = options || {
      data: {}
    };
    options.data.value = parseInt(rack_value.join(''));
  }, function () {
    var idx, length;
    options = options || {
      data: {}
    };
    length = options.data.multi_header.length;

    for (idx = 0; idx < length; idx++) {
      if (options.data.multi_header[idx].parsed === null) {
        options.data = null;
        break;
      }
    }

    if (options.data !== null) {
      options.data = options.data.multi_header;
    } else {
      options.data = -1;
    }
  }, function () {
    var header;
    options = options || {
      data: {}
    };
    if (!options.data.multi_header) options.data.multi_header = [];

    try {
      header = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
      delete options.data.uri;
      delete options.data.displayName;
      delete options.data.params;
    } catch (e) {
      header = null;
    }

    options.data.multi_header.push({
      'position': peg$currPos,
      'offset': location().start.offset,
      'parsed': header
    });
  }, function () {
    options = options || {
      data: {}
    };
    options.data = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
  }, function () {
    options = options || {
      data: {}
    };

    if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
      options.data = -1;
    }
  }, function () {
    options = options || {
      data: {}
    };
    options.data = {
      call_id: options.data
    };
  }, "from-tag", peg$literalExpectation("from-tag", true), function (from_tag) {
    options = options || {
      data: {}
    };
    options.data.replaces_from_tag = from_tag;
  }, "to-tag", peg$literalExpectation("to-tag", true), function (to_tag) {
    options = options || {
      data: {}
    };
    options.data.replaces_to_tag = to_tag;
  }, "early-only", peg$literalExpectation("early-only", true), function () {
    options = options || {
      data: {}
    };
    options.data.early_only = true;
  }, function (head, r) {
    return r;
  }, function (head, tail) {
    return list(head, tail);
  }, function (value) {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Require') {
      options.data = value || [];
    }
  }, function (rseq_value) {
    options = options || {
      data: {}
    };
    options.data.value = parseInt(rseq_value.join(''));
  }, "active", peg$literalExpectation("active", true), "pending", peg$literalExpectation("pending", true), "terminated", peg$literalExpectation("terminated", true), function () {
    options = options || {
      data: {}
    };
    options.data.state = text();
  }, "reason", peg$literalExpectation("reason", true), function (reason) {
    options = options || {
      data: {}
    };
    if (typeof reason !== 'undefined') options.data.reason = reason;
  }, function (expires) {
    options = options || {
      data: {}
    };
    if (typeof expires !== 'undefined') options.data.expires = expires;
  }, "retry_after", peg$literalExpectation("retry_after", true), function (retry_after) {
    options = options || {
      data: {}
    };
    if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after;
  }, "deactivated", peg$literalExpectation("deactivated", true), "probation", peg$literalExpectation("probation", true), "rejected", peg$literalExpectation("rejected", true), "timeout", peg$literalExpectation("timeout", true), "giveup", peg$literalExpectation("giveup", true), "noresource", peg$literalExpectation("noresource", true), "invariant", peg$literalExpectation("invariant", true), function (value) {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Supported') {
      options.data = value || [];
    }
  }, function () {
    options = options || {
      data: {}
    };
    var tag = options.data.tag;
    options.data = new _nameAddrHeader.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);

    if (tag) {
      options.data.setParam('tag', tag);
    }
  }, "ttl", peg$literalExpectation("ttl", true), function (via_ttl_value) {
    options = options || {
      data: {}
    };
    options.data.ttl = via_ttl_value;
  }, "maddr", peg$literalExpectation("maddr", true), function (via_maddr) {
    options = options || {
      data: {}
    };
    options.data.maddr = via_maddr;
  }, "received", peg$literalExpectation("received", true), function (via_received) {
    options = options || {
      data: {}
    };
    options.data.received = via_received;
  }, "branch", peg$literalExpectation("branch", true), function (via_branch) {
    options = options || {
      data: {}
    };
    options.data.branch = via_branch;
  }, "rport", peg$literalExpectation("rport", true), function (response_port) {
    options = options || {
      data: {}
    };
    if (typeof response_port !== 'undefined') options.data.rport = response_port.join('');
  }, function (via_protocol) {
    options = options || {
      data: {}
    };
    options.data.protocol = via_protocol;
  }, peg$literalExpectation("UDP", true), peg$literalExpectation("TCP", true), peg$literalExpectation("TLS", true), peg$literalExpectation("SCTP", true), function (via_transport) {
    options = options || {
      data: {}
    };
    options.data.transport = via_transport;
  }, function () {
    options = options || {
      data: {}
    };
    options.data.host = text();
  }, function (via_sent_by_port) {
    options = options || {
      data: {}
    };
    options.data.port = parseInt(via_sent_by_port.join(''));
  }, function (ttl) {
    return parseInt(ttl.join(''));
  }, function (deltaSeconds) {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Session_Expires') {
      options.data.deltaSeconds = deltaSeconds;
    }
  }, "refresher", peg$literalExpectation("refresher", false), "uas", peg$literalExpectation("uas", false), "uac", peg$literalExpectation("uac", false), function (endpoint) {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Session_Expires') {
      options.data.refresher = endpoint;
    }
  }, function (deltaSeconds) {
    options = options || {
      data: {}
    };

    if (options.startRule === 'Min_SE') {
      options.data = deltaSeconds;
    }
  }, "stuns", peg$literalExpectation("stuns", true), "stun", peg$literalExpectation("stun", true), function (scheme) {
    options = options || {
      data: {}
    };
    options.data.scheme = scheme;
  }, function (host) {
    options = options || {
      data: {}
    };
    options.data.host = host;
  }, "?transport=", peg$literalExpectation("?transport=", false), "turns", peg$literalExpectation("turns", true), "turn", peg$literalExpectation("turn", true), function (transport) {
    options = options || {
      data: {}
    };
    options.data.transport = transport;
  }, function () {
    options = options || {
      data: {}
    };
    options.data = text();
  }, "Referred-By", peg$literalExpectation("Referred-By", false), "b", peg$literalExpectation("b", false), "cid", peg$literalExpectation("cid", false)];
  var peg$bytecode = [peg$decode("2 \"\"6 7!"), peg$decode("4\"\"\"5!7#"), peg$decode("4$\"\"5!7%"), peg$decode("4&\"\"5!7'"), peg$decode(";'.# &;("), peg$decode("4(\"\"5!7)"), peg$decode("4*\"\"5!7+"), peg$decode("2,\"\"6,7-"), peg$decode("2.\"\"6.7/"), peg$decode("40\"\"5!71"), peg$decode("22\"\"6273.\x89 &24\"\"6475.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"), peg$decode(";).# &;,"), peg$decode("2F\"\"6F7G.} &2H\"\"6H7I.q &2J\"\"6J7K.e &2L\"\"6L7M.Y &2N\"\"6N7O.M &2P\"\"6P7Q.A &2R\"\"6R7S.5 &2T\"\"6T7U.) &2V\"\"6V7W"), peg$decode("%%2X\"\"6X7Y/5#;#/,$;#/#$+#)(#'#(\"'#&'#/\"!&,)"), peg$decode("%%$;$0#*;$&/,#; /#$+\")(\"'#&'#.\" &\"/=#$;$/&#0#*;$&&&#/'$8\":Z\" )(\"'#&'#"), peg$decode(";..\" &\""), peg$decode("%$;'.# &;(0)*;'.# &;(&/?#28\"\"6879/0$;//'$8#:[# )(#'#(\"'#&'#"), peg$decode("%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\")(\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"), peg$decode("4\\\"\"5!7].# &;3"), peg$decode("4^\"\"5!7_"), peg$decode("4`\"\"5!7a"), peg$decode(";!.) &4b\"\"5!7c"), peg$decode("%$;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x9E#0\x9B*;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"), peg$decode("%$;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x92#0\x8F*;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"), peg$decode("2T\"\"6T7U.\xE3 &2V\"\"6V7W.\xD7 &2f\"\"6f7g.\xCB &2h\"\"6h7i.\xBF &2:\"\"6:7;.\xB3 &2D\"\"6D7E.\xA7 &22\"\"6273.\x9B &28\"\"6879.\x8F &2j\"\"6j7k.\x83 &;&.} &24\"\"6475.q &2l\"\"6l7m.e &2n\"\"6n7o.Y &26\"\"6677.M &2>\"\"6>7?.A &2p\"\"6p7q.5 &2r\"\"6r7s.) &;'.# &;("), peg$decode("%$;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s/\u0134#0\u0131*;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s&&&#/\"!&,)"), peg$decode("%;//?#2P\"\"6P7Q/0$;//'$8#:t# )(#'#(\"'#&'#"), peg$decode("%;//?#24\"\"6475/0$;//'$8#:u# )(#'#(\"'#&'#"), peg$decode("%;//?#2>\"\"6>7?/0$;//'$8#:v# )(#'#(\"'#&'#"), peg$decode("%;//?#2T\"\"6T7U/0$;//'$8#:w# )(#'#(\"'#&'#"), peg$decode("%;//?#2V\"\"6V7W/0$;//'$8#:x# )(#'#(\"'#&'#"), peg$decode("%2h\"\"6h7i/0#;//'$8\":y\" )(\"'#&'#"), peg$decode("%;//6#2f\"\"6f7g/'$8\":z\" )(\"'#&'#"), peg$decode("%;//?#2D\"\"6D7E/0$;//'$8#:{# )(#'#(\"'#&'#"), peg$decode("%;//?#22\"\"6273/0$;//'$8#:|# )(#'#(\"'#&'#"), peg$decode("%;//?#28\"\"6879/0$;//'$8#:}# )(#'#(\"'#&'#"), peg$decode("%;//0#;&/'$8\":~\" )(\"'#&'#"), peg$decode("%;&/0#;//'$8\":~\" )(\"'#&'#"), peg$decode("%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\"'#&'#"), peg$decode("4\x7F\"\"5!7\x80.A &4\x81\"\"5!7\x82.5 &4\x83\"\"5!7\x84.) &;3.# &;."), peg$decode("%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\"'#&'#/\"!&,)"), peg$decode("%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\"!&,)/1$;&/($8$:\x85$!!)($'#(#'#(\"'#&'#"), peg$decode(";..G &2L\"\"6L7M.; &4\x86\"\"5!7\x87./ &4\x83\"\"5!7\x84.# &;3"), peg$decode("%2j\"\"6j7k/J#4\x88\"\"5!7\x89.5 &4\x8A\"\"5!7\x8B.) &4\x8C\"\"5!7\x8D/#$+\")(\"'#&'#"), peg$decode("%;N/M#28\"\"6879/>$;O.\" &\"/0$;S/'$8$:\x8E$ )($'#(#'#(\"'#&'#"), peg$decode("%;N/d#28\"\"6879/U$;O.\" &\"/G$;S/>$;_/5$;l.\" &\"/'$8&:\x8F& )(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%3\x90\"\"5$7\x91.) &3\x92\"\"5#7\x93/' 8!:\x94!! )"), peg$decode("%;P/]#%28\"\"6879/,#;R/#$+\")(\"'#&'#.\" &\"/6$2:\"\"6:7;/'$8#:\x95# )(#'#(\"'#&'#"), peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"), peg$decode("2<\"\"6<7=.q &2>\"\"6>7?.e &2@\"\"6@7A.Y &2B\"\"6B7C.M &2D\"\"6D7E.A &22\"\"6273.5 &26\"\"6677.) &24\"\"6475"), peg$decode("%$;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E0e*;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E&/& 8!:\x96! )"), peg$decode("%;T/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"), peg$decode("%;U.) &;\\.# &;X/& 8!:\x97! )"), peg$decode("%$%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#0<*%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#&/D#;W/;$2J\"\"6J7K.\" &\"/'$8#:\x98# )(#'#(\"'#&'#"), peg$decode("$4\x99\"\"5!7\x9A/,#0)*4\x99\"\"5!7\x9A&&&#"), peg$decode("%4$\"\"5!7%/?#$4\x9B\"\"5!7\x9C0)*4\x9B\"\"5!7\x9C&/#$+\")(\"'#&'#"), peg$decode("%2l\"\"6l7m/?#;Y/6$2n\"\"6n7o/'$8#:\x9D# )(#'#(\"'#&'#"), peg$decode("%%;Z/\xB3#28\"\"6879/\xA4$;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0790 &%2\x9E\"\"6\x9E7\x9F/\xA4#;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u06F9 &%2\x9E\"\"6\x9E7\x9F/\x8C#;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u067A &%2\x9E\"\"6\x9E7\x9F/t#;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0613 &%2\x9E\"\"6\x9E7\x9F/\\#;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\"'#&'#.\u05C4 &%2\x9E\"\"6\x9E7\x9F/D#;Z/;$28\"\"6879/,$;[/#$+$)($'#(#'#(\"'#&'#.\u058D &%2\x9E\"\"6\x9E7\x9F/,#;[/#$+\")(\"'#&'#.\u056E &%2\x9E\"\"6\x9E7\x9F/,#;Z/#$+\")(\"'#&'#.\u054F &%;Z/\x9B#2\x9E\"\"6\x9E7\x9F/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u04C7 &%;Z/\xAA#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x83$2\x9E\"\"6\x9E7\x9F/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0430 &%;Z/\xB9#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x92$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/k$2\x9E\"\"6\x9E7\x9F/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u038A &%;Z/\xC8#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA1$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/z$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/S$2\x9E\"\"6\x9E7\x9F/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u02D5 &%;Z/\xD7#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0211 &%;Z/\xFE#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xD7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0126 &%;Z/\u011C#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xF5$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xCE$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x80$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/Y$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/2$2\x9E\"\"6\x9E7\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/& 8!:\xA0! )"), peg$decode("%;#/M#;#.\" &\"/?$;#.\" &\"/1$;#.\" &\"/#$+$)($'#(#'#(\"'#&'#"), peg$decode("%;Z/;#28\"\"6879/,$;Z/#$+#)(#'#(\"'#&'#.# &;\\"), peg$decode("%;]/o#2J\"\"6J7K/`$;]/W$2J\"\"6J7K/H$;]/?$2J\"\"6J7K/0$;]/'$8':\xA1' )(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%2\xA2\"\"6\xA27\xA3/2#4\xA4\"\"5!7\xA5/#$+\")(\"'#&'#.\x98 &%2\xA6\"\"6\xA67\xA7/;#4\xA8\"\"5!7\xA9/,$;!/#$+#)(#'#(\"'#&'#.j &%2\xAA\"\"6\xAA7\xAB/5#;!/,$;!/#$+#)(#'#(\"'#&'#.B &%4\xAC\"\"5!7\xAD/,#;!/#$+\")(\"'#&'#.# &;!"), peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\xAE!! )"), peg$decode("$%22\"\"6273/,#;`/#$+\")(\"'#&'#0<*%22\"\"6273/,#;`/#$+\")(\"'#&'#&"), peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"), peg$decode("%3\xAF\"\"5*7\xB0/a#3\xB1\"\"5#7\xB2.G &3\xB3\"\"5#7\xB4.; &3\xB5\"\"5$7\xB6./ &3\xB7\"\"5#7\xB8.# &;6/($8\":\xB9\"! )(\"'#&'#"), peg$decode("%3\xBA\"\"5%7\xBB/I#3\xBC\"\"5%7\xBD./ &3\xBE\"\"5\"7\xBF.# &;6/($8\":\xC0\"! )(\"'#&'#"), peg$decode("%3\xC1\"\"5'7\xC2/1#;\x90/($8\":\xC3\"! )(\"'#&'#"), peg$decode("%3\xC4\"\"5$7\xC5/1#;\xF0/($8\":\xC6\"! )(\"'#&'#"), peg$decode("%3\xC7\"\"5&7\xC8/1#;T/($8\":\xC9\"! )(\"'#&'#"), peg$decode("%3\xCA\"\"5\"7\xCB/N#%2>\"\"6>7?/,#;6/#$+\")(\"'#&'#.\" &\"/'$8\":\xCC\" )(\"'#&'#"), peg$decode("%;h/P#%2>\"\"6>7?/,#;i/#$+\")(\"'#&'#.\" &\"/)$8\":\xCD\"\"! )(\"'#&'#"), peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"), peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"), peg$decode(";k.) &;+.# &;-"), peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &28\"\"6879.A &2<\"\"6<7=.5 &2@\"\"6@7A.) &2B\"\"6B7C"), peg$decode("%26\"\"6677/n#;m/e$$%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#0<*%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"), peg$decode("%;n/A#2>\"\"6>7?/2$;o/)$8#:\xCE#\"\" )(#'#(\"'#&'#"), peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"), peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"), peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &26\"\"6677.A &28\"\"6879.5 &2@\"\"6@7A.) &2B\"\"6B7C"), peg$decode(";\x91.# &;r"), peg$decode("%;\x90/G#;'/>$;s/5$;'/,$;\x84/#$+%)(%'#($'#(#'#(\"'#&'#"), peg$decode(";M.# &;t"), peg$decode("%;\x7F/E#28\"\"6879/6$;u.# &;x/'$8#:\xCF# )(#'#(\"'#&'#"), peg$decode("%;v.# &;w/J#%26\"\"6677/,#;\x83/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"), peg$decode("%2\xD0\"\"6\xD07\xD1/:#;\x80/1$;w.\" &\"/#$+#)(#'#(\"'#&'#"), peg$decode("%24\"\"6475/,#;{/#$+\")(\"'#&'#"), peg$decode("%;z/3#$;y0#*;y&/#$+\")(\"'#&'#"), peg$decode(";*.) &;+.# &;-"), peg$decode(";+.\x8F &;-.\x89 &22\"\"6273.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"), peg$decode("%;|/e#$%24\"\"6475/,#;|/#$+\")(\"'#&'#0<*%24\"\"6475/,#;|/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%$;~0#*;~&/e#$%22\"\"6273/,#;}/#$+\")(\"'#&'#0<*%22\"\"6273/,#;}/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("$;~0#*;~&"), peg$decode(";+.w &;-.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"), peg$decode("%%;\"/\x87#$;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K0M*;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K&/#$+\")(\"'#&'#/& 8!:\xD2! )"), peg$decode(";\x81.# &;\x82"), peg$decode("%%;O/2#2:\"\"6:7;/#$+\")(\"'#&'#.\" &\"/,#;S/#$+\")(\"'#&'#.\" &\""), peg$decode("$;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A/\x8C#0\x89*;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A&&&#"), peg$decode("$;y0#*;y&"), peg$decode("%3\x92\"\"5#7\xD3/q#24\"\"6475/b$$;!/&#0#*;!&&&#/L$2J\"\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\xD4% )(%'#($'#(#'#(\"'#&'#"), peg$decode("2\xD5\"\"6\xD57\xD6"), peg$decode("2\xD7\"\"6\xD77\xD8"), peg$decode("2\xD9\"\"6\xD97\xDA"), peg$decode("2\xDB\"\"6\xDB7\xDC"), peg$decode("2\xDD\"\"6\xDD7\xDE"), peg$decode("2\xDF\"\"6\xDF7\xE0"), peg$decode("2\xE1\"\"6\xE17\xE2"), peg$decode("2\xE3\"\"6\xE37\xE4"), peg$decode("2\xE5\"\"6\xE57\xE6"), peg$decode("2\xE7\"\"6\xE77\xE8"), peg$decode("2\xE9\"\"6\xE97\xEA"), peg$decode("%;\x85.Y &;\x86.S &;\x88.M &;\x89.G &;\x8A.A &;\x8B.; &;\x8C.5 &;\x8F./ &;\x8D.) &;\x8E.# &;6/& 8!:\xEB! )"), peg$decode("%;\x84/G#;'/>$;\x92/5$;'/,$;\x94/#$+%)(%'#($'#(#'#(\"'#&'#"), peg$decode("%;\x93/' 8!:\xEC!! )"), peg$decode("%;!/5#;!/,$;!/#$+#)(#'#(\"'#&'#"), peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\xED! )"), peg$decode("%;\xB6/Y#$%;A/,#;\xB6/#$+\")(\"'#&'#06*%;A/,#;\xB6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%;9/N#%2:\"\"6:7;/,#;9/#$+\")(\"'#&'#.\" &\"/'$8\":\xEE\" )(\"'#&'#"), peg$decode("%;:.c &%;\x98/Y#$%;A/,#;\x98/#$+\")(\"'#&'#06*%;A/,#;\x98/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/& 8!:\xEF! )"), peg$decode("%;L.# &;\x99/]#$%;B/,#;\x9B/#$+\")(\"'#&'#06*%;B/,#;\x9B/#$+\")(\"'#&'#&/'$8\":\xF0\" )(\"'#&'#"), peg$decode("%;\x9A.\" &\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\"'#&'#"), peg$decode("%%;6/Y#$%;./,#;6/#$+\")(\"'#&'#06*%;./,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#.# &;H/' 8!:\xF1!! )"), peg$decode(";\x9C.) &;\x9D.# &;\xA0"), peg$decode("%3\xF2\"\"5!7\xF3/:#;</1$;\x9F/($8#:\xF4#! )(#'#(\"'#&'#"), peg$decode("%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\xF7#! )(#'#(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\xF8!! )"), peg$decode("%2\xF9\"\"6\xF97\xFA/o#%2J\"\"6J7K/M#;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/'$8\":\xFB\" )(\"'#&'#"), peg$decode("%;6/J#%;</,#;\xA1/#$+\")(\"'#&'#.\" &\"/)$8\":\xFC\"\"! )(\"'#&'#"), peg$decode(";6.) &;T.# &;H"), peg$decode("%;\xA3/Y#$%;B/,#;\xA4/#$+\")(\"'#&'#06*%;B/,#;\xA4/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%3\xFD\"\"5&7\xFE.G &3\xFF\"\"5'7\u0100.; &3\u0101\"\"5$7\u0102./ &3\u0103\"\"5%7\u0104.# &;6/& 8!:\u0105! )"), peg$decode(";\xA5.# &;\xA0"), peg$decode("%3\u0106\"\"5(7\u0107/M#;</D$3\u0108\"\"5(7\u0109./ &3\u010A\"\"5(7\u010B.# &;6/#$+#)(#'#(\"'#&'#"), peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u010C!! )"), peg$decode("%;\xA9/& 8!:\u010D! )"), peg$decode("%;\xAA/k#;;/b$;\xAF/Y$$%;B/,#;\xB0/#$+\")(\"'#&'#06*%;B/,#;\xB0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), peg$decode(";\xAB.# &;\xAC"), peg$decode("3\u010E\"\"5$7\u010F.S &3\u0110\"\"5%7\u0111.G &3\u0112\"\"5%7\u0113.; &3\u0114\"\"5%7\u0115./ &3\u0116\"\"5+7\u0117.# &;\xAD"), peg$decode("3\u0118\"\"5'7\u0119./ &3\u011A\"\"5)7\u011B.# &;\xAD"), peg$decode(";6.# &;\xAE"), peg$decode("%3\u011C\"\"5\"7\u011D/,#;6/#$+\")(\"'#&'#"), peg$decode(";\xAD.# &;6"), peg$decode("%;6/5#;</,$;\xB1/#$+#)(#'#(\"'#&'#"), peg$decode(";6.# &;H"), peg$decode("%;\xB3/5#;./,$;\x90/#$+#)(#'#(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u011E!! )"), peg$decode("%;\x9E/' 8!:\u011F!! )"), peg$decode("%;\xB6/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u0120\"!!)(\"'#&'#"), peg$decode("%%;7/e#$%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#0<*%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"), peg$decode("%;L.# &;\x99/]#$%;B/,#;\xB8/#$+\")(\"'#&'#06*%;B/,#;\xB8/#$+\")(\"'#&'#&/'$8\":\u0121\" )(\"'#&'#"), peg$decode(";\xB9.# &;\xA0"), peg$decode("%3\u0122\"\"5#7\u0123/:#;</1$;6/($8#:\u0124#! )(#'#(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u0125!! )"), peg$decode("%;\x9E/' 8!:\u0126!! )"), peg$decode("%$;\x9A0#*;\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8%:\u0127% )(%'#($'#(#'#(\"'#&'#"), peg$decode(";\xBE"), peg$decode("%3\u0128\"\"5&7\u0129/k#;./b$;\xC1/Y$$%;A/,#;\xC1/#$+\")(\"'#&'#06*%;A/,#;\xC1/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#.# &;\xBF"), peg$decode("%;6/k#;./b$;\xC0/Y$$%;A/,#;\xC0/#$+\")(\"'#&'#06*%;A/,#;\xC0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), peg$decode("%;6/;#;</2$;6.# &;H/#$+#)(#'#(\"'#&'#"), peg$decode(";\xC2.G &;\xC4.A &;\xC6.; &;\xC8.5 &;\xC9./ &;\xCA.) &;\xCB.# &;\xC0"), peg$decode("%3\u012A\"\"5%7\u012B/5#;</,$;\xC3/#$+#)(#'#(\"'#&'#"), peg$decode("%;I/' 8!:\u012C!! )"), peg$decode("%3\u012D\"\"5&7\u012E/\x97#;</\x8E$;D/\x85$;\xC5/|$$%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode(";t.# &;w"), peg$decode("%3\u012F\"\"5%7\u0130/5#;</,$;\xC7/#$+#)(#'#(\"'#&'#"), peg$decode("%;I/' 8!:\u0131!! )"), peg$decode("%3\u0132\"\"5&7\u0133/:#;</1$;I/($8#:\u0134#! )(#'#(\"'#&'#"), peg$decode("%3\u0135\"\"5%7\u0136/]#;</T$%3\u0137\"\"5$7\u0138/& 8!:\u0139! ).4 &%3\u013A\"\"5%7\u013B/& 8!:\u013C! )/#$+#)(#'#(\"'#&'#"), peg$decode("%3\u013D\"\"5)7\u013E/R#;</I$3\u013F\"\"5#7\u0140./ &3\u0141\"\"5(7\u0142.# &;6/($8#:\u0143#! )(#'#(\"'#&'#"), peg$decode("%3\u0144\"\"5#7\u0145/\x93#;</\x8A$;D/\x81$%;\xCC/e#$%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#0<*%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#"), peg$decode("%3\u0146\"\"5(7\u0147./ &3\u0148\"\"5$7\u0149.# &;6/' 8!:\u014A!! )"), peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%;\xCF/G#;./>$;\xCF/5$;./,$;\x90/#$+%)(%'#($'#(#'#(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u014B!! )"), peg$decode("%;\xD1/]#$%;A/,#;\xD1/#$+\")(\"'#&'#06*%;A/,#;\xD1/#$+\")(\"'#&'#&/'$8\":\u014C\" )(\"'#&'#"), peg$decode("%;\x99/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014D\" )(\"'#&'#"), peg$decode("%;L.O &;\x99.I &%;@.\" &\"/:#;t/1$;?.\" &\"/#$+#)(#'#(\"'#&'#/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014E\" )(\"'#&'#"), peg$decode("%;\xD4/]#$%;B/,#;\xD5/#$+\")(\"'#&'#06*%;B/,#;\xD5/#$+\")(\"'#&'#&/'$8\":\u014F\" )(\"'#&'#"), peg$decode("%;\x96/& 8!:\u0150! )"), peg$decode("%3\u0151\"\"5(7\u0152/:#;</1$;6/($8#:\u0153#! )(#'#(\"'#&'#.g &%3\u0154\"\"5&7\u0155/:#;</1$;6/($8#:\u0156#! )(#'#(\"'#&'#.: &%3\u0157\"\"5*7\u0158/& 8!:\u0159! ).# &;\xA0"), peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u015C!! )"), peg$decode("%;\xD8/Y#$%;A/,#;\xD8/#$+\")(\"'#&'#06*%;A/,#;\xD8/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%;\x99/Y#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u015D!! )"), peg$decode("%;\xDB/Y#$%;B/,#;\xDC/#$+\")(\"'#&'#06*%;B/,#;\xDC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%3\u015E\"\"5&7\u015F.; &3\u0160\"\"5'7\u0161./ &3\u0162\"\"5*7\u0163.# &;6/& 8!:\u0164! )"), peg$decode("%3\u0165\"\"5&7\u0166/:#;</1$;\xDD/($8#:\u0167#! )(#'#(\"'#&'#.} &%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\u0168#! )(#'#(\"'#&'#.P &%3\u0169\"\"5+7\u016A/:#;</1$;\x9E/($8#:\u016B#! )(#'#(\"'#&'#.# &;\xA0"), peg$decode("3\u016C\"\"5+7\u016D.k &3\u016E\"\"5)7\u016F._ &3\u0170\"\"5(7\u0171.S &3\u0172\"\"5'7\u0173.G &3\u0174\"\"5&7\u0175.; &3\u0176\"\"5*7\u0177./ &3\u0178\"\"5)7\u0179.# &;6"), peg$decode(";1.\" &\""), peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u017A!! )"), peg$decode("%;L.# &;\x99/]#$%;B/,#;\xE1/#$+\")(\"'#&'#06*%;B/,#;\xE1/#$+\")(\"'#&'#&/'$8\":\u017B\" )(\"'#&'#"), peg$decode(";\xB9.# &;\xA0"), peg$decode("%;\xE3/Y#$%;A/,#;\xE3/#$+\")(\"'#&'#06*%;A/,#;\xE3/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"), peg$decode("%;\xEA/k#;./b$;\xED/Y$$%;B/,#;\xE4/#$+\")(\"'#&'#06*%;B/,#;\xE4/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), peg$decode(";\xE5.; &;\xE6.5 &;\xE7./ &;\xE8.) &;\xE9.# &;\xA0"), peg$decode("%3\u017C\"\"5#7\u017D/:#;</1$;\xF0/($8#:\u017E#! )(#'#(\"'#&'#"), peg$decode("%3\u017F\"\"5%7\u0180/:#;</1$;T/($8#:\u0181#! )(#'#(\"'#&'#"), peg$decode("%3\u0182\"\"5(7\u0183/F#;</=$;\\.) &;Y.# &;X/($8#:\u0184#! )(#'#(\"'#&'#"), peg$decode("%3\u0185\"\"5&7\u0186/:#;</1$;6/($8#:\u0187#! )(#'#(\"'#&'#"), peg$decode("%3\u0188\"\"5%7\u0189/A#;</8$$;!0#*;!&/($8#:\u018A#! )(#'#(\"'#&'#"), peg$decode("%;\xEB/G#;;/>$;6/5$;;/,$;\xEC/#$+%)(%'#($'#(#'#(\"'#&'#"), peg$decode("%3\x92\"\"5#7\xD3.# &;6/' 8!:\u018B!! )"), peg$decode("%3\xB1\"\"5#7\u018C.G &3\xB3\"\"5#7\u018D.; &3\xB7\"\"5#7\u018E./ &3\xB5\"\"5$7\u018F.# &;6/' 8!:\u0190!! )"), peg$decode("%;\xEE/D#%;C/,#;\xEF/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"), peg$decode("%;U.) &;\\.# &;X/& 8!:\u0191! )"), peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\u0192!! )"), peg$decode("%%;!/?#;!.\" &\"/1$;!.\" &\"/#$+#)(#'#(\"'#&'#/' 8!:\u0193!! )"), peg$decode(";\xBE"), peg$decode("%;\x9E/^#$%;B/,#;\xF3/#$+\")(\"'#&'#06*%;B/,#;\xF3/#$+\")(\"'#&'#&/($8\":\u0194\"!!)(\"'#&'#"), peg$decode(";\xF4.# &;\xA0"), peg$decode("%2\u0195\"\"6\u01957\u0196/L#;</C$2\u0197\"\"6\u01977\u0198.) &2\u0199\"\"6\u01997\u019A/($8#:\u019B#! )(#'#(\"'#&'#"), peg$decode("%;\x9E/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u019C\"!!)(\"'#&'#"), peg$decode("%;6/5#;0/,$;\xF7/#$+#)(#'#(\"'#&'#"), peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"), peg$decode("$;%0#*;%&"), peg$decode("%;\xFA/;#28\"\"6879/,$;\xFB/#$+#)(#'#(\"'#&'#"), peg$decode("%3\u019D\"\"5%7\u019E.) &3\u019F\"\"5$7\u01A0/' 8!:\u01A1!! )"), peg$decode("%;\xFC/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"), peg$decode("%;\\.) &;X.# &;\x82/' 8!:\u01A2!! )"), peg$decode(";\".S &;!.M &2F\"\"6F7G.A &2J\"\"6J7K.5 &2H\"\"6H7I.) &2N\"\"6N7O"), peg$decode("2L\"\"6L7M.\x95 &2B\"\"6B7C.\x89 &2<\"\"6<7=.} &2R\"\"6R7S.q &2T\"\"6T7U.e &2V\"\"6V7W.Y &2P\"\"6P7Q.M &2@\"\"6@7A.A &2D\"\"6D7E.5 &22\"\"6273.) &2>\"\"6>7?"), peg$decode("%;\u0100/b#28\"\"6879/S$;\xFB/J$%2\u01A3\"\"6\u01A37\u01A4/,#;\xEC/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#"), peg$decode("%3\u01A5\"\"5%7\u01A6.) &3\u01A7\"\"5$7\u01A8/' 8!:\u01A1!! )"), peg$decode("%3\xB1\"\"5#7\xB2.6 &3\xB3\"\"5#7\xB4.* &$;+0#*;+&/' 8!:\u01A9!! )"), peg$decode("%;\u0104/\x87#2F\"\"6F7G/x$;\u0103/o$2F\"\"6F7G/`$;\u0103/W$2F\"\"6F7G/H$;\u0103/?$2F\"\"6F7G/0$;\u0105/'$8):\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\"'#&'#"), peg$decode("%;\u0103/,#;\u0103/#$+\")(\"'#&'#"), peg$decode("%;\u0103/5#;\u0103/,$;\u0103/#$+#)(#'#(\"'#&'#"), peg$decode("%;q/T#$;m0#*;m&/D$%; /,#;\xF8/#$+\")(\"'#&'#.\" &\"/#$+#)(#'#(\"'#&'#"), peg$decode("%2\u01AB\"\"6\u01AB7\u01AC.) &2\u01AD\"\"6\u01AD7\u01AE/w#;0/n$;\u0108/e$$%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#0<*%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"), peg$decode(";\x99.# &;L"), peg$decode("%2\u01AF\"\"6\u01AF7\u01B0/5#;</,$;\u010A/#$+#)(#'#(\"'#&'#"), peg$decode("%;D/S#;,/J$2:\"\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#")];
  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{
    line: 1,
    column: 1
  }];
  var peg$maxFailPos = 0;
  var peg$maxFailExpected = [];
  var peg$silentFails = 0;
  var peg$result;

  if (options.startRule !== undefined) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location1) {
    location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
  }

  function error(message, location1) {
    location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location1);
  }

  function peg$literalExpectation(text1, ignoreCase) {
    return {
      type: "literal",
      text: text1,
      ignoreCase: ignoreCase
    };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  }

  function peg$anyExpectation() {
    return {
      type: "any"
    };
  }

  function peg$endExpectation() {
    return {
      type: "end"
    };
  }

  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      p = pos - 1;

      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected1) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected1);
  }

  function peg$buildSimpleError(message, location1) {
    return new SyntaxError(message, [], "", location1);
  }

  function peg$buildStructuredError(expected1, found, location1) {
    return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
  }

  function peg$decode(s) {
    return s.split("").map(function (ch) {
      return ch.charCodeAt(0) - 32;
    });
  }

  function peg$parseRule(index) {
    var bc = peg$bytecode[index];
    var ip = 0;
    var ips = [];
    var end = bc.length;
    var ends = [];
    var stack = [];
    var params;

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);
              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += peg$consts[bc[ip + 1]].length;
            ip += 2;
            break;

          case 23:
            stack.push(peg$FAILED);

            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]]);
            }

            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]).map(function (p) {
              return stack[stack.length - 1 - p];
            });
            stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }

  options.data = {}; // Object to which header attributes will be assigned during parsing

  function list(head, tail) {
    return [head].concat(tail);
  }

  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}

var parse = peg$parse;
exports.parse = parse;
},{"../../name-addr-header":"node_modules/sip.js/lib/grammar/name-addr-header.js","../../uri":"node_modules/sip.js/lib/grammar/uri.js"}],"node_modules/sip.js/lib/grammar/grammar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Grammar = void 0;

var pegGrammar = _interopRequireWildcard(require("./pegjs/dist/grammar"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-namespace */

/* eslint-disable no-inner-declarations */

/**
 * Grammar.
 * @internal
 */
var Grammar;
exports.Grammar = Grammar;

(function (Grammar) {
  /**
   * Parse.
   * @param input -
   * @param startRule -
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function parse(input, startRule) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var options = {
      startRule: startRule
    };

    try {
      pegGrammar.parse(input, options);
    } catch (e) {
      options.data = -1;
    }

    return options.data;
  }

  Grammar.parse = parse;
  /**
   * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
   * it is an invalid NameAddrHeader.
   * @param name_addr_header -
   */

  function nameAddrHeaderParse(nameAddrHeader) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var parsedNameAddrHeader = Grammar.parse(nameAddrHeader, "Name_Addr_Header");
    return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;
  }

  Grammar.nameAddrHeaderParse = nameAddrHeaderParse;
  /**
   * Parse the given string and returns a SIP.URI instance or undefined if
   * it is an invalid URI.
   * @param uri -
   */

  function URIParse(uri) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var parsedUri = Grammar.parse(uri, "SIP_URI");
    return parsedUri !== -1 ? parsedUri : undefined;
  }

  Grammar.URIParse = URIParse;
})(Grammar || (exports.Grammar = Grammar = {}));
},{"./pegjs/dist/grammar":"node_modules/sip.js/lib/grammar/pegjs/dist/grammar.js"}],"node_modules/sip.js/lib/grammar/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _grammar = require("./grammar");

Object.keys(_grammar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _grammar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _grammar[key];
    }
  });
});

var _nameAddrHeader = require("./name-addr-header");

Object.keys(_nameAddrHeader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nameAddrHeader[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nameAddrHeader[key];
    }
  });
});

var _parameters = require("./parameters");

Object.keys(_parameters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _parameters[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _parameters[key];
    }
  });
});

var _uri = require("./uri");

Object.keys(_uri).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _uri[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _uri[key];
    }
  });
});
},{"./grammar":"node_modules/sip.js/lib/grammar/grammar.js","./name-addr-header":"node_modules/sip.js/lib/grammar/name-addr-header.js","./parameters":"node_modules/sip.js/lib/grammar/parameters.js","./uri":"node_modules/sip.js/lib/grammar/uri.js"}],"node_modules/sip.js/lib/core/messages/methods/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.C = void 0;

/* eslint-disable @typescript-eslint/no-namespace */

/**
 * SIP Methods
 * @internal
 */
var C;
exports.C = C;

(function (C) {
  C.ACK = "ACK";
  C.BYE = "BYE";
  C.CANCEL = "CANCEL";
  C.INFO = "INFO";
  C.INVITE = "INVITE";
  C.MESSAGE = "MESSAGE";
  C.NOTIFY = "NOTIFY";
  C.OPTIONS = "OPTIONS";
  C.REGISTER = "REGISTER";
  C.UPDATE = "UPDATE";
  C.SUBSCRIBE = "SUBSCRIBE";
  C.PUBLISH = "PUBLISH";
  C.REFER = "REFER";
  C.PRACK = "PRACK";
})(C || (exports.C = C = {}));
},{}],"node_modules/sip.js/lib/core/messages/methods/ack.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/bye.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/cancel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/invite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/notify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/prack.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/publish.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/register.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/refer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/subscribe.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/methods/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constants[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});

var _ack = require("./ack");

Object.keys(_ack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ack[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ack[key];
    }
  });
});

var _bye = require("./bye");

Object.keys(_bye).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bye[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bye[key];
    }
  });
});

var _cancel = require("./cancel");

Object.keys(_cancel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cancel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cancel[key];
    }
  });
});

var _info = require("./info");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _info[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

var _invite = require("./invite");

Object.keys(_invite).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invite[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invite[key];
    }
  });
});

var _message = require("./message");

Object.keys(_message).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _message[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _message[key];
    }
  });
});

var _notify = require("./notify");

Object.keys(_notify).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _notify[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _notify[key];
    }
  });
});

var _prack = require("./prack");

Object.keys(_prack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _prack[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prack[key];
    }
  });
});

var _publish = require("./publish");

Object.keys(_publish).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publish[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publish[key];
    }
  });
});

var _register = require("./register");

Object.keys(_register).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _register[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _register[key];
    }
  });
});

var _refer = require("./refer");

Object.keys(_refer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _refer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _refer[key];
    }
  });
});

var _subscribe = require("./subscribe");

Object.keys(_subscribe).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscribe[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscribe[key];
    }
  });
});
},{"./constants":"node_modules/sip.js/lib/core/messages/methods/constants.js","./ack":"node_modules/sip.js/lib/core/messages/methods/ack.js","./bye":"node_modules/sip.js/lib/core/messages/methods/bye.js","./cancel":"node_modules/sip.js/lib/core/messages/methods/cancel.js","./info":"node_modules/sip.js/lib/core/messages/methods/info.js","./invite":"node_modules/sip.js/lib/core/messages/methods/invite.js","./message":"node_modules/sip.js/lib/core/messages/methods/message.js","./notify":"node_modules/sip.js/lib/core/messages/methods/notify.js","./prack":"node_modules/sip.js/lib/core/messages/methods/prack.js","./publish":"node_modules/sip.js/lib/core/messages/methods/publish.js","./register":"node_modules/sip.js/lib/core/messages/methods/register.js","./refer":"node_modules/sip.js/lib/core/messages/methods/refer.js","./subscribe":"node_modules/sip.js/lib/core/messages/methods/subscribe.js"}],"node_modules/sip.js/lib/core/messages/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRandomToken = createRandomToken;
exports.getReasonPhrase = getReasonPhrase;
exports.headerize = headerize;
exports.newTag = newTag;
exports.utf8Length = utf8Length;

/**
 * SIP Response Reasons
 * DOC: http://www.iana.org/assignments/sip-parameters
 * @internal
 */
var REASON_PHRASE = {
  100: "Trying",
  180: "Ringing",
  181: "Call Is Being Forwarded",
  182: "Queued",
  183: "Session Progress",
  199: "Early Dialog Terminated",
  200: "OK",
  202: "Accepted",
  204: "No Notification",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Moved Temporarily",
  305: "Use Proxy",
  380: "Alternative Service",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  410: "Gone",
  412: "Conditional Request Failed",
  413: "Request Entity Too Large",
  414: "Request-URI Too Long",
  415: "Unsupported Media Type",
  416: "Unsupported URI Scheme",
  417: "Unknown Resource-Priority",
  420: "Bad Extension",
  421: "Extension Required",
  422: "Session Interval Too Small",
  423: "Interval Too Brief",
  428: "Use Identity Header",
  429: "Provide Referrer Identity",
  430: "Flow Failed",
  433: "Anonymity Disallowed",
  436: "Bad Identity-Info",
  437: "Unsupported Certificate",
  438: "Invalid Identity Header",
  439: "First Hop Lacks Outbound Support",
  440: "Max-Breadth Exceeded",
  469: "Bad Info Package",
  470: "Consent Needed",
  478: "Unresolvable Destination",
  480: "Temporarily Unavailable",
  481: "Call/Transaction Does Not Exist",
  482: "Loop Detected",
  483: "Too Many Hops",
  484: "Address Incomplete",
  485: "Ambiguous",
  486: "Busy Here",
  487: "Request Terminated",
  488: "Not Acceptable Here",
  489: "Bad Event",
  491: "Request Pending",
  493: "Undecipherable",
  494: "Security Agreement Required",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Server Time-out",
  505: "Version Not Supported",
  513: "Message Too Large",
  580: "Precondition Failure",
  600: "Busy Everywhere",
  603: "Decline",
  604: "Does Not Exist Anywhere",
  606: "Not Acceptable"
};
/**
 * @param size -
 * @param base -
 * @internal
 */

function createRandomToken(size) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
  var token = "";

  for (var i = 0; i < size; i++) {
    var r = Math.floor(Math.random() * base);
    token += r.toString(base);
  }

  return token;
}
/**
 * @internal
 */


function getReasonPhrase(code) {
  return REASON_PHRASE[code] || "";
}
/**
 * @internal
 */


function newTag() {
  return createRandomToken(10);
}
/**
 * @param str -
 * @internal
 */


function headerize(str) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var exceptions = {
    "Call-Id": "Call-ID",
    Cseq: "CSeq",
    "Min-Se": "Min-SE",
    Rack: "RAck",
    Rseq: "RSeq",
    "Www-Authenticate": "WWW-Authenticate"
  };
  var name = str.toLowerCase().replace(/_/g, "-").split("-");
  var parts = name.length;
  var hname = "";

  for (var part = 0; part < parts; part++) {
    if (part !== 0) {
      hname += "-";
    }

    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
  }

  if (exceptions[hname]) {
    hname = exceptions[hname];
  }

  return hname;
}
/**
 * @param str -
 * @internal
 */


function utf8Length(str) {
  return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
}
},{}],"node_modules/sip.js/lib/core/messages/incoming-message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IncomingMessage = void 0;

var _grammar = require("../../grammar");

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Incoming message.
 * @public
 */
var IncomingMessage = /*#__PURE__*/function () {
  function IncomingMessage() {
    _classCallCheck(this, IncomingMessage);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.headers = {};
  }
  /**
   * Insert a header of the given name and value into the last position of the
   * header array.
   * @param name - header name
   * @param value - header value
   */


  _createClass(IncomingMessage, [{
    key: "addHeader",
    value: function addHeader(name, value) {
      var header = {
        raw: value
      };
      name = (0, _utils.headerize)(name);

      if (this.headers[name]) {
        this.headers[name].push(header);
      } else {
        this.headers[name] = [header];
      }
    }
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */

  }, {
    key: "getHeader",
    value: function getHeader(name) {
      var header = this.headers[(0, _utils.headerize)(name)];

      if (header) {
        if (header[0]) {
          return header[0].raw;
        }
      } else {
        return;
      }
    }
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array - with all the headers of the specified name.
     */

  }, {
    key: "getHeaders",
    value: function getHeaders(name) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var header = this.headers[(0, _utils.headerize)(name)];
      var result = [];

      if (!header) {
        return [];
      }

      var _iterator = _createForOfIteratorHelper(header),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var headerPart = _step.value;
          result.push(headerPart.raw);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return result;
    }
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */

  }, {
    key: "hasHeader",
    value: function hasHeader(name) {
      return !!this.headers[(0, _utils.headerize)(name)];
    }
    /**
     * Parse the given header on the given index.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "parseHeader",
    value: function parseHeader(name) {
      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      name = (0, _utils.headerize)(name);

      if (!this.headers[name]) {
        // this.logger.log("header '" + name + "' not present");
        return;
      } else if (idx >= this.headers[name].length) {
        // this.logger.log("not so many '" + name + "' headers present");
        return;
      }

      var header = this.headers[name][idx];
      var value = header.raw;

      if (header.parsed) {
        return header.parsed;
      } // substitute '-' by '_' for grammar rule matching.


      var parsed = _grammar.Grammar.parse(value, name.replace(/-/g, "_"));

      if (parsed === -1) {
        this.headers[name].splice(idx, 1); // delete from headers
        // this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');

        return;
      } else {
        header.parsed = parsed;
        return parsed;
      }
    }
    /**
     * Message Header attribute selector. Alias of parseHeader.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     *
     * @example
     * message.s('via',3).port
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "s",
    value: function s(name) {
      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.parseHeader(name, idx);
    }
    /**
     * Replace the value of the given header by the value.
     * @param name - header name
     * @param value - header value
     */

  }, {
    key: "setHeader",
    value: function setHeader(name, value) {
      this.headers[(0, _utils.headerize)(name)] = [{
        raw: value
      }];
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.data;
    }
  }]);

  return IncomingMessage;
}();

exports.IncomingMessage = IncomingMessage;
},{"../../grammar":"node_modules/sip.js/lib/grammar/index.js","./utils":"node_modules/sip.js/lib/core/messages/utils.js"}],"node_modules/sip.js/lib/core/messages/incoming-request-message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IncomingRequestMessage = void 0;

var _incomingMessage = require("./incoming-message");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Incoming request message.
 * @public
 */
var IncomingRequestMessage = /*#__PURE__*/function (_IncomingMessage) {
  _inherits(IncomingRequestMessage, _IncomingMessage);

  var _super = _createSuper(IncomingRequestMessage);

  function IncomingRequestMessage() {
    _classCallCheck(this, IncomingRequestMessage);

    return _super.call(this);
  }

  return _createClass(IncomingRequestMessage);
}(_incomingMessage.IncomingMessage);

exports.IncomingRequestMessage = IncomingRequestMessage;
},{"./incoming-message":"node_modules/sip.js/lib/core/messages/incoming-message.js"}],"node_modules/sip.js/lib/core/messages/incoming-response-message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IncomingResponseMessage = void 0;

var _incomingMessage = require("./incoming-message");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Incoming response message.
 * @public
 */
var IncomingResponseMessage = /*#__PURE__*/function (_IncomingMessage) {
  _inherits(IncomingResponseMessage, _IncomingMessage);

  var _super = _createSuper(IncomingResponseMessage);

  function IncomingResponseMessage() {
    _classCallCheck(this, IncomingResponseMessage);

    return _super.call(this);
  }

  return _createClass(IncomingResponseMessage);
}(_incomingMessage.IncomingMessage);

exports.IncomingResponseMessage = IncomingResponseMessage;
},{"./incoming-message":"node_modules/sip.js/lib/core/messages/incoming-message.js"}],"node_modules/sip.js/lib/core/messages/outgoing-request-message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OutgoingRequestMessage = void 0;

var _grammar = require("../../grammar");

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Outgoing SIP request message.
 * @public
 */
var OutgoingRequestMessage = /*#__PURE__*/function () {
  function OutgoingRequestMessage(method, ruri, fromURI, toURI, options, extraHeaders, body) {
    _classCallCheck(this, OutgoingRequestMessage);

    this.headers = {};
    this.extraHeaders = []; // Initialize default options

    this.options = OutgoingRequestMessage.getDefaultOptions(); // Options - merge a deep copy

    if (options) {
      this.options = Object.assign(Object.assign({}, this.options), options);

      if (this.options.optionTags && this.options.optionTags.length) {
        this.options.optionTags = this.options.optionTags.slice();
      }

      if (this.options.routeSet && this.options.routeSet.length) {
        this.options.routeSet = this.options.routeSet.slice();
      }
    } // Extra headers - deep copy


    if (extraHeaders && extraHeaders.length) {
      this.extraHeaders = extraHeaders.slice();
    } // Body - deep copy


    if (body) {
      // TODO: internal representation should be Body
      // this.body = { ...body };
      this.body = {
        body: body.content,
        contentType: body.contentType
      };
    } // Method


    this.method = method; // RURI

    this.ruri = ruri.clone(); // From

    this.fromURI = fromURI.clone();
    this.fromTag = this.options.fromTag ? this.options.fromTag : (0, _utils.newTag)();
    this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag); // To

    this.toURI = toURI.clone();
    this.toTag = this.options.toTag;
    this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag); // Call-ID

    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + (0, _utils.createRandomToken)(15); // CSeq

    this.cseq = this.options.cseq; // The relative order of header fields with different field names is not
    // significant.  However, it is RECOMMENDED that header fields which are
    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
    // Max-Forwards, and Proxy-Authorization, for example) appear towards
    // the top of the message to facilitate rapid parsing.
    // https://tools.ietf.org/html/rfc3261#section-7.3.1

    this.setHeader("route", this.options.routeSet);
    this.setHeader("via", "");
    this.setHeader("to", this.to.toString());
    this.setHeader("from", this.from.toString());
    this.setHeader("cseq", this.cseq + " " + this.method);
    this.setHeader("call-id", this.callId);
    this.setHeader("max-forwards", "70");
  }
  /** Get a copy of the default options. */


  _createClass(OutgoingRequestMessage, [{
    key: "getHeader",
    value:
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */
    function getHeader(name) {
      var header = this.headers[(0, _utils.headerize)(name)];

      if (header) {
        if (header[0]) {
          return header[0];
        }
      } else {
        var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");

        var _iterator = _createForOfIteratorHelper(this.extraHeaders),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var exHeader = _step.value;

            if (regexp.test(exHeader)) {
              return exHeader.substring(exHeader.indexOf(":") + 1).trim();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return;
    }
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array with all the headers of the specified name.
     */

  }, {
    key: "getHeaders",
    value: function getHeaders(name) {
      var result = [];
      var headerArray = this.headers[(0, _utils.headerize)(name)];

      if (headerArray) {
        var _iterator2 = _createForOfIteratorHelper(headerArray),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var headerPart = _step2.value;
            result.push(headerPart);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");

        var _iterator3 = _createForOfIteratorHelper(this.extraHeaders),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var exHeader = _step3.value;

            if (regexp.test(exHeader)) {
              result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }

      return result;
    }
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */

  }, {
    key: "hasHeader",
    value: function hasHeader(name) {
      if (this.headers[(0, _utils.headerize)(name)]) {
        return true;
      } else {
        var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");

        var _iterator4 = _createForOfIteratorHelper(this.extraHeaders),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var extraHeader = _step4.value;

            if (regexp.test(extraHeader)) {
              return true;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }

      return false;
    }
    /**
     * Replace the the given header by the given value.
     * @param name - header name
     * @param value - header value
     */

  }, {
    key: "setHeader",
    value: function setHeader(name, value) {
      this.headers[(0, _utils.headerize)(name)] = value instanceof Array ? value : [value];
    }
    /**
     * The Via header field indicates the transport used for the transaction
     * and identifies the location where the response is to be sent.  A Via
     * header field value is added only after the transport that will be
     * used to reach the next hop has been selected (which may involve the
     * usage of the procedures in [4]).
     *
     * When the UAC creates a request, it MUST insert a Via into that
     * request.  The protocol name and protocol version in the header field
     * MUST be SIP and 2.0, respectively.  The Via header field value MUST
     * contain a branch parameter.  This parameter is used to identify the
     * transaction created by that request.  This parameter is used by both
     * the client and the server.
     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
     * @param branchParameter - The branch parameter.
     * @param transport - The sent protocol transport.
     */

  }, {
    key: "setViaHeader",
    value: function setViaHeader(branch, transport) {
      // FIXME: Hack
      if (this.options.hackViaTcp) {
        transport = "TCP";
      }

      var via = "SIP/2.0/" + transport;
      via += " " + this.options.viaHost + ";branch=" + branch;

      if (this.options.forceRport) {
        via += ";rport";
      }

      this.setHeader("via", via);
      this.branch = branch;
    }
  }, {
    key: "toString",
    value: function toString() {
      var msg = "";
      msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";

      for (var header in this.headers) {
        if (this.headers[header]) {
          var _iterator5 = _createForOfIteratorHelper(this.headers[header]),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var headerPart = _step5.value;
              msg += header + ": " + headerPart + "\r\n";
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      }

      var _iterator6 = _createForOfIteratorHelper(this.extraHeaders),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _header = _step6.value;
          msg += _header.trim() + "\r\n";
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
      msg += "User-Agent: " + this.options.userAgentString + "\r\n";

      if (this.body) {
        if (typeof this.body === "string") {
          msg += "Content-Length: " + (0, _utils.utf8Length)(this.body) + "\r\n\r\n";
          msg += this.body;
        } else {
          if (this.body.body && this.body.contentType) {
            msg += "Content-Type: " + this.body.contentType + "\r\n";
            msg += "Content-Length: " + (0, _utils.utf8Length)(this.body.body) + "\r\n\r\n";
            msg += this.body.body;
          } else {
            msg += "Content-Length: " + 0 + "\r\n\r\n";
          }
        }
      } else {
        msg += "Content-Length: " + 0 + "\r\n\r\n";
      }

      return msg;
    }
  }], [{
    key: "getDefaultOptions",
    value: function getDefaultOptions() {
      return {
        callId: "",
        callIdPrefix: "",
        cseq: 1,
        toDisplayName: "",
        toTag: "",
        fromDisplayName: "",
        fromTag: "",
        forceRport: false,
        hackViaTcp: false,
        optionTags: ["outbound"],
        routeSet: [],
        userAgentString: "sip.js",
        viaHost: ""
      };
    }
  }, {
    key: "makeNameAddrHeader",
    value: function makeNameAddrHeader(uri, displayName, tag) {
      var parameters = {};

      if (tag) {
        parameters.tag = tag;
      }

      return new _grammar.NameAddrHeader(uri, displayName, parameters);
    }
  }]);

  return OutgoingRequestMessage;
}();

exports.OutgoingRequestMessage = OutgoingRequestMessage;
},{"../../grammar":"node_modules/sip.js/lib/grammar/index.js","./utils":"node_modules/sip.js/lib/core/messages/utils.js"}],"node_modules/sip.js/lib/core/messages/body.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromBodyLegacy = fromBodyLegacy;
exports.getBody = getBody;
exports.isBody = isBody;

var _incomingRequestMessage = require("./incoming-request-message");

var _incomingResponseMessage = require("./incoming-response-message");

var _outgoingRequestMessage = require("./outgoing-request-message");

// If the Content-Disposition header field is missing, bodies of
// Content-Type application/sdp imply the disposition "session", while
// other content types imply "render".
// https://tools.ietf.org/html/rfc3261#section-13.2.1
function contentTypeToContentDisposition(contentType) {
  if (contentType === "application/sdp") {
    return "session";
  } else {
    return "render";
  }
}
/**
 * Create a Body given a legacy body type.
 * @param bodyLegacy - Body Object
 * @internal
 */


function fromBodyLegacy(bodyLegacy) {
  var content = typeof bodyLegacy === "string" ? bodyLegacy : bodyLegacy.body;
  var contentType = typeof bodyLegacy === "string" ? "application/sdp" : bodyLegacy.contentType;
  var contentDisposition = contentTypeToContentDisposition(contentType);
  var body = {
    contentDisposition: contentDisposition,
    contentType: contentType,
    content: content
  };
  return body;
}
/**
 * User-Defined Type Guard for Body.
 * @param body - Body to check.
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any


function isBody(body) {
  return body && typeof body.content === "string" && typeof body.contentType === "string" && body.contentDisposition === undefined ? true : typeof body.contentDisposition === "string";
}
/**
 * Given a message, get a normalized body.
 * The content disposition is inferred if not set.
 * @param message - The message.
 * @internal
 */


function getBody(message) {
  var contentDisposition;
  var contentType;
  var content; // We're in UAS role, receiving incoming request

  if (message instanceof _incomingRequestMessage.IncomingRequestMessage) {
    if (message.body) {
      // FIXME: Parsing needs typing
      var parse = message.parseHeader("Content-Disposition");
      contentDisposition = parse ? parse.type : undefined;
      contentType = message.parseHeader("Content-Type");
      content = message.body;
    }
  } // We're in UAC role, receiving incoming response


  if (message instanceof _incomingResponseMessage.IncomingResponseMessage) {
    if (message.body) {
      // FIXME: Parsing needs typing
      var _parse = message.parseHeader("Content-Disposition");

      contentDisposition = _parse ? _parse.type : undefined;
      contentType = message.parseHeader("Content-Type");
      content = message.body;
    }
  } // We're in UAC role, sending outgoing request


  if (message instanceof _outgoingRequestMessage.OutgoingRequestMessage) {
    if (message.body) {
      contentDisposition = message.getHeader("Content-Disposition");
      contentType = message.getHeader("Content-Type");

      if (typeof message.body === "string") {
        // FIXME: OutgoingRequest should not allow a "string" body without a "Content-Type" header.
        if (!contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }

        content = message.body;
      } else {
        // FIXME: OutgoingRequest should not allow the "Content-Type" header not to match th body content type
        if (contentType && contentType !== message.body.contentType) {
          throw new Error("Header content type header does not equal body content type.");
        }

        contentType = message.body.contentType;
        content = message.body.body;
      }
    }
  } // We're in UAS role, sending outgoing response


  if (isBody(message)) {
    contentDisposition = message.contentDisposition;
    contentType = message.contentType;
    content = message.content;
  } // No content, no body.


  if (!content) {
    return undefined;
  }

  if (contentType && !contentDisposition) {
    contentDisposition = contentTypeToContentDisposition(contentType);
  }

  if (!contentDisposition) {
    throw new Error("Content disposition undefined.");
  }

  if (!contentType) {
    throw new Error("Content type undefined.");
  }

  return {
    contentDisposition: contentDisposition,
    contentType: contentType,
    content: content
  };
}
},{"./incoming-request-message":"node_modules/sip.js/lib/core/messages/incoming-request-message.js","./incoming-response-message":"node_modules/sip.js/lib/core/messages/incoming-response-message.js","./outgoing-request-message":"node_modules/sip.js/lib/core/messages/outgoing-request-message.js"}],"node_modules/sip.js/lib/core/messages/md5.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Md5 = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* eslint-disable */
//
// Scoped from: https://github.com/cotag/ts-md5
//

/*

TypeScript Md5
==============

Based on work by
* Joseph Myers: http://www.myersdaily.org/joseph/javascript/md5-text.html
* Andr Cruz: https://github.com/satazor/SparkMD5
* Raymond Hill: https://github.com/gorhill/yamd5.js

Effectively a TypeScrypt re-write of Raymond Hill JS Library

The MIT License (MIT)

Copyright (C) 2014 Raymond Hill

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
                    Version 2, December 2004

 Copyright (C) 2015 Andr Cruz <amdfcruz@gmail.com>

 Everyone is permitted to copy and distribute verbatim or modified
 copies of this license document, and changing it is allowed as long
 as the name is changed.

            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.


*/
var Md5 = /*#__PURE__*/function () {
  function Md5() {
    _classCallCheck(this, Md5);

    this._dataLength = 0;
    this._bufferLength = 0;
    this._state = new Int32Array(4);
    this._buffer = new ArrayBuffer(68);
    this._buffer8 = new Uint8Array(this._buffer, 0, 68);
    this._buffer32 = new Uint32Array(this._buffer, 0, 17);
    this.start();
  }

  _createClass(Md5, [{
    key: "start",
    value: function start() {
      this._dataLength = 0;
      this._bufferLength = 0;

      this._state.set(Md5.stateIdentity);

      return this;
    } // Char to code point to to array conversion:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
    // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown

  }, {
    key: "appendStr",
    value: function appendStr(str) {
      var buf8 = this._buffer8;
      var buf32 = this._buffer32;
      var bufLen = this._bufferLength;
      var code;
      var i;

      for (i = 0; i < str.length; i += 1) {
        code = str.charCodeAt(i);

        if (code < 128) {
          buf8[bufLen++] = code;
        } else if (code < 0x800) {
          buf8[bufLen++] = (code >>> 6) + 0xC0;
          buf8[bufLen++] = code & 0x3F | 0x80;
        } else if (code < 0xD800 || code > 0xDBFF) {
          buf8[bufLen++] = (code >>> 12) + 0xE0;
          buf8[bufLen++] = code >>> 6 & 0x3F | 0x80;
          buf8[bufLen++] = code & 0x3F | 0x80;
        } else {
          code = (code - 0xD800) * 0x400 + (str.charCodeAt(++i) - 0xDC00) + 0x10000;

          if (code > 0x10FFFF) {
            throw new Error('Unicode standard supports code points up to U+10FFFF');
          }

          buf8[bufLen++] = (code >>> 18) + 0xF0;
          buf8[bufLen++] = code >>> 12 & 0x3F | 0x80;
          buf8[bufLen++] = code >>> 6 & 0x3F | 0x80;
          buf8[bufLen++] = code & 0x3F | 0x80;
        }

        if (bufLen >= 64) {
          this._dataLength += 64;

          Md5._md5cycle(this._state, buf32);

          bufLen -= 64;
          buf32[0] = buf32[16];
        }
      }

      this._bufferLength = bufLen;
      return this;
    }
  }, {
    key: "appendAsciiStr",
    value: function appendAsciiStr(str) {
      var buf8 = this._buffer8;
      var buf32 = this._buffer32;
      var bufLen = this._bufferLength;
      var i;
      var j = 0;

      for (;;) {
        i = Math.min(str.length - j, 64 - bufLen);

        while (i--) {
          buf8[bufLen++] = str.charCodeAt(j++);
        }

        if (bufLen < 64) {
          break;
        }

        this._dataLength += 64;

        Md5._md5cycle(this._state, buf32);

        bufLen = 0;
      }

      this._bufferLength = bufLen;
      return this;
    }
  }, {
    key: "appendByteArray",
    value: function appendByteArray(input) {
      var buf8 = this._buffer8;
      var buf32 = this._buffer32;
      var bufLen = this._bufferLength;
      var i;
      var j = 0;

      for (;;) {
        i = Math.min(input.length - j, 64 - bufLen);

        while (i--) {
          buf8[bufLen++] = input[j++];
        }

        if (bufLen < 64) {
          break;
        }

        this._dataLength += 64;

        Md5._md5cycle(this._state, buf32);

        bufLen = 0;
      }

      this._bufferLength = bufLen;
      return this;
    }
  }, {
    key: "getState",
    value: function getState() {
      var self = this;
      var s = self._state;
      return {
        buffer: String.fromCharCode.apply(null, self._buffer8),
        buflen: self._bufferLength,
        length: self._dataLength,
        state: [s[0], s[1], s[2], s[3]]
      };
    }
  }, {
    key: "setState",
    value: function setState(state) {
      var buf = state.buffer;
      var x = state.state;
      var s = this._state;
      var i;
      this._dataLength = state.length;
      this._bufferLength = state.buflen;
      s[0] = x[0];
      s[1] = x[1];
      s[2] = x[2];
      s[3] = x[3];

      for (i = 0; i < buf.length; i += 1) {
        this._buffer8[i] = buf.charCodeAt(i);
      }
    }
  }, {
    key: "end",
    value: function end() {
      var raw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var bufLen = this._bufferLength;
      var buf8 = this._buffer8;
      var buf32 = this._buffer32;
      var i = (bufLen >> 2) + 1;
      var dataBitsLen;
      this._dataLength += bufLen;
      buf8[bufLen] = 0x80;
      buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
      buf32.set(Md5.buffer32Identity.subarray(i), i);

      if (bufLen > 55) {
        Md5._md5cycle(this._state, buf32);

        buf32.set(Md5.buffer32Identity);
      } // Do the final computation based on the tail and length
      // Beware that the final length may not fit in 32 bits so we take care of that


      dataBitsLen = this._dataLength * 8;

      if (dataBitsLen <= 0xFFFFFFFF) {
        buf32[14] = dataBitsLen;
      } else {
        var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);

        if (matches === null) {
          return;
        }

        var lo = parseInt(matches[2], 16);
        var hi = parseInt(matches[1], 16) || 0;
        buf32[14] = lo;
        buf32[15] = hi;
      }

      Md5._md5cycle(this._state, buf32);

      return raw ? this._state : Md5._hex(this._state);
    }
  }], [{
    key: "hashStr",
    value: function hashStr(str) {
      var raw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this.onePassHasher.start().appendStr(str).end(raw);
    }
  }, {
    key: "hashAsciiStr",
    value: function hashAsciiStr(str) {
      var raw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this.onePassHasher.start().appendAsciiStr(str).end(raw);
    }
  }, {
    key: "_hex",
    value: function _hex(x) {
      var hc = Md5.hexChars;
      var ho = Md5.hexOut;
      var n;
      var offset;
      var j;
      var i;

      for (i = 0; i < 4; i += 1) {
        offset = i * 8;
        n = x[i];

        for (j = 0; j < 8; j += 2) {
          ho[offset + 1 + j] = hc.charAt(n & 0x0F);
          n >>>= 4;
          ho[offset + 0 + j] = hc.charAt(n & 0x0F);
          n >>>= 4;
        }
      }

      return ho.join('');
    }
  }, {
    key: "_md5cycle",
    value: function _md5cycle(x, k) {
      var a = x[0];
      var b = x[1];
      var c = x[2];
      var d = x[3]; // ff()

      a += (b & c | ~b & d) + k[0] - 680876936 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[1] - 389564586 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[2] + 606105819 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[4] - 176418897 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[7] - 45705983 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[10] - 42063 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[13] - 40341101 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
      b = (b << 22 | b >>> 10) + c | 0; // gg()

      a += (b & d | c & ~d) + k[1] - 165796510 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[11] + 643717713 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[0] - 373897302 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[5] - 701558691 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[10] + 38016083 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[15] - 660478335 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[4] - 405537848 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[9] + 568446438 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[3] - 187363961 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[2] - 51403784 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
      b = (b << 20 | b >>> 12) + c | 0; // hh()

      a += (b ^ c ^ d) + k[5] - 378558 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[14] - 35309556 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[7] - 155497632 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[13] + 681279174 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[0] - 358537222 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[3] - 722521979 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[6] + 76029189 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[9] - 640364487 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[12] - 421815835 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[15] + 530742520 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[2] - 995338651 | 0;
      b = (b << 23 | b >>> 9) + c | 0; // ii()

      a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      x[0] = a + x[0] | 0;
      x[1] = b + x[1] | 0;
      x[2] = c + x[2] | 0;
      x[3] = d + x[3] | 0;
    }
  }]);

  return Md5;
}(); // Private Static Variables


exports.Md5 = Md5;
Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
Md5.hexChars = '0123456789abcdef';
Md5.hexOut = []; // Permanent instance is to use for one-call hashing

Md5.onePassHasher = new Md5();

if (Md5.hashStr('hello') !== '5d41402abc4b2a76b9719d911017c592') {
  console.error('Md5 self test failed.');
}
},{}],"node_modules/sip.js/lib/core/messages/digest-authentication.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DigestAuthentication = void 0;

var _md = require("./md5");

var _utils = require("./utils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function MD5(s) {
  return _md.Md5.hashStr(s);
}
/**
 * Digest Authentication.
 * @internal
 */


var DigestAuthentication = /*#__PURE__*/function () {
  /**
   * Constructor.
   * @param loggerFactory - LoggerFactory.
   * @param username - Username.
   * @param password - Password.
   */
  function DigestAuthentication(loggerFactory, ha1, username, password) {
    _classCallCheck(this, DigestAuthentication);

    this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
    this.username = username;
    this.password = password;
    this.ha1 = ha1;
    this.nc = 0;
    this.ncHex = "00000000";
  }
  /**
   * Performs Digest authentication given a SIP request and the challenge
   * received in a response to that request.
   * @param request -
   * @param challenge -
   * @returns true if credentials were successfully generated, false otherwise.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  _createClass(DigestAuthentication, [{
    key: "authenticate",
    value: function authenticate(request, challenge, body) {
      // Inspect and validate the challenge.
      this.algorithm = challenge.algorithm;
      this.realm = challenge.realm;
      this.nonce = challenge.nonce;
      this.opaque = challenge.opaque;
      this.stale = challenge.stale;

      if (this.algorithm) {
        if (this.algorithm !== "MD5") {
          this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
          return false;
        }
      } else {
        this.algorithm = "MD5";
      }

      if (!this.realm) {
        this.logger.warn("challenge without Digest realm, authentication aborted");
        return false;
      }

      if (!this.nonce) {
        this.logger.warn("challenge without Digest nonce, authentication aborted");
        return false;
      } // 'qop' can contain a list of values (Array). Let's choose just one.


      if (challenge.qop) {
        if (challenge.qop.indexOf("auth") > -1) {
          this.qop = "auth";
        } else if (challenge.qop.indexOf("auth-int") > -1) {
          this.qop = "auth-int";
        } else {
          // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
          this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
          return false;
        }
      } else {
        this.qop = undefined;
      } // Fill other attributes.


      this.method = request.method;
      this.uri = request.ruri;
      this.cnonce = (0, _utils.createRandomToken)(12);
      this.nc += 1;
      this.updateNcHex(); // nc-value = 8LHEX. Max value = 'FFFFFFFF'.

      if (this.nc === 4294967296) {
        this.nc = 1;
        this.ncHex = "00000001";
      } // Calculate the Digest "response" value.


      this.calculateResponse(body);
      return true;
    }
    /**
     * Return the Proxy-Authorization or WWW-Authorization header value.
     */

  }, {
    key: "toString",
    value: function toString() {
      var authParams = [];

      if (!this.response) {
        throw new Error("response field does not exist, cannot generate Authorization header");
      }

      authParams.push("algorithm=" + this.algorithm);
      authParams.push('username="' + this.username + '"');
      authParams.push('realm="' + this.realm + '"');
      authParams.push('nonce="' + this.nonce + '"');
      authParams.push('uri="' + this.uri + '"');
      authParams.push('response="' + this.response + '"');

      if (this.opaque) {
        authParams.push('opaque="' + this.opaque + '"');
      }

      if (this.qop) {
        authParams.push("qop=" + this.qop);
        authParams.push('cnonce="' + this.cnonce + '"');
        authParams.push("nc=" + this.ncHex);
      }

      return "Digest " + authParams.join(", ");
    }
    /**
     * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
     */

  }, {
    key: "updateNcHex",
    value: function updateNcHex() {
      var hex = Number(this.nc).toString(16);
      this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
    }
    /**
     * Generate Digest 'response' value.
     */

  }, {
    key: "calculateResponse",
    value: function calculateResponse(body) {
      var ha1, ha2; // HA1 = MD5(A1) = MD5(username:realm:password)

      ha1 = this.ha1;

      if (ha1 === "" || ha1 === undefined) {
        ha1 = MD5(this.username + ":" + this.realm + ":" + this.password);
      }

      if (this.qop === "auth") {
        // HA2 = MD5(A2) = MD5(method:digestURI)
        ha2 = MD5(this.method + ":" + this.uri); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)`

        this.response = MD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
      } else if (this.qop === "auth-int") {
        // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
        ha2 = MD5(this.method + ":" + this.uri + ":" + MD5(body ? body : "")); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)

        this.response = MD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
      } else if (this.qop === undefined) {
        // HA2 = MD5(A2) = MD5(method:digestURI)
        ha2 = MD5(this.method + ":" + this.uri); // response = MD5(HA1:nonce:HA2)

        this.response = MD5(ha1 + ":" + this.nonce + ":" + ha2);
      }
    }
  }]);

  return DigestAuthentication;
}();

exports.DigestAuthentication = DigestAuthentication;
},{"./md5":"node_modules/sip.js/lib/core/messages/md5.js","./utils":"node_modules/sip.js/lib/core/messages/utils.js"}],"node_modules/sip.js/lib/core/messages/incoming-request.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/incoming-response.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/outgoing-request.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/messages/outgoing-response.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructOutgoingResponse = constructOutgoingResponse;

var _utils = require("./utils");

/**
 * When a UAS wishes to construct a response to a request, it follows
 * the general procedures detailed in the following subsections.
 * Additional behaviors specific to the response code in question, which
 * are not detailed in this section, may also be required.
 * https://tools.ietf.org/html/rfc3261#section-8.2.6
 * @internal
 */
function constructOutgoingResponse(message, options) {
  var CRLF = "\r\n";

  if (options.statusCode < 100 || options.statusCode > 699) {
    throw new TypeError("Invalid statusCode: " + options.statusCode);
  }

  var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : (0, _utils.getReasonPhrase)(options.statusCode); // SIP responses are distinguished from requests by having a Status-Line
  // as their start-line.  A Status-Line consists of the protocol version
  // followed by a numeric Status-Code and its associated textual phrase,
  // with each element separated by a single SP character.
  // https://tools.ietf.org/html/rfc3261#section-7.2

  var response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF; // One largely non-method-specific guideline for the generation of
  // responses is that UASs SHOULD NOT issue a provisional response for a
  // non-INVITE request.  Rather, UASs SHOULD generate a final response to
  // a non-INVITE request as soon as possible.
  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1

  if (options.statusCode >= 100 && options.statusCode < 200) {// TODO
  } // When a 100 (Trying) response is generated, any Timestamp header field
  // present in the request MUST be copied into this 100 (Trying)
  // response.  If there is a delay in generating the response, the UAS
  // SHOULD add a delay value into the Timestamp value in the response.
  // This value MUST contain the difference between the time of sending of
  // the response and receipt of the request, measured in seconds.
  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1


  if (options.statusCode === 100) {// TODO
  } // The From field of the response MUST equal the From header field of
  // the request.  The Call-ID header field of the response MUST equal the
  // Call-ID header field of the request.  The CSeq header field of the
  // response MUST equal the CSeq field of the request.  The Via header
  // field values in the response MUST equal the Via header field values
  // in the request and MUST maintain the same ordering.
  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2


  var fromHeader = "From: " + message.getHeader("From") + CRLF;
  var callIdHeader = "Call-ID: " + message.callId + CRLF;
  var cSeqHeader = "CSeq: " + message.cseq + " " + message.method + CRLF;
  var viaHeaders = message.getHeaders("via").reduce(function (previous, current) {
    return previous + "Via: " + current + CRLF;
  }, ""); // If a request contained a To tag in the request, the To header field
  // in the response MUST equal that of the request.  However, if the To
  // header field in the request did not contain a tag, the URI in the To
  // header field in the response MUST equal the URI in the To header
  // field; additionally, the UAS MUST add a tag to the To header field in
  // the response (with the exception of the 100 (Trying) response, in
  // which a tag MAY be present).  This serves to identify the UAS that is
  // responding, possibly resulting in a component of a dialog ID.  The
  // same tag MUST be used for all responses to that request, both final
  // and provisional (again excepting the 100 (Trying)).
  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2

  var toHeader = "To: " + message.getHeader("to");

  if (options.statusCode > 100 && !message.parseHeader("to").hasParam("tag")) {
    var toTag = options.toTag;

    if (!toTag) {
      // Stateless UAS Behavior...
      // o  To header tags MUST be generated for responses in a stateless
      //    manner - in a manner that will generate the same tag for the
      //    same request consistently.  For information on tag construction
      //    see Section 19.3.
      // https://tools.ietf.org/html/rfc3261#section-8.2.7
      toTag = (0, _utils.newTag)(); // FIXME: newTag() currently generates random tags
    }

    toHeader += ";tag=" + toTag;
  }

  toHeader += CRLF; // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)
  // let recordRouteHeaders = "";
  // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {
  //   recordRouteHeaders = request.getHeaders("record-route").reduce((previous, current) => {
  //     return previous + "Record-Route: " + current + CRLF;
  //   }, "");
  // }
  // FIXME: TODO: needs review...

  var supportedHeader = "";

  if (options.supported) {
    supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
  } // FIXME: TODO: needs review...


  var userAgentHeader = "";

  if (options.userAgent) {
    userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
  }

  var extensionHeaders = "";

  if (options.extraHeaders) {
    extensionHeaders = options.extraHeaders.reduce(function (previous, current) {
      return previous + current.trim() + CRLF;
    }, "");
  } // The relative order of header fields with different field names is not
  // significant.  However, it is RECOMMENDED that header fields which are
  // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
  // Max-Forwards, and Proxy-Authorization, for example) appear towards
  // the top of the message to facilitate rapid parsing.
  // https://tools.ietf.org/html/rfc3261#section-7.3.1
  // response += recordRouteHeaders;


  response += viaHeaders;
  response += fromHeader;
  response += toHeader;
  response += cSeqHeader;
  response += callIdHeader;
  response += supportedHeader;
  response += userAgentHeader;
  response += extensionHeaders;

  if (options.body) {
    response += "Content-Type: " + options.body.contentType + CRLF;
    response += "Content-Length: " + (0, _utils.utf8Length)(options.body.content) + CRLF + CRLF;
    response += options.body.content;
  } else {
    response += "Content-Length: " + 0 + CRLF + CRLF;
  }

  return {
    message: response
  };
}
},{"./utils":"node_modules/sip.js/lib/core/messages/utils.js"}],"node_modules/sip.js/lib/core/messages/parser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = void 0;

var _grammar = require("../../grammar");

var _incomingRequestMessage = require("./incoming-request-message");

var _incomingResponseMessage = require("./incoming-response-message");

/* eslint-disable no-inner-declarations */

/* eslint-disable @typescript-eslint/no-namespace */

/**
 * Extract and parse every header of a SIP message.
 * @internal
 */
var Parser;
exports.Parser = Parser;

(function (Parser) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function getHeader(data, headerStart) {
    // 'start' position of the header.
    var start = headerStart; // 'end' position of the header.

    var end = 0; // 'partial end' position of the header.

    var partialEnd = 0; // End of message.

    if (data.substring(start, start + 2).match(/(^\r\n)/)) {
      return -2;
    }

    while (end === 0) {
      // Partial End of Header.
      partialEnd = data.indexOf("\r\n", start); // 'indexOf' returns -1 if the value to be found never occurs.

      if (partialEnd === -1) {
        return partialEnd;
      }

      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
        // Not the end of the message. Continue from the next position.
        start = partialEnd + 2;
      } else {
        end = partialEnd;
      }
    }

    return end;
  }

  Parser.getHeader = getHeader;

  function parseHeader(message, // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data, headerStart, headerEnd) {
    var hcolonIndex = data.indexOf(":", headerStart);
    var headerName = data.substring(headerStart, hcolonIndex).trim();
    var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

    var parsed; // If header-field is well-known, parse it.

    switch (headerName.toLowerCase()) {
      case "via":
      case "v":
        message.addHeader("via", headerValue);

        if (message.getHeaders("via").length === 1) {
          parsed = message.parseHeader("Via");

          if (parsed) {
            message.via = parsed;
            message.viaBranch = parsed.branch;
          }
        } else {
          parsed = 0;
        }

        break;

      case "from":
      case "f":
        message.setHeader("from", headerValue);
        parsed = message.parseHeader("from");

        if (parsed) {
          message.from = parsed;
          message.fromTag = parsed.getParam("tag");
        }

        break;

      case "to":
      case "t":
        message.setHeader("to", headerValue);
        parsed = message.parseHeader("to");

        if (parsed) {
          message.to = parsed;
          message.toTag = parsed.getParam("tag");
        }

        break;

      case "record-route":
        parsed = _grammar.Grammar.parse(headerValue, "Record_Route");

        if (parsed === -1) {
          parsed = undefined;
          break;
        }

        if (!(parsed instanceof Array)) {
          parsed = undefined;
          break;
        }

        parsed.forEach(function (header) {
          message.addHeader("record-route", headerValue.substring(header.position, header.offset));
          message.headers["Record-Route"][message.getHeaders("record-route").length - 1].parsed = header.parsed;
        });
        break;

      case "call-id":
      case "i":
        message.setHeader("call-id", headerValue);
        parsed = message.parseHeader("call-id");

        if (parsed) {
          message.callId = headerValue;
        }

        break;

      case "contact":
      case "m":
        parsed = _grammar.Grammar.parse(headerValue, "Contact");

        if (parsed === -1) {
          parsed = undefined;
          break;
        }

        if (!(parsed instanceof Array)) {
          parsed = undefined;
          break;
        }

        parsed.forEach(function (header) {
          message.addHeader("contact", headerValue.substring(header.position, header.offset));
          message.headers.Contact[message.getHeaders("contact").length - 1].parsed = header.parsed;
        });
        break;

      case "content-length":
      case "l":
        message.setHeader("content-length", headerValue);
        parsed = message.parseHeader("content-length");
        break;

      case "content-type":
      case "c":
        message.setHeader("content-type", headerValue);
        parsed = message.parseHeader("content-type");
        break;

      case "cseq":
        message.setHeader("cseq", headerValue);
        parsed = message.parseHeader("cseq");

        if (parsed) {
          message.cseq = parsed.value;
        }

        if (message instanceof _incomingResponseMessage.IncomingResponseMessage) {
          message.method = parsed.method;
        }

        break;

      case "max-forwards":
        message.setHeader("max-forwards", headerValue);
        parsed = message.parseHeader("max-forwards");
        break;

      case "www-authenticate":
        message.setHeader("www-authenticate", headerValue);
        parsed = message.parseHeader("www-authenticate");
        break;

      case "proxy-authenticate":
        message.setHeader("proxy-authenticate", headerValue);
        parsed = message.parseHeader("proxy-authenticate");
        break;

      case "refer-to":
      case "r":
        message.setHeader("refer-to", headerValue);
        parsed = message.parseHeader("refer-to");

        if (parsed) {
          message.referTo = parsed;
        }

        break;

      default:
        // Do not parse this header.
        message.addHeader(headerName.toLowerCase(), headerValue);
        parsed = 0;
    }

    if (parsed === undefined) {
      return {
        error: "error parsing header '" + headerName + "'"
      };
    } else {
      return true;
    }
  }

  Parser.parseHeader = parseHeader;

  function parseMessage(data, logger) {
    var headerStart = 0;
    var headerEnd = data.indexOf("\r\n");

    if (headerEnd === -1) {
      logger.warn("no CRLF found, not a SIP message, discarded");
      return;
    } // Parse first line. Check if it is a Request or a Reply.


    var firstLine = data.substring(0, headerEnd);

    var parsed = _grammar.Grammar.parse(firstLine, "Request_Response");

    var message;

    if (parsed === -1) {
      logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
      return;
    } else if (!parsed.status_code) {
      message = new _incomingRequestMessage.IncomingRequestMessage();
      message.method = parsed.method;
      message.ruri = parsed.uri;
    } else {
      message = new _incomingResponseMessage.IncomingResponseMessage();
      message.statusCode = parsed.status_code;
      message.reasonPhrase = parsed.reason_phrase;
    }

    message.data = data;
    headerStart = headerEnd + 2; // Loop over every line in data. Detect the end of each header and parse
    // it or simply add to the headers collection.

    var bodyStart; // eslint-disable-next-line no-constant-condition

    while (true) {
      headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.

      if (headerEnd === -2) {
        bodyStart = headerStart + 2;
        break;
      } else if (headerEnd === -1) {
        // data.indexOf returned -1 due to a malformed message.
        logger.error("malformed message");
        return;
      }

      var parsedHeader = parseHeader(message, data, headerStart, headerEnd);

      if (parsedHeader && parsedHeader !== true) {
        logger.error(parsedHeader.error);
        return;
      }

      headerStart = headerEnd + 2;
    } // RFC3261 18.3.
    // If there are additional bytes in the transport packet
    // beyond the end of the body, they MUST be discarded.


    if (message.hasHeader("content-length")) {
      message.body = data.substr(bodyStart, Number(message.getHeader("content-length")));
    } else {
      message.body = data.substring(bodyStart);
    }

    return message;
  }

  Parser.parseMessage = parseMessage;
})(Parser || (exports.Parser = Parser = {}));
},{"../../grammar":"node_modules/sip.js/lib/grammar/index.js","./incoming-request-message":"node_modules/sip.js/lib/core/messages/incoming-request-message.js","./incoming-response-message":"node_modules/sip.js/lib/core/messages/incoming-response-message.js"}],"node_modules/sip.js/lib/core/messages/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _grammar = require("../../grammar");

Object.keys(_grammar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _grammar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _grammar[key];
    }
  });
});

var _methods = require("./methods");

Object.keys(_methods).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _methods[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _methods[key];
    }
  });
});

var _body = require("./body");

Object.keys(_body).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _body[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _body[key];
    }
  });
});

var _digestAuthentication = require("./digest-authentication");

Object.keys(_digestAuthentication).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _digestAuthentication[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _digestAuthentication[key];
    }
  });
});

var _incomingMessage = require("./incoming-message");

Object.keys(_incomingMessage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incomingMessage[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incomingMessage[key];
    }
  });
});

var _incomingRequestMessage = require("./incoming-request-message");

Object.keys(_incomingRequestMessage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incomingRequestMessage[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incomingRequestMessage[key];
    }
  });
});

var _incomingRequest = require("./incoming-request");

Object.keys(_incomingRequest).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incomingRequest[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incomingRequest[key];
    }
  });
});

var _incomingResponseMessage = require("./incoming-response-message");

Object.keys(_incomingResponseMessage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incomingResponseMessage[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incomingResponseMessage[key];
    }
  });
});

var _incomingResponse = require("./incoming-response");

Object.keys(_incomingResponse).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incomingResponse[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incomingResponse[key];
    }
  });
});

var _outgoingRequestMessage = require("./outgoing-request-message");

Object.keys(_outgoingRequestMessage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _outgoingRequestMessage[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _outgoingRequestMessage[key];
    }
  });
});

var _outgoingRequest = require("./outgoing-request");

Object.keys(_outgoingRequest).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _outgoingRequest[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _outgoingRequest[key];
    }
  });
});

var _outgoingResponse = require("./outgoing-response");

Object.keys(_outgoingResponse).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _outgoingResponse[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _outgoingResponse[key];
    }
  });
});

var _parser = require("./parser");

Object.keys(_parser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _parser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _parser[key];
    }
  });
});
},{"../../grammar":"node_modules/sip.js/lib/grammar/index.js","./methods":"node_modules/sip.js/lib/core/messages/methods/index.js","./body":"node_modules/sip.js/lib/core/messages/body.js","./digest-authentication":"node_modules/sip.js/lib/core/messages/digest-authentication.js","./incoming-message":"node_modules/sip.js/lib/core/messages/incoming-message.js","./incoming-request-message":"node_modules/sip.js/lib/core/messages/incoming-request-message.js","./incoming-request":"node_modules/sip.js/lib/core/messages/incoming-request.js","./incoming-response-message":"node_modules/sip.js/lib/core/messages/incoming-response-message.js","./incoming-response":"node_modules/sip.js/lib/core/messages/incoming-response.js","./outgoing-request-message":"node_modules/sip.js/lib/core/messages/outgoing-request-message.js","./outgoing-request":"node_modules/sip.js/lib/core/messages/outgoing-request.js","./outgoing-response":"node_modules/sip.js/lib/core/messages/outgoing-response.js","./parser":"node_modules/sip.js/lib/core/messages/parser.js"}],"node_modules/sip.js/lib/core/dialogs/dialog.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dialog = void 0;

var _messages = require("../messages");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Dialog.
 * @remarks
 * A key concept for a user agent is that of a dialog.  A dialog
 * represents a peer-to-peer SIP relationship between two user agents
 * that persists for some time.  The dialog facilitates sequencing of
 * messages between the user agents and proper routing of requests
 * between both of them.  The dialog represents a context in which to
 * interpret SIP messages.
 * https://tools.ietf.org/html/rfc3261#section-12
 * @public
 */
var Dialog = /*#__PURE__*/function () {
  /**
   * Dialog constructor.
   * @param core - User agent core.
   * @param dialogState - Initial dialog state.
   */
  function Dialog(core, dialogState) {
    _classCallCheck(this, Dialog);

    this.core = core;
    this.dialogState = dialogState;
    this.core.dialogs.set(this.id, this);
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */


  _createClass(Dialog, [{
    key: "dispose",
    value:
    /** Destructor. */
    function dispose() {
      this.core.dialogs.delete(this.id);
    }
    /**
     * A dialog is identified at each UA with a dialog ID, which consists of
     * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
     * UA involved in the dialog is not the same.  Specifically, the local
     * tag at one UA is identical to the remote tag at the peer UA.  The
     * tags are opaque tokens that facilitate the generation of unique
     * dialog IDs.
     * https://tools.ietf.org/html/rfc3261#section-12
     */

  }, {
    key: "id",
    get: function get() {
      return this.dialogState.id;
    }
    /**
     * A dialog can also be in the "early" state, which occurs when it is
     * created with a provisional response, and then it transition to the
     * "confirmed" state when a 2xx final response received or is sent.
     *
     * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
     * can be a point of confusion if an INVITE dialog is "confirmed" after
     * a 2xx is sent or after receiving the ACK for the 2xx response.
     * With careful reading it can be inferred a dialog is always is
     * "confirmed" when the 2xx is sent (regardless of type of dialog).
     * However a INVITE dialog does have additional considerations
     * when it is confirmed but an ACK has not yet been received (in
     * particular with regard to a callee sending BYE requests).
     */

  }, {
    key: "early",
    get: function get() {
      return this.dialogState.early;
    }
    /** Call identifier component of the dialog id. */

  }, {
    key: "callId",
    get: function get() {
      return this.dialogState.callId;
    }
    /** Local tag component of the dialog id. */

  }, {
    key: "localTag",
    get: function get() {
      return this.dialogState.localTag;
    }
    /** Remote tag component of the dialog id. */

  }, {
    key: "remoteTag",
    get: function get() {
      return this.dialogState.remoteTag;
    }
    /** Local sequence number (used to order requests from the UA to its peer). */

  }, {
    key: "localSequenceNumber",
    get: function get() {
      return this.dialogState.localSequenceNumber;
    }
    /** Remote sequence number (used to order requests from its peer to the UA). */

  }, {
    key: "remoteSequenceNumber",
    get: function get() {
      return this.dialogState.remoteSequenceNumber;
    }
    /** Local URI. */

  }, {
    key: "localURI",
    get: function get() {
      return this.dialogState.localURI;
    }
    /** Remote URI. */

  }, {
    key: "remoteURI",
    get: function get() {
      return this.dialogState.remoteURI;
    }
    /** Remote target. */

  }, {
    key: "remoteTarget",
    get: function get() {
      return this.dialogState.remoteTarget;
    }
    /**
     * Route set, which is an ordered list of URIs. The route set is the
     * list of servers that need to be traversed to send a request to the peer.
     */

  }, {
    key: "routeSet",
    get: function get() {
      return this.dialogState.routeSet;
    }
    /**
     * If the request was sent over TLS, and the Request-URI contained
     * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
     */

  }, {
    key: "secure",
    get: function get() {
      return this.dialogState.secure;
    }
    /** The user agent core servicing this dialog. */

  }, {
    key: "userAgentCore",
    get: function get() {
      return this.core;
    }
    /** Confirm the dialog. Only matters if dialog is currently early. */

  }, {
    key: "confirm",
    value: function confirm() {
      this.dialogState.early = false;
    }
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     *
     *    Note that some requests, such as INVITEs, affect several pieces of
     *    state.
     *
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */

  }, {
    key: "receiveRequest",
    value: function receiveRequest(message) {
      // ACK guard.
      // By convention, the handling of ACKs is the responsibility
      // the particular dialog implementation. For example, see SessionDialog.
      // Furthermore, ACKs have same sequence number as the associated INVITE.
      if (message.method === _messages.C.ACK) {
        return;
      } // If the remote sequence number was not empty, but the sequence number
      // of the request is lower than the remote sequence number, the request
      // is out of order and MUST be rejected with a 500 (Server Internal
      // Error) response.  If the remote sequence number was not empty, and
      // the sequence number of the request is greater than the remote
      // sequence number, the request is in order.  It is possible for the
      // CSeq sequence number to be higher than the remote sequence number by
      // more than one.  This is not an error condition, and a UAS SHOULD be
      // prepared to receive and process requests with CSeq values more than
      // one higher than the previous received request.  The UAS MUST then set
      // the remote sequence number to the value of the sequence number in the
      // CSeq header field value in the request.
      //
      //    If a proxy challenges a request generated by the UAC, the UAC has
      //    to resubmit the request with credentials.  The resubmitted request
      //    will have a new CSeq number.  The UAS will never see the first
      //    request, and thus, it will notice a gap in the CSeq number space.
      //    Such a gap does not represent any error condition.
      //
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      if (this.remoteSequenceNumber) {
        if (message.cseq <= this.remoteSequenceNumber) {
          throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
        }

        this.dialogState.remoteSequenceNumber = message.cseq;
      } // If the remote sequence number is empty, it MUST be set to the value
      // of the sequence number in the CSeq header field value in the request.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      if (!this.remoteSequenceNumber) {
        this.dialogState.remoteSequenceNumber = message.cseq;
      } // When a UAS receives a target refresh request, it MUST replace the
      // dialog's remote target URI with the URI from the Contact header field
      // in that request, if present.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2
      // Note: "target refresh request" processing delegated to sub-class.

    }
    /**
     * If the dialog identifier in the 2xx response matches the dialog
     * identifier of an existing dialog, the dialog MUST be transitioned to
     * the "confirmed" state, and the route set for the dialog MUST be
     * recomputed based on the 2xx response using the procedures of Section
     * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
     * constructed using the procedures of Section 12.1.2.
     *
     * Note that the only piece of state that is recomputed is the route
     * set.  Other pieces of state such as the highest sequence numbers
     * (remote and local) sent within the dialog are not recomputed.  The
     * route set only is recomputed for backwards compatibility.  RFC
     * 2543 did not mandate mirroring of the Record-Route header field in
     * a 1xx, only 2xx.  However, we cannot update the entire state of
     * the dialog, since mid-dialog requests may have been sent within
     * the early dialog, modifying the sequence numbers, for example.
     *
     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     */

  }, {
    key: "recomputeRouteSet",
    value: function recomputeRouteSet(message) {
      this.dialogState.routeSet = message.getHeaders("record-route").reverse();
    }
    /**
     * A request within a dialog is constructed by using many of the
     * components of the state stored as part of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
     * @param method - Outgoing request method.
     */

  }, {
    key: "createOutgoingRequestMessage",
    value: function createOutgoingRequestMessage(method, options) {
      // The URI in the To field of the request MUST be set to the remote URI
      // from the dialog state.  The tag in the To header field of the request
      // MUST be set to the remote tag of the dialog ID.  The From URI of the
      // request MUST be set to the local URI from the dialog state.  The tag
      // in the From header field of the request MUST be set to the local tag
      // of the dialog ID.  If the value of the remote or local tags is null,
      // the tag parameter MUST be omitted from the To or From header fields,
      // respectively.
      //
      //    Usage of the URI from the To and From fields in the original
      //    request within subsequent requests is done for backwards
      //    compatibility with RFC 2543, which used the URI for dialog
      //    identification.  In this specification, only the tags are used for
      //    dialog identification.  It is expected that mandatory reflection
      //    of the original To and From URI in mid-dialog requests will be
      //    deprecated in a subsequent revision of this specification.
      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
      var toUri = this.remoteURI;
      var toTag = this.remoteTag;
      var fromUri = this.localURI;
      var fromTag = this.localTag; // The Call-ID of the request MUST be set to the Call-ID of the dialog.
      // Requests within a dialog MUST contain strictly monotonically
      // increasing and contiguous CSeq sequence numbers (increasing-by-one)
      // in each direction (excepting ACK and CANCEL of course, whose numbers
      // equal the requests being acknowledged or cancelled).  Therefore, if
      // the local sequence number is not empty, the value of the local
      // sequence number MUST be incremented by one, and this value MUST be
      // placed into the CSeq header field.  If the local sequence number is
      // empty, an initial value MUST be chosen using the guidelines of
      // Section 8.1.1.5.  The method field in the CSeq header field value
      // MUST match the method of the request.
      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1

      var callId = this.callId;
      var cseq;

      if (options && options.cseq) {
        cseq = options.cseq;
      } else if (!this.dialogState.localSequenceNumber) {
        cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5
      } else {
        cseq = this.dialogState.localSequenceNumber += 1;
      } // The UAC uses the remote target and route set to build the Request-URI
      // and Route header field of the request.
      //
      // If the route set is empty, the UAC MUST place the remote target URI
      // into the Request-URI.  The UAC MUST NOT add a Route header field to
      // the request.
      //
      // If the route set is not empty, and the first URI in the route set
      // contains the lr parameter (see Section 19.1.1), the UAC MUST place
      // the remote target URI into the Request-URI and MUST include a Route
      // header field containing the route set values in order, including all
      // parameters.
      //
      // If the route set is not empty, and its first URI does not contain the
      // lr parameter, the UAC MUST place the first URI from the route set
      // into the Request-URI, stripping any parameters that are not allowed
      // in a Request-URI.  The UAC MUST add a Route header field containing
      // the remainder of the route set values in order, including all
      // parameters.  The UAC MUST then place the remote target URI into the
      // Route header field as the last value.
      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
      // The lr parameter, when present, indicates that the element
      // responsible for this resource implements the routing mechanisms
      // specified in this document.  This parameter will be used in the
      // URIs proxies place into Record-Route header field values, and
      // may appear in the URIs in a pre-existing route set.
      //
      // This parameter is used to achieve backwards compatibility with
      // systems implementing the strict-routing mechanisms of RFC 2543
      // and the rfc2543bis drafts up to bis-05.  An element preparing
      // to send a request based on a URI not containing this parameter
      // can assume the receiving element implements strict-routing and
      // reformat the message to preserve the information in the
      // Request-URI.
      // https://tools.ietf.org/html/rfc3261#section-19.1.1
      // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).


      var ruri = this.remoteTarget;
      var routeSet = this.routeSet;
      var extraHeaders = options && options.extraHeaders;
      var body = options && options.body; // The relative order of header fields with different field names is not
      // significant.  However, it is RECOMMENDED that header fields which are
      // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
      // Max-Forwards, and Proxy-Authorization, for example) appear towards
      // the top of the message to facilitate rapid parsing.
      // https://tools.ietf.org/html/rfc3261#section-7.3.1

      var message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
        callId: callId,
        cseq: cseq,
        fromTag: fromTag,
        toTag: toTag,
        routeSet: routeSet
      }, extraHeaders, body);
      return message;
    }
    /**
     * Increment the local sequence number by one.
     * It feels like this should be protected, but the current authentication handling currently
     * needs this to keep the dialog in sync when "auto re-sends" request messages.
     * @internal
     */

  }, {
    key: "incrementLocalSequenceNumber",
    value: function incrementLocalSequenceNumber() {
      if (!this.dialogState.localSequenceNumber) {
        throw new Error("Local sequence number undefined.");
      }

      this.dialogState.localSequenceNumber += 1;
    }
    /**
     * If the remote sequence number was not empty, but the sequence number
     * of the request is lower than the remote sequence number, the request
     * is out of order and MUST be rejected with a 500 (Server Internal
     * Error) response.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param request - Incoming request to guard.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
     */

  }, {
    key: "sequenceGuard",
    value: function sequenceGuard(message) {
      // ACK guard.
      // By convention, handling of unexpected ACKs is responsibility
      // the particular dialog implementation. For example, see SessionDialog.
      // Furthermore, we cannot reply to an "out of sequence" ACK.
      if (message.method === _messages.C.ACK) {
        return true;
      } // Note: We are rejecting on "less than or equal to" the remote
      // sequence number (excepting ACK whose numbers equal the requests
      // being acknowledged or cancelled), which is the correct thing to
      // do in our case. The only time a request with the same sequence number
      // will show up here if is a) it is a very late retransmission of a
      // request we already handled or b) it is a different request with the
      // same sequence number which would be violation of the standard.
      // Request retransmissions are absorbed by the transaction layer,
      // so any request with a duplicate sequence number getting here
      // would have to be a retransmission after the transaction terminated
      // or a broken request (with unique via branch value).
      // Requests within a dialog MUST contain strictly monotonically
      // increasing and contiguous CSeq sequence numbers (increasing-by-one)
      // in each direction (excepting ACK and CANCEL of course, whose numbers
      // equal the requests being acknowledged or cancelled).  Therefore, if
      // the local sequence number is not empty, the value of the local
      // sequence number MUST be incremented by one, and this value MUST be
      // placed into the CSeq header field.
      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1


      if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {
        this.core.replyStateless(message, {
          statusCode: 500
        });
        return false;
      }

      return true;
    }
  }], [{
    key: "initialDialogStateForUserAgentClient",
    value: function initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {
      // If the request was sent over TLS, and the Request-URI contained a
      // SIPS URI, the "secure" flag is set to TRUE.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2
      var secure = false; // FIXME: Currently no support for TLS.
      // The route set MUST be set to the list of URIs in the Record-Route
      // header field from the response, taken in reverse order and preserving
      // all URI parameters.  If no Record-Route header field is present in
      // the response, the route set MUST be set to the empty set.  This route
      // set, even if empty, overrides any pre-existing route set for future
      // requests in this dialog.  The remote target MUST be set to the URI
      // from the Contact header field of the response.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2

      var routeSet = incomingResponseMessage.getHeaders("record-route").reverse(); // When a UAS responds to a request with a response that establishes a
      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
      // header field values from the request into the response (including the
      // URIs, URI parameters, and any Record-Route header field parameters,
      // whether they are known or unknown to the UAS) and MUST maintain the
      // order of those values.  The UAS MUST add a Contact header field to
      // the response.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1

      var contact = incomingResponseMessage.parseHeader("contact");

      if (!contact) {
        // TODO: Review to make sure this will never happen
        throw new Error("Contact undefined.");
      }

      if (!(contact instanceof _messages.NameAddrHeader)) {
        throw new Error("Contact not instance of NameAddrHeader.");
      }

      var remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence
      // number in the CSeq header field of the request.  The remote sequence
      // number MUST be empty (it is established when the remote UA sends a
      // request within the dialog).  The call identifier component of the
      // dialog ID MUST be set to the value of the Call-ID in the request.
      // The local tag component of the dialog ID MUST be set to the tag in
      // the From field in the request, and the remote tag component of the
      // dialog ID MUST be set to the tag in the To field of the response.  A
      // UAC MUST be prepared to receive a response without a tag in the To
      // field, in which case the tag is considered to have a value of null.
      //
      //    This is to maintain backwards compatibility with RFC 2543, which
      //    did not mandate To tags.
      //
      // https://tools.ietf.org/html/rfc3261#section-12.1.2

      var localSequenceNumber = outgoingRequestMessage.cseq;
      var remoteSequenceNumber = undefined;
      var callId = outgoingRequestMessage.callId;
      var localTag = outgoingRequestMessage.fromTag;
      var remoteTag = incomingResponseMessage.toTag;

      if (!callId) {
        // TODO: Review to make sure this will never happen
        throw new Error("Call id undefined.");
      }

      if (!localTag) {
        // TODO: Review to make sure this will never happen
        throw new Error("From tag undefined.");
      }

      if (!remoteTag) {
        // TODO: Review to make sure this will never happen
        throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
      } // The remote URI MUST be set to the URI in the To field, and the local
      // URI MUST be set to the URI in the From field.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2


      if (!outgoingRequestMessage.from) {
        // TODO: Review to make sure this will never happen
        throw new Error("From undefined.");
      }

      if (!outgoingRequestMessage.to) {
        // TODO: Review to make sure this will never happen
        throw new Error("To undefined.");
      }

      var localURI = outgoingRequestMessage.from.uri;
      var remoteURI = outgoingRequestMessage.to.uri; // A dialog can also be in the "early" state, which occurs when it is
      // created with a provisional response, and then transition to the
      // "confirmed" state when a 2xx final response arrives.
      // https://tools.ietf.org/html/rfc3261#section-12

      if (!incomingResponseMessage.statusCode) {
        throw new Error("Incoming response status code undefined.");
      }

      var early = incomingResponseMessage.statusCode < 200 ? true : false;
      var dialogState = {
        id: callId + localTag + remoteTag,
        early: early,
        callId: callId,
        localTag: localTag,
        remoteTag: remoteTag,
        localSequenceNumber: localSequenceNumber,
        remoteSequenceNumber: remoteSequenceNumber,
        localURI: localURI,
        remoteURI: remoteURI,
        remoteTarget: remoteTarget,
        routeSet: routeSet,
        secure: secure
      };
      return dialogState;
    }
    /**
     * The UAS then constructs the state of the dialog.  This state MUST be
     * maintained for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.1
     * @param incomingRequestMessage - Incoming request message creating dialog.
     * @param toTag - Tag in the To field in the response to the incoming request.
     */

  }, {
    key: "initialDialogStateForUserAgentServer",
    value: function initialDialogStateForUserAgentServer(incomingRequestMessage, toTag) {
      var early = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // If the request arrived over TLS, and the Request-URI contained a SIPS
      // URI, the "secure" flag is set to TRUE.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1
      var secure = false; // FIXME: Currently no support for TLS.
      // The route set MUST be set to the list of URIs in the Record-Route
      // header field from the request, taken in order and preserving all URI
      // parameters.  If no Record-Route header field is present in the
      // request, the route set MUST be set to the empty set.  This route set,
      // even if empty, overrides any pre-existing route set for future
      // requests in this dialog.  The remote target MUST be set to the URI
      // from the Contact header field of the request.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1

      var routeSet = incomingRequestMessage.getHeaders("record-route");
      var contact = incomingRequestMessage.parseHeader("contact");

      if (!contact) {
        // TODO: Review to make sure this will never happen
        throw new Error("Contact undefined.");
      }

      if (!(contact instanceof _messages.NameAddrHeader)) {
        throw new Error("Contact not instance of NameAddrHeader.");
      }

      var remoteTarget = contact.uri; // The remote sequence number MUST be set to the value of the sequence
      // number in the CSeq header field of the request.  The local sequence
      // number MUST be empty.  The call identifier component of the dialog ID
      // MUST be set to the value of the Call-ID in the request.  The local
      // tag component of the dialog ID MUST be set to the tag in the To field
      // in the response to the request (which always includes a tag), and the
      // remote tag component of the dialog ID MUST be set to the tag from the
      // From field in the request.  A UAS MUST be prepared to receive a
      // request without a tag in the From field, in which case the tag is
      // considered to have a value of null.
      //
      //    This is to maintain backwards compatibility with RFC 2543, which
      //    did not mandate From tags.
      //
      // https://tools.ietf.org/html/rfc3261#section-12.1.1

      var remoteSequenceNumber = incomingRequestMessage.cseq;
      var localSequenceNumber = undefined;
      var callId = incomingRequestMessage.callId;
      var localTag = toTag;
      var remoteTag = incomingRequestMessage.fromTag; // The remote URI MUST be set to the URI in the From field, and the
      // local URI MUST be set to the URI in the To field.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1

      var remoteURI = incomingRequestMessage.from.uri;
      var localURI = incomingRequestMessage.to.uri;
      var dialogState = {
        id: callId + localTag + remoteTag,
        early: early,
        callId: callId,
        localTag: localTag,
        remoteTag: remoteTag,
        localSequenceNumber: localSequenceNumber,
        remoteSequenceNumber: remoteSequenceNumber,
        localURI: localURI,
        remoteURI: remoteURI,
        remoteTarget: remoteTarget,
        routeSet: routeSet,
        secure: secure
      };
      return dialogState;
    }
  }]);

  return Dialog;
}();

exports.Dialog = Dialog;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js"}],"node_modules/sip.js/lib/core/dialogs/dialog-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/session/session.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignalingState = exports.SessionState = void 0;

/**
 * Session state.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-13
 * @public
 */
var SessionState;
exports.SessionState = SessionState;

(function (SessionState) {
  SessionState["Initial"] = "Initial";
  SessionState["Early"] = "Early";
  SessionState["AckWait"] = "AckWait";
  SessionState["Confirmed"] = "Confirmed";
  SessionState["Terminated"] = "Terminated";
})(SessionState || (exports.SessionState = SessionState = {}));
/**
 * Offer/Answer state.
 * @remarks
 * ```txt
 *         Offer                Answer             RFC    Ini Est Early
 *  -------------------------------------------------------------------
 *  1. INVITE Req.          2xx INVITE Resp.     RFC 3261  Y   Y    N
 *  2. 2xx INVITE Resp.     ACK Req.             RFC 3261  Y   Y    N
 *  3. INVITE Req.          1xx-rel INVITE Resp. RFC 3262  Y   Y    N
 *  4. 1xx-rel INVITE Resp. PRACK Req.           RFC 3262  Y   Y    N
 *  5. PRACK Req.           200 PRACK Resp.      RFC 3262  N   Y    Y
 *  6. UPDATE Req.          2xx UPDATE Resp.     RFC 3311  N   Y    Y
 *
 *       Table 1: Summary of SIP Usage of the Offer/Answer Model
 * ```
 * https://tools.ietf.org/html/rfc6337#section-2.2
 * @public
 */


var SignalingState;
exports.SignalingState = SignalingState;

(function (SignalingState) {
  SignalingState["Initial"] = "Initial";
  SignalingState["HaveLocalOffer"] = "HaveLocalOffer";
  SignalingState["HaveRemoteOffer"] = "HaveRemoteOffer";
  SignalingState["Stable"] = "Stable";
  SignalingState["Closed"] = "Closed";
})(SignalingState || (exports.SignalingState = SignalingState = {}));
},{}],"node_modules/sip.js/lib/core/session/session-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/session/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _session = require("./session");

Object.keys(_session).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _session[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _session[key];
    }
  });
});

var _sessionDelegate = require("./session-delegate");

Object.keys(_sessionDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDelegate[key];
    }
  });
});
},{"./session":"node_modules/sip.js/lib/core/session/session.js","./session-delegate":"node_modules/sip.js/lib/core/session/session-delegate.js"}],"node_modules/sip.js/lib/core/timers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timers = void 0;
var T1 = 500;
var T2 = 4000;
var T4 = 5000;
/**
 * Timers.
 * @public
 */

var Timers = {
  T1: T1,
  T2: T2,
  T4: T4,
  TIMER_B: 64 * T1,
  TIMER_D: 0 * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0 * T4,
  TIMER_J: 0 * T1,
  TIMER_K: 0 * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1,
  TIMER_N: 64 * T1,
  PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1

};
exports.Timers = Timers;
},{}],"node_modules/sip.js/lib/core/exceptions/exception.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Exception = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An Exception is considered a condition that a reasonable application may wish to catch.
 * An Error indicates serious problems that a reasonable application should not try to catch.
 * @public
 */
var Exception = /*#__PURE__*/function (_Error) {
  _inherits(Exception, _Error);

  var _super = _createSuper(Exception);

  function Exception(message) {
    var _this;

    _classCallCheck(this, Exception);

    _this = _super.call(this, message); // 'Error' breaks prototype chain here

    Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof Exception ? this.constructor : void 0).prototype); // restore prototype chain

    return _this;
  }

  return _createClass(Exception);
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.Exception = Exception;
},{}],"node_modules/sip.js/lib/core/exceptions/transaction-state-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionStateError = void 0;

var _exception = require("./exception");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Indicates that the operation could not be completed given the current transaction state.
 * @public
 */
var TransactionStateError = /*#__PURE__*/function (_Exception) {
  _inherits(TransactionStateError, _Exception);

  var _super = _createSuper(TransactionStateError);

  function TransactionStateError(message) {
    _classCallCheck(this, TransactionStateError);

    return _super.call(this, message ? message : "Transaction state error.");
  }

  return _createClass(TransactionStateError);
}(_exception.Exception);

exports.TransactionStateError = TransactionStateError;
},{"./exception":"node_modules/sip.js/lib/core/exceptions/exception.js"}],"node_modules/sip.js/lib/core/exceptions/transport-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportError = void 0;

var _exception = require("./exception");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Transport error.
 * @public
 */
var TransportError = /*#__PURE__*/function (_Exception) {
  _inherits(TransportError, _Exception);

  var _super = _createSuper(TransportError);

  function TransportError(message) {
    _classCallCheck(this, TransportError);

    return _super.call(this, message ? message : "Unspecified transport error.");
  }

  return _createClass(TransportError);
}(_exception.Exception);

exports.TransportError = TransportError;
},{"./exception":"node_modules/sip.js/lib/core/exceptions/exception.js"}],"node_modules/sip.js/lib/core/exceptions/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _exception = require("./exception");

Object.keys(_exception).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exception[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exception[key];
    }
  });
});

var _transactionStateError = require("./transaction-state-error");

Object.keys(_transactionStateError).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactionStateError[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transactionStateError[key];
    }
  });
});

var _transportError = require("./transport-error");

Object.keys(_transportError).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transportError[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transportError[key];
    }
  });
});
},{"./exception":"node_modules/sip.js/lib/core/exceptions/exception.js","./transaction-state-error":"node_modules/sip.js/lib/core/exceptions/transaction-state-error.js","./transport-error":"node_modules/sip.js/lib/core/exceptions/transport-error.js"}],"node_modules/sip.js/lib/core/transactions/transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transaction = void 0;

var _exceptions = require("../exceptions");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Transaction.
 * @remarks
 * SIP is a transactional protocol: interactions between components take
 * place in a series of independent message exchanges.  Specifically, a
 * SIP transaction consists of a single request and any responses to
 * that request, which include zero or more provisional responses and
 * one or more final responses.  In the case of a transaction where the
 * request was an INVITE (known as an INVITE transaction), the
 * transaction also includes the ACK only if the final response was not
 * a 2xx response.  If the response was a 2xx, the ACK is not considered
 * part of the transaction.
 * https://tools.ietf.org/html/rfc3261#section-17
 * @public
 */
var Transaction = /*#__PURE__*/function () {
  function Transaction(_transport, _user, _id, _state, loggerCategory) {
    _classCallCheck(this, Transaction);

    this._transport = _transport;
    this._user = _user;
    this._id = _id;
    this._state = _state;
    this.listeners = new Array();
    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
    this.logger.debug("Constructing ".concat(this.typeToString(), " with id ").concat(this.id, "."));
  }
  /**
   * Destructor.
   * Once the transaction is in the "terminated" state, it is destroyed
   * immediately and there is no need to call `dispose`. However, if a
   * transaction needs to be ended prematurely, the transaction user may
   * do so by calling this method (for example, perhaps the UA is shutting down).
   * No state transition will occur upon calling this method, all outstanding
   * transmission timers will be cancelled, and use of the transaction after
   * calling `dispose` is undefined.
   */


  _createClass(Transaction, [{
    key: "dispose",
    value: function dispose() {
      this.logger.debug("Destroyed ".concat(this.typeToString(), " with id ").concat(this.id, "."));
    }
    /** Transaction id. */

  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
    /** Transaction kind. Deprecated. */

  }, {
    key: "kind",
    get: function get() {
      throw new Error("Invalid kind.");
    }
    /** Transaction state. */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /** Transaction transport. */

  }, {
    key: "transport",
    get: function get() {
      return this._transport;
    }
    /**
     * Sets up a function that will be called whenever the transaction state changes.
     * @param listener - Callback function.
     * @param options - An options object that specifies characteristics about the listener.
     *                  If once true, indicates that the listener should be invoked at most once after being added.
     *                  If once true, the listener would be automatically removed when invoked.
     */

  }, {
    key: "addStateChangeListener",
    value: function addStateChangeListener(listener, options) {
      var _this = this;

      var onceWrapper = function onceWrapper() {
        _this.removeStateChangeListener(onceWrapper);

        listener();
      };

      (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
    }
    /**
     * This is currently public so tests may spy on it.
     * @internal
     */

  }, {
    key: "notifyStateChangeListeners",
    value: function notifyStateChangeListeners() {
      this.listeners.slice().forEach(function (listener) {
        return listener();
      });
    }
    /**
     * Removes a listener previously registered with addStateListener.
     * @param listener - Callback function.
     */

  }, {
    key: "removeStateChangeListener",
    value: function removeStateChangeListener(listener) {
      this.listeners = this.listeners.filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "logTransportError",
    value: function logTransportError(error, message) {
      this.logger.error(error.message);
      this.logger.error("Transport error occurred in ".concat(this.typeToString(), " with id ").concat(this.id, "."));
      this.logger.error(message);
    }
    /**
     * Pass message to transport for transmission. If transport fails,
     * the transaction user is notified by callback to onTransportError().
     * @returns
     * Rejects with `TransportError` if transport fails.
     */

  }, {
    key: "send",
    value: function send(message) {
      var _this2 = this;

      return this.transport.send(message).catch(function (error) {
        // If the transport rejects, it SHOULD reject with a TransportError.
        // But the transport may be external code, so we are careful
        // make sure we convert it to a TransportError if need be.
        if (error instanceof _exceptions.TransportError) {
          _this2.onTransportError(error);

          throw error;
        }

        var transportError;

        if (error && typeof error.message === "string") {
          transportError = new _exceptions.TransportError(error.message);
        } else {
          transportError = new _exceptions.TransportError();
        }

        _this2.onTransportError(transportError);

        throw transportError;
      });
    }
  }, {
    key: "setState",
    value: function setState(state) {
      this.logger.debug("State change to \"".concat(state, "\" on ").concat(this.typeToString(), " with id ").concat(this.id, "."));
      this._state = state;

      if (this._user.onStateChange) {
        this._user.onStateChange(state);
      }

      this.notifyStateChangeListeners();
    }
  }, {
    key: "typeToString",
    value: function typeToString() {
      return "UnknownType";
    }
  }]);

  return Transaction;
}();

exports.Transaction = Transaction;
},{"../exceptions":"node_modules/sip.js/lib/core/exceptions/index.js"}],"node_modules/sip.js/lib/core/transactions/client-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClientTransaction = void 0;

var _transaction = require("./transaction");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Client Transaction.
 * @remarks
 * The client transaction provides its functionality through the
 * maintenance of a state machine.
 *
 * The TU communicates with the client transaction through a simple
 * interface.  When the TU wishes to initiate a new transaction, it
 * creates a client transaction and passes it the SIP request to send
 * and an IP address, port, and transport to which to send it.  The
 * client transaction begins execution of its state machine.  Valid
 * responses are passed up to the TU from the client transaction.
 * https://tools.ietf.org/html/rfc3261#section-17.1
 * @public
 */
var ClientTransaction = /*#__PURE__*/function (_Transaction) {
  _inherits(ClientTransaction, _Transaction);

  var _super = _createSuper(ClientTransaction);

  function ClientTransaction(_request, transport, user, state, loggerCategory) {
    var _this;

    _classCallCheck(this, ClientTransaction);

    _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory);
    _this._request = _request;
    _this.user = user; // The Via header field indicates the transport used for the transaction
    // and identifies the location where the response is to be sent.  A Via
    // header field value is added only after the transport that will be
    // used to reach the next hop has been selected (which may involve the
    // usage of the procedures in [4]).
    // https://tools.ietf.org/html/rfc3261#section-8.1.1.7

    _request.setViaHeader(_this.id, transport.protocol);

    return _this;
  }

  _createClass(ClientTransaction, [{
    key: "request",
    get:
    /** The outgoing request the transaction handling. */
    function get() {
      return this._request;
    }
    /**
     * A 408 to non-INVITE will always arrive too late to be useful ([3]),
     * The client already has full knowledge of the timeout. The only
     * information this message would convey is whether or not the server
     * believed the transaction timed out. However, with the current design
     * of the NIT, a client cannot do anything with this knowledge. Thus,
     * the 408 is simply wasting network resources and contributes to the
     * response bombardment illustrated in [3].
     * https://tools.ietf.org/html/rfc4320#section-4.1
     */

  }, {
    key: "onRequestTimeout",
    value: function onRequestTimeout() {
      if (this.user.onRequestTimeout) {
        this.user.onRequestTimeout();
      }
    }
  }], [{
    key: "makeId",
    value: function makeId(request) {
      if (request.method === "CANCEL") {
        if (!request.branch) {
          throw new Error("Outgoing CANCEL request without a branch.");
        }

        return request.branch;
      } else {
        return "z9hG4bK" + Math.floor(Math.random() * 10000000);
      }
    }
  }]);

  return ClientTransaction;
}(_transaction.Transaction);

exports.ClientTransaction = ClientTransaction;
},{"./transaction":"node_modules/sip.js/lib/core/transactions/transaction.js"}],"node_modules/sip.js/lib/core/transactions/transaction-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionState = void 0;

/**
 * Transaction state.
 * @public
 */
var TransactionState;
exports.TransactionState = TransactionState;

(function (TransactionState) {
  TransactionState["Accepted"] = "Accepted";
  TransactionState["Calling"] = "Calling";
  TransactionState["Completed"] = "Completed";
  TransactionState["Confirmed"] = "Confirmed";
  TransactionState["Proceeding"] = "Proceeding";
  TransactionState["Terminated"] = "Terminated";
  TransactionState["Trying"] = "Trying";
})(TransactionState || (exports.TransactionState = TransactionState = {}));
},{}],"node_modules/sip.js/lib/core/transactions/invite-client-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InviteClientTransaction = void 0;

var _timers = require("../timers");

var _clientTransaction = require("./client-transaction");

var _transactionState = require("./transaction-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INVITE Client Transaction.
 * @remarks
 * The INVITE transaction consists of a three-way handshake.  The client
 * transaction sends an INVITE, the server transaction sends responses,
 * and the client transaction sends an ACK.
 * https://tools.ietf.org/html/rfc3261#section-17.1.1
 * @public
 */
var InviteClientTransaction = /*#__PURE__*/function (_ClientTransaction) {
  _inherits(InviteClientTransaction, _ClientTransaction);

  var _super = _createSuper(InviteClientTransaction);

  /**
   * Constructor.
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.1
   * @param request - The outgoing INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  function InviteClientTransaction(request, transport, user) {
    var _this;

    _classCallCheck(this, InviteClientTransaction);

    _this = _super.call(this, request, transport, user, _transactionState.TransactionState.Calling, "sip.transaction.ict");
    /**
     * Map of 2xx to-tag to ACK.
     * If value is not undefined, value is the ACK which was sent.
     * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.
     * Otherwise, a 2xx was not (yet) received for this transaction.
     */

    _this.ackRetransmissionCache = new Map(); // FIXME: Timer A for unreliable transport not implemented
    //
    // If an unreliable transport is being used, the client transaction
    // MUST start timer A with a value of T1. If a reliable transport is being used,
    // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).
    // For any transport, the client transaction MUST start timer B with a value
    // of 64*T1 seconds (Timer B controls transaction timeouts).
    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
    //
    // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
    // will wait for an INVITE message to be acknowledged (a SIP response message is received).
    // So Timer B should be cleared when the transaction state proceeds from "Calling".

    _this.B = setTimeout(function () {
      return _this.timerB();
    }, _timers.Timers.TIMER_B);

    _this.send(request.toString()).catch(function (error) {
      _this.logTransportError(error, "Failed to send initial outgoing request.");
    });

    return _this;
  }
  /**
   * Destructor.
   */


  _createClass(InviteClientTransaction, [{
    key: "dispose",
    value: function dispose() {
      if (this.B) {
        clearTimeout(this.B);
        this.B = undefined;
      }

      if (this.D) {
        clearTimeout(this.D);
        this.D = undefined;
      }

      if (this.M) {
        clearTimeout(this.M);
        this.M = undefined;
      }

      _get(_getPrototypeOf(InviteClientTransaction.prototype), "dispose", this).call(this);
    }
    /** Transaction kind. Deprecated. */

  }, {
    key: "kind",
    get: function get() {
      return "ict";
    }
    /**
     * ACK a 2xx final response.
     *
     * The transaction includes the ACK only if the final response was not a 2xx response (the
     * transaction will generate and send the ACK to the transport automagically). If the
     * final response was a 2xx, the ACK is not considered part of the transaction (the
     * transaction user needs to generate and send the ACK).
     *
     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
     * by the transaction layer (instead of the UAC core). The "standard" approach is for
     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
     * and any retransmissions of those ACKs as needed.
     *
     * @param ack - The outgoing ACK request.
     */

  }, {
    key: "ackResponse",
    value: function ackResponse(ack) {
      var _this2 = this;

      var toTag = ack.toTag;

      if (!toTag) {
        throw new Error("To tag undefined.");
      }

      var id = "z9hG4bK" + Math.floor(Math.random() * 10000000);
      ack.setViaHeader(id, this.transport.protocol);
      this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache

      this.send(ack.toString()).catch(function (error) {
        _this2.logTransportError(error, "Failed to send ACK to 2xx response.");
      });
    }
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(response) {
      var _this3 = this;

      var statusCode = response.statusCode;

      if (!statusCode || statusCode < 100 || statusCode > 699) {
        throw new Error("Invalid status code ".concat(statusCode));
      }

      switch (this.state) {
        case _transactionState.TransactionState.Calling:
          // If the client transaction receives a provisional response while in
          // the "Calling" state, it transitions to the "Proceeding" state. In the
          // "Proceeding" state, the client transaction SHOULD NOT retransmit the
          // request any longer. Furthermore, the provisional response MUST be
          // passed to the TU.  Any further provisional responses MUST be passed
          // up to the TU while in the "Proceeding" state.
          // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
          if (statusCode >= 100 && statusCode <= 199) {
            this.stateTransition(_transactionState.TransactionState.Proceeding);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          } // When a 2xx response is received while in either the "Calling" or
          // "Proceeding" states, the client transaction MUST transition to
          // the "Accepted" state... The 2xx response MUST be passed up to the TU.
          // The client transaction MUST NOT generate an ACK to the 2xx response -- its
          // handling is delegated to the TU. A UAC core will send an ACK to
          // the 2xx response using a new transaction.
          // https://tools.ietf.org/html/rfc6026#section-8.4


          if (statusCode >= 200 && statusCode <= 299) {
            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache

            this.stateTransition(_transactionState.TransactionState.Accepted);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          } // When in either the "Calling" or "Proceeding" states, reception of
          // a response with status code from 300-699 MUST cause the client
          // transaction to transition to "Completed". The client transaction
          // MUST pass the received response up to the TU, and the client
          // transaction MUST generate an ACK request, even if the transport is
          // reliable (guidelines for constructing the ACK from the response
          // are given in Section 17.1.1.3), and then pass the ACK to the
          // transport layer for transmission. The ACK MUST be sent to the
          // same address, port, and transport to which the original request was sent.
          // https://tools.ietf.org/html/rfc6026#section-8.4


          if (statusCode >= 300 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);
            this.ack(response);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          }

          break;

        case _transactionState.TransactionState.Proceeding:
          // In the "Proceeding" state, the client transaction SHOULD NOT retransmit the
          // request any longer. Furthermore, the provisional response MUST be
          // passed to the TU.  Any further provisional responses MUST be passed
          // up to the TU while in the "Proceeding" state.
          // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
          if (statusCode >= 100 && statusCode <= 199) {
            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          } // When a 2xx response is received while in either the "Calling" or "Proceeding" states,
          // the client transaction MUST transition to the "Accepted" state...
          // The 2xx response MUST be passed up to the TU. The client
          // transaction MUST NOT generate an ACK to the 2xx response -- its
          // handling is delegated to the TU. A UAC core will send an ACK to
          // the 2xx response using a new transaction.
          // https://tools.ietf.org/html/rfc6026#section-8.4


          if (statusCode >= 200 && statusCode <= 299) {
            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache

            this.stateTransition(_transactionState.TransactionState.Accepted);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          } // When in either the "Calling" or "Proceeding" states, reception of
          // a response with status code from 300-699 MUST cause the client
          // transaction to transition to "Completed". The client transaction
          // MUST pass the received response up to the TU, and the client
          // transaction MUST generate an ACK request, even if the transport is
          // reliable (guidelines for constructing the ACK from the response
          // are given in Section 17.1.1.3), and then pass the ACK to the
          // transport layer for transmission. The ACK MUST be sent to the
          // same address, port, and transport to which the original request was sent.
          // https://tools.ietf.org/html/rfc6026#section-8.4


          if (statusCode >= 300 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);
            this.ack(response);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          }

          break;

        case _transactionState.TransactionState.Accepted:
          // The purpose of the "Accepted" state is to allow the client
          // transaction to continue to exist to receive, and pass to the TU,
          // any retransmissions of the 2xx response and any additional 2xx
          // responses from other branches of the INVITE if it forked
          // downstream. Timer M reflects the amount of time that the
          // transaction user will wait for such messages.
          //
          // Any 2xx responses that match this client transaction and that are
          // received while in the "Accepted" state MUST be passed up to the
          // TU. The client transaction MUST NOT generate an ACK to the 2xx
          // response. The client transaction takes no further action.
          // https://tools.ietf.org/html/rfc6026#section-8.4
          if (statusCode >= 200 && statusCode <= 299) {
            // NOTE: This implementation herein is intentionally not RFC compliant.
            // While the first 2xx response for a given branch is passed up to the TU,
            // retransmissions of 2xx responses are absorbed and the ACK associated
            // with the original response is resent. This approach is taken because
            // our current transaction users are not currently in a good position to
            // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)
            //
            // If we don't have a cache hit, pass the response to the TU.
            if (!this.ackRetransmissionCache.has(response.toTag)) {
              this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache

              if (this.user.receiveResponse) {
                this.user.receiveResponse(response);
              }

              return;
            } // If we have a cache hit, try pulling the ACK from cache and retransmitting it.


            var ack = this.ackRetransmissionCache.get(response.toTag);

            if (ack) {
              this.send(ack.toString()).catch(function (error) {
                _this3.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
              });
              return;
            } // If an ACK was not found in cache then we have received a retransmitted 2xx
            // response before the TU responded to the original response (we don't have an ACK yet).
            // So discard this response under the assumption that the TU will eventually
            // get us a ACK for the original response.


            return;
          }

          break;

        case _transactionState.TransactionState.Completed:
          // Any retransmissions of a response with status code 300-699 that
          // are received while in the "Completed" state MUST cause the ACK to
          // be re-passed to the transport layer for retransmission, but the
          // newly received response MUST NOT be passed up to the TU.
          // https://tools.ietf.org/html/rfc6026#section-8.4
          if (statusCode >= 300 && statusCode <= 699) {
            this.ack(response);
            return;
          }

          break;

        case _transactionState.TransactionState.Terminated:
          break;

        default:
          throw new Error("Invalid state ".concat(this.state));
      } // Any response received that does not match an existing client
      // transaction state machine is simply dropped. (Implementations are,
      // of course, free to log or do other implementation-specific things
      // with such responses, but the implementer should be sure to consider
      // the impact of large numbers of malicious stray responses.)
      // https://tools.ietf.org/html/rfc6026#section-7.2


      var message = "Received unexpected ".concat(statusCode, " response while in state ").concat(this.state, ".");
      this.logger.warn(message);
      return;
    }
    /**
     * The client transaction SHOULD inform the TU that a transport failure
     * has occurred, and the client transaction SHOULD transition directly
     * to the "Terminated" state.  The TU will handle the failover
     * mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - The error.
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      if (this.user.onTransportError) {
        this.user.onTransportError(error);
      }

      this.stateTransition(_transactionState.TransactionState.Terminated, true);
    }
    /** For logging. */

  }, {
    key: "typeToString",
    value: function typeToString() {
      return "INVITE client transaction";
    }
  }, {
    key: "ack",
    value: function ack(response) {
      var _this4 = this;

      // The ACK request constructed by the client transaction MUST contain
      // values for the Call-ID, From, and Request-URI that are equal to the
      // values of those header fields in the request passed to the transport
      // by the client transaction (call this the "original request"). The To
      // header field in the ACK MUST equal the To header field in the
      // response being acknowledged, and therefore will usually differ from
      // the To header field in the original request by the addition of the
      // tag parameter. The ACK MUST contain a single Via header field, and
      // this MUST be equal to the top Via header field of the original
      // request. The CSeq header field in the ACK MUST contain the same
      // value for the sequence number as was present in the original request,
      // but the method parameter MUST be equal to "ACK".
      //
      // If the INVITE request whose response is being acknowledged had Route
      // header fields, those header fields MUST appear in the ACK. This is
      // to ensure that the ACK can be routed properly through any downstream
      // stateless proxies.
      // https://tools.ietf.org/html/rfc3261#section-17.1.1.3
      var ruri = this.request.ruri;
      var callId = this.request.callId;
      var cseq = this.request.cseq;
      var from = this.request.getHeader("from");
      var to = response.getHeader("to");
      var via = this.request.getHeader("via");
      var route = this.request.getHeader("route");

      if (!from) {
        throw new Error("From undefined.");
      }

      if (!to) {
        throw new Error("To undefined.");
      }

      if (!via) {
        throw new Error("Via undefined.");
      }

      var ack = "ACK ".concat(ruri, " SIP/2.0\r\n");

      if (route) {
        ack += "Route: ".concat(route, "\r\n");
      }

      ack += "Via: ".concat(via, "\r\n");
      ack += "To: ".concat(to, "\r\n");
      ack += "From: ".concat(from, "\r\n");
      ack += "Call-ID: ".concat(callId, "\r\n");
      ack += "CSeq: ".concat(cseq, " ACK\r\n");
      ack += "Max-Forwards: 70\r\n";
      ack += "Content-Length: 0\r\n\r\n"; // TOOO: "User-Agent" header

      this.send(ack).catch(function (error) {
        _this4.logTransportError(error, "Failed to send ACK to non-2xx response.");
      });
      return;
    }
    /**
     * Execute a state transition.
     * @param newState - New state.
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this5 = this;

      var dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Assert valid state transitions.
      var invalidStateTransition = function invalidStateTransition() {
        throw new Error("Invalid state transition from ".concat(_this5.state, " to ").concat(newState));
      };

      switch (newState) {
        case _transactionState.TransactionState.Calling:
          invalidStateTransition();
          break;

        case _transactionState.TransactionState.Proceeding:
          if (this.state !== _transactionState.TransactionState.Calling) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Accepted:
        case _transactionState.TransactionState.Completed:
          if (this.state !== _transactionState.TransactionState.Calling && this.state !== _transactionState.TransactionState.Proceeding) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Terminated:
          if (this.state !== _transactionState.TransactionState.Calling && this.state !== _transactionState.TransactionState.Accepted && this.state !== _transactionState.TransactionState.Completed) {
            if (!dueToTransportError) {
              invalidStateTransition();
            }
          }

          break;

        default:
          invalidStateTransition();
      } // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
      // will wait for an INVITE message to be acknowledged (a SIP response message is received).
      // So Timer B should be cleared when the transaction state proceeds from "Calling".


      if (this.B) {
        clearTimeout(this.B);
        this.B = undefined;
      }

      if (newState === _transactionState.TransactionState.Proceeding) {// Timers have no effect on "Proceeding" state.
        // In the "Proceeding" state, the client transaction
        // SHOULD NOT retransmit the request any longer.
        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
      } // The client transaction MUST start Timer D when it enters the "Completed" state
      // for any reason, with a value of at least 32 seconds for unreliable transports,
      // and a value of zero seconds for reliable transports.
      // https://tools.ietf.org/html/rfc6026#section-8.4


      if (newState === _transactionState.TransactionState.Completed) {
        this.D = setTimeout(function () {
          return _this5.timerD();
        }, _timers.Timers.TIMER_D);
      } // The client transaction MUST transition to the "Accepted" state,
      // and Timer M MUST be started with a value of 64*T1.
      // https://tools.ietf.org/html/rfc6026#section-8.4


      if (newState === _transactionState.TransactionState.Accepted) {
        this.M = setTimeout(function () {
          return _this5.timerM();
        }, _timers.Timers.TIMER_M);
      } // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
      // https://tools.ietf.org/html/rfc6026#section-8.7


      if (newState === _transactionState.TransactionState.Terminated) {
        this.dispose();
      } // Update state.


      this.setState(newState);
    }
    /**
     * When timer A fires, the client transaction MUST retransmit the
     * request by passing it to the transport layer, and MUST reset the
     * timer with a value of 2*T1.
     * When timer A fires 2*T1 seconds later, the request MUST be
     * retransmitted again (assuming the client transaction is still in this
     * state). This process MUST continue so that the request is
     * retransmitted with intervals that double after each transmission.
     * These retransmissions SHOULD only be done while the client
     * transaction is in the "Calling" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */

  }, {
    key: "timerA",
    value: function timerA() {// TODO
    }
    /**
     * If the client transaction is still in the "Calling" state when timer
     * B fires, the client transaction SHOULD inform the TU that a timeout
     * has occurred.  The client transaction MUST NOT generate an ACK.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */

  }, {
    key: "timerB",
    value: function timerB() {
      this.logger.debug("Timer B expired for INVITE client transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Calling) {
        this.onRequestTimeout();
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
    /**
     * If Timer D fires while the client transaction is in the "Completed" state,
     * the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */

  }, {
    key: "timerD",
    value: function timerD() {
      this.logger.debug("Timer D expired for INVITE client transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Completed) {
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
    /**
     * If Timer M fires while the client transaction is in the "Accepted"
     * state, the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */

  }, {
    key: "timerM",
    value: function timerM() {
      this.logger.debug("Timer M expired for INVITE client transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Accepted) {
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
  }]);

  return InviteClientTransaction;
}(_clientTransaction.ClientTransaction);

exports.InviteClientTransaction = InviteClientTransaction;
},{"../timers":"node_modules/sip.js/lib/core/timers.js","./client-transaction":"node_modules/sip.js/lib/core/transactions/client-transaction.js","./transaction-state":"node_modules/sip.js/lib/core/transactions/transaction-state.js"}],"node_modules/sip.js/lib/core/transactions/server-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerTransaction = void 0;

var _transaction = require("./transaction");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Server Transaction.
 * @remarks
 * The server transaction is responsible for the delivery of requests to
 * the TU and the reliable transmission of responses.  It accomplishes
 * this through a state machine.  Server transactions are created by the
 * core when a request is received, and transaction handling is desired
 * for that request (this is not always the case).
 * https://tools.ietf.org/html/rfc3261#section-17.2
 * @public
 */
var ServerTransaction = /*#__PURE__*/function (_Transaction) {
  _inherits(ServerTransaction, _Transaction);

  var _super = _createSuper(ServerTransaction);

  function ServerTransaction(_request, transport, user, state, loggerCategory) {
    var _this;

    _classCallCheck(this, ServerTransaction);

    _this = _super.call(this, transport, user, _request.viaBranch, state, loggerCategory);
    _this._request = _request;
    _this.user = user;
    return _this;
  }
  /** The incoming request the transaction handling. */


  _createClass(ServerTransaction, [{
    key: "request",
    get: function get() {
      return this._request;
    }
  }]);

  return ServerTransaction;
}(_transaction.Transaction);

exports.ServerTransaction = ServerTransaction;
},{"./transaction":"node_modules/sip.js/lib/core/transactions/transaction.js"}],"node_modules/sip.js/lib/core/transactions/invite-server-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InviteServerTransaction = void 0;

var _messages = require("../messages");

var _timers = require("../timers");

var _serverTransaction = require("./server-transaction");

var _transactionState = require("./transaction-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.1
 * @public
 */
var InviteServerTransaction = /*#__PURE__*/function (_ServerTransaction) {
  _inherits(InviteServerTransaction, _ServerTransaction);

  var _super = _createSuper(InviteServerTransaction);

  /**
   * Constructor.
   * Upon construction, a "100 Trying" reply will be immediately sent.
   * After construction the transaction will be in the "proceeding" state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.1
   * @param request - Incoming INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  function InviteServerTransaction(request, transport, user) {
    _classCallCheck(this, InviteServerTransaction);

    return _super.call(this, request, transport, user, _transactionState.TransactionState.Proceeding, "sip.transaction.ist");
  }
  /**
   * Destructor.
   */


  _createClass(InviteServerTransaction, [{
    key: "dispose",
    value: function dispose() {
      this.stopProgressExtensionTimer();

      if (this.H) {
        clearTimeout(this.H);
        this.H = undefined;
      }

      if (this.I) {
        clearTimeout(this.I);
        this.I = undefined;
      }

      if (this.L) {
        clearTimeout(this.L);
        this.L = undefined;
      }

      _get(_getPrototypeOf(InviteServerTransaction.prototype), "dispose", this).call(this);
    }
    /** Transaction kind. Deprecated. */

  }, {
    key: "kind",
    get: function get() {
      return "ist";
    }
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */

  }, {
    key: "receiveRequest",
    value: function receiveRequest(request) {
      var _this = this;

      switch (this.state) {
        case _transactionState.TransactionState.Proceeding:
          // If a request retransmission is received while in the "Proceeding" state, the most
          // recent provisional response that was received from the TU MUST be passed to the
          // transport layer for retransmission.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1
          if (request.method === _messages.C.INVITE) {
            if (this.lastProvisionalResponse) {
              this.send(this.lastProvisionalResponse).catch(function (error) {
                _this.logTransportError(error, "Failed to send retransmission of provisional response.");
              });
            }

            return;
          }

          break;

        case _transactionState.TransactionState.Accepted:
          // While in the "Accepted" state, any retransmissions of the INVITE
          // received will match this transaction state machine and will be
          // absorbed by the machine without changing its state. These
          // retransmissions are not passed onto the TU.
          // https://tools.ietf.org/html/rfc6026#section-7.1
          if (request.method === _messages.C.INVITE) {
            return;
          }

          break;

        case _transactionState.TransactionState.Completed:
          // Furthermore, while in the "Completed" state, if a request retransmission is
          // received, the server SHOULD pass the response to the transport for retransmission.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1
          if (request.method === _messages.C.INVITE) {
            if (!this.lastFinalResponse) {
              throw new Error("Last final response undefined.");
            }

            this.send(this.lastFinalResponse).catch(function (error) {
              _this.logTransportError(error, "Failed to send retransmission of final response.");
            });
            return;
          } // If an ACK is received while the server transaction is in the "Completed" state,
          // the server transaction MUST transition to the "Confirmed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1


          if (request.method === _messages.C.ACK) {
            this.stateTransition(_transactionState.TransactionState.Confirmed);
            return;
          }

          break;

        case _transactionState.TransactionState.Confirmed:
          // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
          // triggered from retransmissions of the final response.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1
          if (request.method === _messages.C.INVITE || request.method === _messages.C.ACK) {
            return;
          }

          break;

        case _transactionState.TransactionState.Terminated:
          // For good measure absorb any additional messages that arrive (should not happen).
          if (request.method === _messages.C.INVITE || request.method === _messages.C.ACK) {
            return;
          }

          break;

        default:
          throw new Error("Invalid state ".concat(this.state));
      }

      var message = "INVITE server transaction received unexpected ".concat(request.method, " request while in state ").concat(this.state, ".");
      this.logger.warn(message);
      return;
    }
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response.
     * @param response - Response.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(statusCode, response) {
      var _this2 = this;

      if (statusCode < 100 || statusCode > 699) {
        throw new Error("Invalid status code ".concat(statusCode));
      }

      switch (this.state) {
        case _transactionState.TransactionState.Proceeding:
          // The TU passes any number of provisional responses to the server
          // transaction. So long as the server transaction is in the
          // "Proceeding" state, each of these MUST be passed to the transport
          // layer for transmission. They are not sent reliably by the
          // transaction layer (they are not retransmitted by it) and do not cause
          // a change in the state of the server transaction.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1
          if (statusCode >= 100 && statusCode <= 199) {
            this.lastProvisionalResponse = response; // Start the progress extension timer only for a non-100 provisional response.

            if (statusCode > 100) {
              this.startProgressExtensionTimer(); // FIXME: remove
            }

            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send 1xx response.");
            });
            return;
          } // If, while in the "Proceeding" state, the TU passes a 2xx response
          // to the server transaction, the server transaction MUST pass this
          // response to the transport layer for transmission. It is not
          // retransmitted by the server transaction; retransmissions of 2xx
          // responses are handled by the TU. The server transaction MUST then
          // transition to the "Accepted" state.
          // https://tools.ietf.org/html/rfc6026#section-8.5


          if (statusCode >= 200 && statusCode <= 299) {
            this.lastFinalResponse = response;
            this.stateTransition(_transactionState.TransactionState.Accepted);
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send 2xx response.");
            });
            return;
          } // While in the "Proceeding" state, if the TU passes a response with
          // status code from 300 to 699 to the server transaction, the response
          // MUST be passed to the transport layer for transmission, and the state
          // machine MUST enter the "Completed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1


          if (statusCode >= 300 && statusCode <= 699) {
            this.lastFinalResponse = response;
            this.stateTransition(_transactionState.TransactionState.Completed);
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send non-2xx final response.");
            });
            return;
          }

          break;

        case _transactionState.TransactionState.Accepted:
          // While in the "Accepted" state, if the TU passes a 2xx response,
          // the server transaction MUST pass the response to the transport layer for transmission.
          // https://tools.ietf.org/html/rfc6026#section-8.7
          if (statusCode >= 200 && statusCode <= 299) {
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send 2xx response.");
            });
            return;
          }

          break;

        case _transactionState.TransactionState.Completed:
          break;

        case _transactionState.TransactionState.Confirmed:
          break;

        case _transactionState.TransactionState.Terminated:
          break;

        default:
          throw new Error("Invalid state ".concat(this.state));
      }

      var message = "INVITE server transaction received unexpected ".concat(statusCode, " response from TU while in state ").concat(this.state, ".");
      this.logger.error(message);
      throw new Error(message);
    }
    /**
     * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
     */

  }, {
    key: "retransmitAcceptedResponse",
    value: function retransmitAcceptedResponse() {
      var _this3 = this;

      if (this.state === _transactionState.TransactionState.Accepted && this.lastFinalResponse) {
        this.send(this.lastFinalResponse).catch(function (error) {
          _this3.logTransportError(error, "Failed to send 2xx response.");
        });
      }
    }
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and MUST remain in the current state.
     * https://tools.ietf.org/html/rfc6026#section-8.8
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      if (this.user.onTransportError) {
        this.user.onTransportError(error);
      }
    }
    /** For logging. */

  }, {
    key: "typeToString",
    value: function typeToString() {
      return "INVITE server transaction";
    }
    /**
     * Execute a state transition.
     * @param newState - New state.
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this4 = this;

      // Assert valid state transitions.
      var invalidStateTransition = function invalidStateTransition() {
        throw new Error("Invalid state transition from ".concat(_this4.state, " to ").concat(newState));
      };

      switch (newState) {
        case _transactionState.TransactionState.Proceeding:
          invalidStateTransition();
          break;

        case _transactionState.TransactionState.Accepted:
        case _transactionState.TransactionState.Completed:
          if (this.state !== _transactionState.TransactionState.Proceeding) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Confirmed:
          if (this.state !== _transactionState.TransactionState.Completed) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Terminated:
          if (this.state !== _transactionState.TransactionState.Accepted && this.state !== _transactionState.TransactionState.Completed && this.state !== _transactionState.TransactionState.Confirmed) {
            invalidStateTransition();
          }

          break;

        default:
          invalidStateTransition();
      } // On any state transition, stop resending provisional responses


      this.stopProgressExtensionTimer(); // The purpose of the "Accepted" state is to absorb retransmissions of an accepted INVITE request.
      // Any such retransmissions are absorbed entirely within the server transaction.
      // They are not passed up to the TU since any downstream UAS cores that accepted the request have
      // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.
      // https://tools.ietf.org/html/rfc6026#section-8.7

      if (newState === _transactionState.TransactionState.Accepted) {
        this.L = setTimeout(function () {
          return _this4.timerL();
        }, _timers.Timers.TIMER_L);
      } // When the "Completed" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.
      // Timer H determines when the server transaction abandons retransmitting the response.
      // If an ACK is received while the server transaction is in the "Completed" state,
      // the server transaction MUST transition to the "Confirmed" state.
      // https://tools.ietf.org/html/rfc3261#section-17.2.1


      if (newState === _transactionState.TransactionState.Completed) {
        // FIXME: Missing timer G for unreliable transports.
        this.H = setTimeout(function () {
          return _this4.timerH();
        }, _timers.Timers.TIMER_H);
      } // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
      // triggered from retransmissions of the final response. When this state is entered, timer I
      // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable
      // transports. Once timer I fires, the server MUST transition to the "Terminated" state.
      // https://tools.ietf.org/html/rfc3261#section-17.2.1


      if (newState === _transactionState.TransactionState.Confirmed) {
        // FIXME: This timer is not getting set correctly for unreliable transports.
        this.I = setTimeout(function () {
          return _this4.timerI();
        }, _timers.Timers.TIMER_I);
      } // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
      // https://tools.ietf.org/html/rfc6026#section-8.7


      if (newState === _transactionState.TransactionState.Terminated) {
        this.dispose();
      } // Update state.


      this.setState(newState);
    }
    /**
     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */

  }, {
    key: "startProgressExtensionTimer",
    value: function startProgressExtensionTimer() {
      var _this5 = this;

      // Start the progress extension timer only for the first non-100 provisional response.
      if (this.progressExtensionTimer === undefined) {
        this.progressExtensionTimer = setInterval(function () {
          _this5.logger.debug("Progress extension timer expired for INVITE server transaction ".concat(_this5.id, "."));

          if (!_this5.lastProvisionalResponse) {
            throw new Error("Last provisional response undefined.");
          }

          _this5.send(_this5.lastProvisionalResponse).catch(function (error) {
            _this5.logTransportError(error, "Failed to send retransmission of provisional response.");
          });
        }, _timers.Timers.PROVISIONAL_RESPONSE_INTERVAL);
      }
    }
    /**
     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */

  }, {
    key: "stopProgressExtensionTimer",
    value: function stopProgressExtensionTimer() {
      if (this.progressExtensionTimer !== undefined) {
        clearInterval(this.progressExtensionTimer);
        this.progressExtensionTimer = undefined;
      }
    }
    /**
     * While in the "Proceeding" state, if the TU passes a response with status code
     * from 300 to 699 to the server transaction, the response MUST be passed to the
     * transport layer for transmission, and the state machine MUST enter the "Completed" state.
     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
     * reliable transports. If timer G fires, the response is passed to the transport layer once
     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
     * when timer G fires, the response is passed to the transport again for transmission, and
     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
     * it is reset with the value of T2.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */

  }, {
    key: "timerG",
    value: function timerG() {// TODO
    }
    /**
     * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
     * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
     * indicate to the TU that a transaction failure has occurred.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */

  }, {
    key: "timerH",
    value: function timerH() {
      this.logger.debug("Timer H expired for INVITE server transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Completed) {
        this.logger.warn("ACK to negative final response was never received, terminating transaction.");
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
    /**
     * Once timer I fires, the server MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */

  }, {
    key: "timerI",
    value: function timerI() {
      this.logger.debug("Timer I expired for INVITE server transaction ".concat(this.id, "."));
      this.stateTransition(_transactionState.TransactionState.Terminated);
    }
    /**
     * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
     * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
     * it MUST be destroyed immediately. Timer L reflects the amount of time the server
     * transaction could receive 2xx responses for retransmission from the
     * TU while it is waiting to receive an ACK.
     * https://tools.ietf.org/html/rfc6026#section-7.1
     * https://tools.ietf.org/html/rfc6026#section-8.7
     */

  }, {
    key: "timerL",
    value: function timerL() {
      this.logger.debug("Timer L expired for INVITE server transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Accepted) {
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
  }]);

  return InviteServerTransaction;
}(_serverTransaction.ServerTransaction);

exports.InviteServerTransaction = InviteServerTransaction;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../timers":"node_modules/sip.js/lib/core/timers.js","./server-transaction":"node_modules/sip.js/lib/core/transactions/server-transaction.js","./transaction-state":"node_modules/sip.js/lib/core/transactions/transaction-state.js"}],"node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NonInviteClientTransaction = void 0;

var _timers = require("../timers");

var _clientTransaction = require("./client-transaction");

var _transactionState = require("./transaction-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Non-INVITE Client Transaction.
 * @remarks
 * Non-INVITE transactions do not make use of ACK.
 * They are simple request-response interactions.
 * https://tools.ietf.org/html/rfc3261#section-17.1.2
 * @public
 */
var NonInviteClientTransaction = /*#__PURE__*/function (_ClientTransaction) {
  _inherits(NonInviteClientTransaction, _ClientTransaction);

  var _super = _createSuper(NonInviteClientTransaction);

  /**
   * Constructor
   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
   * Then `toString` is called on the outgoing request and the message is sent via the transport.
   * After construction the transaction will be in the "calling" state and the transaction id
   * will equal the branch parameter set in the Via header of the outgoing request.
   * https://tools.ietf.org/html/rfc3261#section-17.1.2
   * @param request - The outgoing Non-INVITE request.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  function NonInviteClientTransaction(request, transport, user) {
    var _this;

    _classCallCheck(this, NonInviteClientTransaction);

    _this = _super.call(this, request, transport, user, _transactionState.TransactionState.Trying, "sip.transaction.nict"); // FIXME: Timer E for unreliable transports not implemented.
    //
    // The "Trying" state is entered when the TU initiates a new client
    // transaction with a request.  When entering this state, the client
    // transaction SHOULD set timer F to fire in 64*T1 seconds. The request
    // MUST be passed to the transport layer for transmission.
    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2

    _this.F = setTimeout(function () {
      return _this.timerF();
    }, _timers.Timers.TIMER_F);

    _this.send(request.toString()).catch(function (error) {
      _this.logTransportError(error, "Failed to send initial outgoing request.");
    });

    return _this;
  }
  /**
   * Destructor.
   */


  _createClass(NonInviteClientTransaction, [{
    key: "dispose",
    value: function dispose() {
      if (this.F) {
        clearTimeout(this.F);
        this.F = undefined;
      }

      if (this.K) {
        clearTimeout(this.K);
        this.K = undefined;
      }

      _get(_getPrototypeOf(NonInviteClientTransaction.prototype), "dispose", this).call(this);
    }
    /** Transaction kind. Deprecated. */

  }, {
    key: "kind",
    get: function get() {
      return "nict";
    }
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(response) {
      var statusCode = response.statusCode;

      if (!statusCode || statusCode < 100 || statusCode > 699) {
        throw new Error("Invalid status code ".concat(statusCode));
      }

      switch (this.state) {
        case _transactionState.TransactionState.Trying:
          // If a provisional response is received while in the "Trying" state, the
          // response MUST be passed to the TU, and then the client transaction
          // SHOULD move to the "Proceeding" state.
          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
          if (statusCode >= 100 && statusCode <= 199) {
            this.stateTransition(_transactionState.TransactionState.Proceeding);

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          } // If a final response (status codes 200-699) is received while in the
          // "Trying" state, the response MUST be passed to the TU, and the
          // client transaction MUST transition to the "Completed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2


          if (statusCode >= 200 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);

            if (statusCode === 408) {
              this.onRequestTimeout();
              return;
            }

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          }

          break;

        case _transactionState.TransactionState.Proceeding:
          // If a provisional response is received while in the "Proceeding" state,
          // the response MUST be passed to the TU. (From Figure 6)
          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
          if (statusCode >= 100 && statusCode <= 199) {
            if (this.user.receiveResponse) {
              return this.user.receiveResponse(response);
            }
          } // If a final response (status codes 200-699) is received while in the
          // "Proceeding" state, the response MUST be passed to the TU, and the
          // client transaction MUST transition to the "Completed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2


          if (statusCode >= 200 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);

            if (statusCode === 408) {
              this.onRequestTimeout();
              return;
            }

            if (this.user.receiveResponse) {
              this.user.receiveResponse(response);
            }

            return;
          }

          break;

        case _transactionState.TransactionState.Completed:
          // The "Completed" state exists to buffer any additional response
          // retransmissions that may be received (which is why the client
          // transaction remains there only for unreliable transports).
          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
          return;

        case _transactionState.TransactionState.Terminated:
          // For good measure just absorb additional response retransmissions.
          return;

        default:
          throw new Error("Invalid state ".concat(this.state));
      }

      var message = "Non-INVITE client transaction received unexpected ".concat(statusCode, " response while in state ").concat(this.state, ".");
      this.logger.warn(message);
      return;
    }
    /**
     * The client transaction SHOULD inform the TU that a transport failure has occurred,
     * and the client transaction SHOULD transition directly to the "Terminated" state.
     * The TU will handle the fail over mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - Transport error
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      if (this.user.onTransportError) {
        this.user.onTransportError(error);
      }

      this.stateTransition(_transactionState.TransactionState.Terminated, true);
    }
    /** For logging. */

  }, {
    key: "typeToString",
    value: function typeToString() {
      return "non-INVITE client transaction";
    }
    /**
     * Execute a state transition.
     * @param newState - New state.
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this2 = this;

      var dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Assert valid state transitions.
      var invalidStateTransition = function invalidStateTransition() {
        throw new Error("Invalid state transition from ".concat(_this2.state, " to ").concat(newState));
      };

      switch (newState) {
        case _transactionState.TransactionState.Trying:
          invalidStateTransition();
          break;

        case _transactionState.TransactionState.Proceeding:
          if (this.state !== _transactionState.TransactionState.Trying) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Completed:
          if (this.state !== _transactionState.TransactionState.Trying && this.state !== _transactionState.TransactionState.Proceeding) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Terminated:
          if (this.state !== _transactionState.TransactionState.Trying && this.state !== _transactionState.TransactionState.Proceeding && this.state !== _transactionState.TransactionState.Completed) {
            if (!dueToTransportError) {
              invalidStateTransition();
            }
          }

          break;

        default:
          invalidStateTransition();
      } // Once the client transaction enters the "Completed" state, it MUST set
      // Timer K to fire in T4 seconds for unreliable transports, and zero
      // seconds for reliable transports  The "Completed" state exists to
      // buffer any additional response retransmissions that may be received
      // (which is why the client transaction remains there only for unreliable transports).
      // https://tools.ietf.org/html/rfc3261#section-17.1.2.2


      if (newState === _transactionState.TransactionState.Completed) {
        if (this.F) {
          clearTimeout(this.F);
          this.F = undefined;
        }

        this.K = setTimeout(function () {
          return _this2.timerK();
        }, _timers.Timers.TIMER_K);
      } // Once the transaction is in the terminated state, it MUST be destroyed immediately.
      // https://tools.ietf.org/html/rfc3261#section-17.1.2.2


      if (newState === _transactionState.TransactionState.Terminated) {
        this.dispose();
      } // Update state.


      this.setState(newState);
    }
    /**
     * If Timer F fires while the client transaction is still in the
     * "Trying" state, the client transaction SHOULD inform the TU about the
     * timeout, and then it SHOULD enter the "Terminated" state.
     * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
     * a timeout, and the client transaction MUST transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */

  }, {
    key: "timerF",
    value: function timerF() {
      this.logger.debug("Timer F expired for non-INVITE client transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Trying || this.state === _transactionState.TransactionState.Proceeding) {
        this.onRequestTimeout();
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
    /**
     * If Timer K fires while in this (COMPLETED) state, the client transaction
     * MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */

  }, {
    key: "timerK",
    value: function timerK() {
      if (this.state === _transactionState.TransactionState.Completed) {
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
  }]);

  return NonInviteClientTransaction;
}(_clientTransaction.ClientTransaction);

exports.NonInviteClientTransaction = NonInviteClientTransaction;
},{"../timers":"node_modules/sip.js/lib/core/timers.js","./client-transaction":"node_modules/sip.js/lib/core/transactions/client-transaction.js","./transaction-state":"node_modules/sip.js/lib/core/transactions/transaction-state.js"}],"node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NonInviteServerTransaction = void 0;

var _timers = require("../timers");

var _serverTransaction = require("./server-transaction");

var _transactionState = require("./transaction-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Non-INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.2
 * @public
 */
var NonInviteServerTransaction = /*#__PURE__*/function (_ServerTransaction) {
  _inherits(NonInviteServerTransaction, _ServerTransaction);

  var _super = _createSuper(NonInviteServerTransaction);

  /**
   * Constructor.
   * After construction the transaction will be in the "trying": state and the transaction
   * `id` will equal the branch parameter set in the Via header of the incoming request.
   * https://tools.ietf.org/html/rfc3261#section-17.2.2
   * @param request - Incoming Non-INVITE request from the transport.
   * @param transport - The transport.
   * @param user - The transaction user.
   */
  function NonInviteServerTransaction(request, transport, user) {
    _classCallCheck(this, NonInviteServerTransaction);

    return _super.call(this, request, transport, user, _transactionState.TransactionState.Trying, "sip.transaction.nist");
  }
  /**
   * Destructor.
   */


  _createClass(NonInviteServerTransaction, [{
    key: "dispose",
    value: function dispose() {
      if (this.J) {
        clearTimeout(this.J);
        this.J = undefined;
      }

      _get(_getPrototypeOf(NonInviteServerTransaction.prototype), "dispose", this).call(this);
    }
    /** Transaction kind. Deprecated. */

  }, {
    key: "kind",
    get: function get() {
      return "nist";
    }
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "receiveRequest",
    value: function receiveRequest(request) {
      var _this = this;

      switch (this.state) {
        case _transactionState.TransactionState.Trying:
          // Once in the "Trying" state, any further request retransmissions are discarded.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          break;

        case _transactionState.TransactionState.Proceeding:
          // If a retransmission of the request is received while in the "Proceeding" state,
          // the most recently sent provisional response MUST be passed to the transport layer for retransmission.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          if (!this.lastResponse) {
            throw new Error("Last response undefined.");
          }

          this.send(this.lastResponse).catch(function (error) {
            _this.logTransportError(error, "Failed to send retransmission of provisional response.");
          });
          break;

        case _transactionState.TransactionState.Completed:
          // While in the "Completed" state, the server transaction MUST pass the final response to the transport
          // layer for retransmission whenever a retransmission of the request is received. Any other final responses
          // passed by the TU to the server transaction MUST be discarded while in the "Completed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          if (!this.lastResponse) {
            throw new Error("Last response undefined.");
          }

          this.send(this.lastResponse).catch(function (error) {
            _this.logTransportError(error, "Failed to send retransmission of final response.");
          });
          break;

        case _transactionState.TransactionState.Terminated:
          break;

        default:
          throw new Error("Invalid state ".concat(this.state));
      }
    }
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.
     * @param response - Response to send.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(statusCode, response) {
      var _this2 = this;

      if (statusCode < 100 || statusCode > 699) {
        throw new Error("Invalid status code ".concat(statusCode));
      } // An SIP element MUST NOT send any provisional response with a
      // Status-Code other than 100 to a non-INVITE request.
      // An SIP element MUST NOT respond to a non-INVITE request with a
      // Status-Code of 100 over any unreliable transport, such as UDP,
      // before the amount of time it takes a client transaction's Timer E to be reset to T2.
      // An SIP element MAY respond to a non-INVITE request with a
      // Status-Code of 100 over a reliable transport at any time.
      // https://tools.ietf.org/html/rfc4320#section-4.1


      if (statusCode > 100 && statusCode <= 199) {
        throw new Error("Provisional response other than 100 not allowed.");
      }

      switch (this.state) {
        case _transactionState.TransactionState.Trying:
          // While in the "Trying" state, if the TU passes a provisional response
          // to the server transaction, the server transaction MUST enter the "Proceeding" state.
          // The response MUST be passed to the transport layer for transmission.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          this.lastResponse = response;

          if (statusCode >= 100 && statusCode < 200) {
            this.stateTransition(_transactionState.TransactionState.Proceeding);
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send provisional response.");
            });
            return;
          }

          if (statusCode >= 200 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send final response.");
            });
            return;
          }

          break;

        case _transactionState.TransactionState.Proceeding:
          // Any further provisional responses that are received from the TU while
          // in the "Proceeding" state MUST be passed to the transport layer for transmission.
          // If the TU passes a final response (status codes 200-699) to the server while in
          // the "Proceeding" state, the transaction MUST enter the "Completed" state, and
          // the response MUST be passed to the transport layer for transmission.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          this.lastResponse = response;

          if (statusCode >= 200 && statusCode <= 699) {
            this.stateTransition(_transactionState.TransactionState.Completed);
            this.send(response).catch(function (error) {
              _this2.logTransportError(error, "Failed to send final response.");
            });
            return;
          }

          break;

        case _transactionState.TransactionState.Completed:
          // Any other final responses passed by the TU to the server
          // transaction MUST be discarded while in the "Completed" state.
          // https://tools.ietf.org/html/rfc3261#section-17.2.2
          return;

        case _transactionState.TransactionState.Terminated:
          break;

        default:
          throw new Error("Invalid state ".concat(this.state));
      }

      var message = "Non-INVITE server transaction received unexpected ".concat(statusCode, " response from TU while in state ").concat(this.state, ".");
      this.logger.error(message);
      throw new Error(message);
    }
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.4
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      if (this.user.onTransportError) {
        this.user.onTransportError(error);
      }

      this.stateTransition(_transactionState.TransactionState.Terminated, true);
    }
    /** For logging. */

  }, {
    key: "typeToString",
    value: function typeToString() {
      return "non-INVITE server transaction";
    }
  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this3 = this;

      var dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Assert valid state transitions.
      var invalidStateTransition = function invalidStateTransition() {
        throw new Error("Invalid state transition from ".concat(_this3.state, " to ").concat(newState));
      };

      switch (newState) {
        case _transactionState.TransactionState.Trying:
          invalidStateTransition();
          break;

        case _transactionState.TransactionState.Proceeding:
          if (this.state !== _transactionState.TransactionState.Trying) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Completed:
          if (this.state !== _transactionState.TransactionState.Trying && this.state !== _transactionState.TransactionState.Proceeding) {
            invalidStateTransition();
          }

          break;

        case _transactionState.TransactionState.Terminated:
          if (this.state !== _transactionState.TransactionState.Proceeding && this.state !== _transactionState.TransactionState.Completed) {
            if (!dueToTransportError) {
              invalidStateTransition();
            }
          }

          break;

        default:
          invalidStateTransition();
      } // When the server transaction enters the "Completed" state, it MUST set Timer J to fire
      // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.
      // https://tools.ietf.org/html/rfc3261#section-17.2.2


      if (newState === _transactionState.TransactionState.Completed) {
        this.J = setTimeout(function () {
          return _this3.timerJ();
        }, _timers.Timers.TIMER_J);
      } // The server transaction MUST be destroyed the instant it enters the "Terminated" state.
      // https://tools.ietf.org/html/rfc3261#section-17.2.2


      if (newState === _transactionState.TransactionState.Terminated) {
        this.dispose();
      }

      this.setState(newState);
    }
    /**
     * The server transaction remains in this state until Timer J fires,
     * at which point it MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     */

  }, {
    key: "timerJ",
    value: function timerJ() {
      this.logger.debug("Timer J expired for NON-INVITE server transaction ".concat(this.id, "."));

      if (this.state === _transactionState.TransactionState.Completed) {
        this.stateTransition(_transactionState.TransactionState.Terminated);
      }
    }
  }]);

  return NonInviteServerTransaction;
}(_serverTransaction.ServerTransaction);

exports.NonInviteServerTransaction = NonInviteServerTransaction;
},{"../timers":"node_modules/sip.js/lib/core/timers.js","./server-transaction":"node_modules/sip.js/lib/core/transactions/server-transaction.js","./transaction-state":"node_modules/sip.js/lib/core/transactions/transaction-state.js"}],"node_modules/sip.js/lib/core/transactions/transaction-user.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/transactions/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _clientTransaction = require("./client-transaction");

Object.keys(_clientTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _clientTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _clientTransaction[key];
    }
  });
});

var _inviteClientTransaction = require("./invite-client-transaction");

Object.keys(_inviteClientTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviteClientTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviteClientTransaction[key];
    }
  });
});

var _inviteServerTransaction = require("./invite-server-transaction");

Object.keys(_inviteServerTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviteServerTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviteServerTransaction[key];
    }
  });
});

var _nonInviteClientTransaction = require("./non-invite-client-transaction");

Object.keys(_nonInviteClientTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nonInviteClientTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nonInviteClientTransaction[key];
    }
  });
});

var _nonInviteServerTransaction = require("./non-invite-server-transaction");

Object.keys(_nonInviteServerTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nonInviteServerTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nonInviteServerTransaction[key];
    }
  });
});

var _serverTransaction = require("./server-transaction");

Object.keys(_serverTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _serverTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _serverTransaction[key];
    }
  });
});

var _transactionState = require("./transaction-state");

Object.keys(_transactionState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactionState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transactionState[key];
    }
  });
});

var _transactionUser = require("./transaction-user");

Object.keys(_transactionUser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactionUser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transactionUser[key];
    }
  });
});

var _transaction = require("./transaction");

Object.keys(_transaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transaction[key];
    }
  });
});
},{"./client-transaction":"node_modules/sip.js/lib/core/transactions/client-transaction.js","./invite-client-transaction":"node_modules/sip.js/lib/core/transactions/invite-client-transaction.js","./invite-server-transaction":"node_modules/sip.js/lib/core/transactions/invite-server-transaction.js","./non-invite-client-transaction":"node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js","./non-invite-server-transaction":"node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js","./server-transaction":"node_modules/sip.js/lib/core/transactions/server-transaction.js","./transaction-state":"node_modules/sip.js/lib/core/transactions/transaction-state.js","./transaction-user":"node_modules/sip.js/lib/core/transactions/transaction-user.js","./transaction":"node_modules/sip.js/lib/core/transactions/transaction.js"}],"node_modules/sip.js/lib/core/user-agents/user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * User Agent Client (UAC).
 * @remarks
 * A user agent client is a logical entity
 * that creates a new request, and then uses the client
 * transaction state machinery to send it.  The role of UAC lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software initiates a request, it acts as a UAC for
 * the duration of that transaction.  If it receives a request
 * later, it assumes the role of a user agent server for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentClient = /*#__PURE__*/function () {
  function UserAgentClient(transactionConstructor, core, message, delegate) {
    _classCallCheck(this, UserAgentClient);

    this.transactionConstructor = transactionConstructor;
    this.core = core;
    this.message = message;
    this.delegate = delegate;
    this.challenged = false;
    this.stale = false;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
    this.init();
  }

  _createClass(UserAgentClient, [{
    key: "dispose",
    value: function dispose() {
      this.transaction.dispose();
    }
  }, {
    key: "loggerFactory",
    get: function get() {
      return this.core.loggerFactory;
    }
    /** The transaction associated with this request. */

  }, {
    key: "transaction",
    get: function get() {
      if (!this._transaction) {
        throw new Error("Transaction undefined.");
      }

      return this._transaction;
    }
    /**
     * Since requests other than INVITE are responded to immediately, sending a
     * CANCEL for a non-INVITE request would always create a race condition.
     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
     * https://tools.ietf.org/html/rfc3261#section-9.1
     * @param options - Cancel options bucket.
     */

  }, {
    key: "cancel",
    value: function cancel(reason) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.transaction) {
        throw new Error("Transaction undefined.");
      }

      if (!this.message.to) {
        throw new Error("To undefined.");
      }

      if (!this.message.from) {
        throw new Error("From undefined.");
      } // The following procedures are used to construct a CANCEL request.  The
      // Request-URI, Call-ID, To, the numeric part of CSeq, and From header
      // fields in the CANCEL request MUST be identical to those in the
      // request being cancelled, including tags.  A CANCEL constructed by a
      // client MUST have only a single Via header field value matching the
      // top Via value in the request being cancelled.  Using the same values
      // for these header fields allows the CANCEL to be matched with the
      // request it cancels (Section 9.2 indicates how such matching occurs).
      // However, the method part of the CSeq header field MUST have a value
      // of CANCEL.  This allows it to be identified and processed as a
      // transaction in its own right (See Section 17).
      // https://tools.ietf.org/html/rfc3261#section-9.1


      var message = this.core.makeOutgoingRequestMessage(_messages.C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
        toTag: this.message.toTag,
        fromTag: this.message.fromTag,
        callId: this.message.callId,
        cseq: this.message.cseq
      }, options.extraHeaders); // TODO: Revisit this.
      // The CANCEL needs to use the same branch parameter so that
      // it matches the INVITE transaction, but this is a hacky way to do this.
      // Or at the very least not well documented. If the the branch parameter
      // is set on the outgoing request, the transaction will use it.
      // Otherwise the transaction will make a new one.

      message.branch = this.message.branch;

      if (this.message.headers.Route) {
        message.headers.Route = this.message.headers.Route;
      }

      if (reason) {
        message.setHeader("Reason", reason);
      } // If no provisional response has been received, the CANCEL request MUST
      // NOT be sent; rather, the client MUST wait for the arrival of a
      // provisional response before sending the request. If the original
      // request has generated a final response, the CANCEL SHOULD NOT be
      // sent, as it is an effective no-op, since CANCEL has no effect on
      // requests that have already generated a final response.
      // https://tools.ietf.org/html/rfc3261#section-9.1


      if (this.transaction.state === _transactions.TransactionState.Proceeding) {
        new UserAgentClient(_transactions.NonInviteClientTransaction, this.core, message);
      } else {
        this.transaction.addStateChangeListener(function () {
          if (_this.transaction && _this.transaction.state === _transactions.TransactionState.Proceeding) {
            new UserAgentClient(_transactions.NonInviteClientTransaction, _this.core, message);
          }
        }, {
          once: true
        });
      }

      return message;
    }
    /**
     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
     * response is received, the UAC SHOULD follow the authorization
     * procedures of Section 22.2 and Section 22.3 to retry the request with
     * credentials.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
     * 22 Usage of HTTP Authentication
     * https://tools.ietf.org/html/rfc3261#section-22
     * 22.1 Framework
     * https://tools.ietf.org/html/rfc3261#section-22.1
     * 22.2 User-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.2
     * 22.3 Proxy-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.3
     *
     * FIXME: This "guard for and retry the request with credentials"
     * implementation is not complete and at best minimally passable.
     * @param response - The incoming response to guard.
     * @param dialog - If defined, the dialog within which the response was received.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise the request is retried with credentials and current request processing must stop.
     */

  }, {
    key: "authenticationGuard",
    value: function authenticationGuard(message, dialog) {
      var statusCode = message.statusCode;

      if (!statusCode) {
        throw new Error("Response status code undefined.");
      } // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
      // response is received, the UAC SHOULD follow the authorization
      // procedures of Section 22.2 and Section 22.3 to retry the request with
      // credentials.
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.5


      if (statusCode !== 401 && statusCode !== 407) {
        return true;
      } // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any


      var challenge;
      var authorizationHeaderName;

      if (statusCode === 401) {
        challenge = message.parseHeader("www-authenticate");
        authorizationHeaderName = "authorization";
      } else {
        challenge = message.parseHeader("proxy-authenticate");
        authorizationHeaderName = "proxy-authorization";
      } // Verify it seems a valid challenge.


      if (!challenge) {
        this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
        return true;
      } // Avoid infinite authentications.


      if (this.challenged && (this.stale || challenge.stale !== true)) {
        this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
        return true;
      } // Get credentials.


      if (!this.credentials) {
        this.credentials = this.core.configuration.authenticationFactory();

        if (!this.credentials) {
          this.logger.warn("Unable to obtain credentials, cannot authenticate");
          return true;
        }
      } // Verify that the challenge is really valid.


      if (!this.credentials.authenticate(this.message, challenge)) {
        return true;
      }

      this.challenged = true;

      if (challenge.stale) {
        this.stale = true;
      } // If response to out of dialog request, assume incrementing the CSeq will suffice.


      var cseq = this.message.cseq += 1; // If response to in dialog request, get a valid next CSeq number.

      if (dialog && dialog.localSequenceNumber) {
        dialog.incrementLocalSequenceNumber();
        cseq = this.message.cseq = dialog.localSequenceNumber;
      }

      this.message.setHeader("cseq", cseq + " " + this.message.method);
      this.message.setHeader(authorizationHeaderName, this.credentials.toString()); // Calling init (again) will swap out our existing client transaction with a new one.
      // FIXME: HACK: An assumption is being made here that there is nothing that needs to
      // be cleaned up beyond the client transaction which is being replaced. For example,
      // it is assumed that no early dialogs have been created.

      this.init();
      return false;
    }
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     */

  }, {
    key: "onRequestTimeout",
    value: function onRequestTimeout() {
      this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
      var message = new _messages.IncomingResponseMessage();
      message.statusCode = 408;
      message.reasonPhrase = "Request Timeout";
      this.receiveResponse(message);
      return;
    }
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     * @param error - Transport error
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      this.logger.error(error.message);
      this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
      var message = new _messages.IncomingResponseMessage();
      message.statusCode = 503;
      message.reasonPhrase = "Service Unavailable";
      this.receiveResponse(message);
    }
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(message) {
      if (!this.authenticationGuard(message)) {
        return;
      }

      var statusCode = message.statusCode ? message.statusCode.toString() : "";

      if (!statusCode) {
        throw new Error("Response status code undefined.");
      }

      switch (true) {
        case /^100$/.test(statusCode):
          if (this.delegate && this.delegate.onTrying) {
            this.delegate.onTrying({
              message: message
            });
          }

          break;

        case /^1[0-9]{2}$/.test(statusCode):
          if (this.delegate && this.delegate.onProgress) {
            this.delegate.onProgress({
              message: message
            });
          }

          break;

        case /^2[0-9]{2}$/.test(statusCode):
          if (this.delegate && this.delegate.onAccept) {
            this.delegate.onAccept({
              message: message
            });
          }

          break;

        case /^3[0-9]{2}$/.test(statusCode):
          if (this.delegate && this.delegate.onRedirect) {
            this.delegate.onRedirect({
              message: message
            });
          }

          break;

        case /^[4-6][0-9]{2}$/.test(statusCode):
          if (this.delegate && this.delegate.onReject) {
            this.delegate.onReject({
              message: message
            });
          }

          break;

        default:
          throw new Error("Invalid status code ".concat(statusCode));
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this2 = this;

      // We are the transaction user.
      var user = {
        loggerFactory: this.loggerFactory,
        onRequestTimeout: function onRequestTimeout() {
          return _this2.onRequestTimeout();
        },
        onStateChange: function onStateChange(newState) {
          if (newState === _transactions.TransactionState.Terminated) {
            // Remove the terminated transaction from the core.
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            _this2.core.userAgentClients.delete(userAgentClientId); // FIXME: HACK: Our transaction may have been swapped out with a new one
            // post authentication (see above), so make sure to only to dispose of
            // ourselves if this terminating transaction is our current transaction.
            // eslint-disable-next-line @typescript-eslint/no-use-before-define


            if (transaction === _this2._transaction) {
              _this2.dispose();
            }
          }
        },
        onTransportError: function onTransportError(error) {
          return _this2.onTransportError(error);
        },
        receiveResponse: function receiveResponse(message) {
          return _this2.receiveResponse(message);
        }
      }; // Create a new transaction with us as the user.

      var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
      this._transaction = transaction; // Add the new transaction to the core.

      var userAgentClientId = transaction.id + transaction.request.method;
      this.core.userAgentClients.set(userAgentClientId, this);
    }
  }]);

  return UserAgentClient;
}();

exports.UserAgentClient = UserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js"}],"node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ByeUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * BYE UAC.
 * @public
 */
var ByeUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(ByeUserAgentClient, _UserAgentClient);

  var _super = _createSuper(ByeUserAgentClient);

  function ByeUserAgentClient(dialog, delegate, options) {
    var _this;

    _classCallCheck(this, ByeUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.BYE, options);
    _this = _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
    dialog.dispose();
    return _this;
  }

  return _createClass(ByeUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.ByeUserAgentClient = ByeUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgentServer = void 0;

var _exceptions = require("../exceptions");

var _messages = require("../messages");

var _utils = require("../messages/utils");

var _transactions = require("../transactions");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * User Agent Server (UAS).
 * @remarks
 * A user agent server is a logical entity
 * that generates a response to a SIP request.  The response
 * accepts, rejects, or redirects the request.  This role lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software responds to a request, it acts as a UAS for
 * the duration of that transaction.  If it generates a request
 * later, it assumes the role of a user agent client for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentServer = /*#__PURE__*/function () {
  function UserAgentServer(transactionConstructor, core, message, delegate) {
    _classCallCheck(this, UserAgentServer);

    this.transactionConstructor = transactionConstructor;
    this.core = core;
    this.message = message;
    this.delegate = delegate;
    this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
    this.toTag = message.toTag ? message.toTag : (0, _utils.newTag)();
    this.init();
  }

  _createClass(UserAgentServer, [{
    key: "dispose",
    value: function dispose() {
      this.transaction.dispose();
    }
  }, {
    key: "loggerFactory",
    get: function get() {
      return this.core.loggerFactory;
    }
    /** The transaction associated with this request. */

  }, {
    key: "transaction",
    get: function get() {
      if (!this._transaction) {
        throw new Error("Transaction undefined.");
      }

      return this._transaction;
    }
  }, {
    key: "accept",
    value: function accept() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 200
      };

      if (!this.acceptable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not acceptable in state ").concat(this.transaction.state, "."));
      }

      var statusCode = options.statusCode;

      if (statusCode < 200 || statusCode > 299) {
        throw new TypeError("Invalid statusCode: ".concat(statusCode));
      }

      var response = this.reply(options);
      return response;
    }
  }, {
    key: "progress",
    value: function progress() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 180
      };

      if (!this.progressable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not progressable in state ").concat(this.transaction.state, "."));
      }

      var statusCode = options.statusCode;

      if (statusCode < 101 || statusCode > 199) {
        throw new TypeError("Invalid statusCode: ".concat(statusCode));
      }

      var response = this.reply(options);
      return response;
    }
  }, {
    key: "redirect",
    value: function redirect(contacts) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        statusCode: 302
      };

      if (!this.redirectable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not redirectable in state ").concat(this.transaction.state, "."));
      }

      var statusCode = options.statusCode;

      if (statusCode < 300 || statusCode > 399) {
        throw new TypeError("Invalid statusCode: ".concat(statusCode));
      }

      var contactHeaders = new Array();
      contacts.forEach(function (contact) {
        return contactHeaders.push("Contact: ".concat(contact.toString()));
      });
      options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
      var response = this.reply(options);
      return response;
    }
  }, {
    key: "reject",
    value: function reject() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 480
      };

      if (!this.rejectable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not rejectable in state ").concat(this.transaction.state, "."));
      }

      var statusCode = options.statusCode;

      if (statusCode < 400 || statusCode > 699) {
        throw new TypeError("Invalid statusCode: ".concat(statusCode));
      }

      var response = this.reply(options);
      return response;
    } // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "trying",
    value: function trying(options) {
      if (!this.tryingable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not tryingable in state ").concat(this.transaction.state, "."));
      }

      var response = this.reply({
        statusCode: 100
      });
      return response;
    }
    /**
     * If the UAS did not find a matching transaction for the CANCEL
     * according to the procedure above, it SHOULD respond to the CANCEL
     * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
     * for the original request still exists, the behavior of the UAS on
     * receiving a CANCEL request depends on whether it has already sent a
     * final response for the original request.  If it has, the CANCEL
     * request has no effect on the processing of the original request, no
     * effect on any session state, and no effect on the responses generated
     * for the original request.  If the UAS has not issued a final response
     * for the original request, its behavior depends on the method of the
     * original request.  If the original request was an INVITE, the UAS
     * SHOULD immediately respond to the INVITE with a 487 (Request
     * Terminated).  A CANCEL request has no impact on the processing of
     * transactions with any other method defined in this specification.
     * https://tools.ietf.org/html/rfc3261#section-9.2
     * @param request - Incoming CANCEL request.
     */

  }, {
    key: "receiveCancel",
    value: function receiveCancel(message) {
      // Note: Currently CANCEL is being handled as a special case.
      // No UAS is created to handle the CANCEL and the response to
      // it CANCEL is being handled statelessly by the user agent core.
      // As such, there is currently no way to externally impact the
      // response to the a CANCEL request.
      if (this.delegate && this.delegate.onCancel) {
        this.delegate.onCancel(message);
      }
    }
  }, {
    key: "acceptable",
    get: function get() {
      if (this.transaction instanceof _transactions.InviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Proceeding || this.transaction.state === _transactions.TransactionState.Accepted;
      }

      if (this.transaction instanceof _transactions.NonInviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Trying || this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      throw new Error("Unknown transaction type.");
    }
  }, {
    key: "progressable",
    get: function get() {
      if (this.transaction instanceof _transactions.InviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      if (this.transaction instanceof _transactions.NonInviteServerTransaction) {
        return false; // https://tools.ietf.org/html/rfc4320#section-4.1
      }

      throw new Error("Unknown transaction type.");
    }
  }, {
    key: "redirectable",
    get: function get() {
      if (this.transaction instanceof _transactions.InviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      if (this.transaction instanceof _transactions.NonInviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Trying || this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      throw new Error("Unknown transaction type.");
    }
  }, {
    key: "rejectable",
    get: function get() {
      if (this.transaction instanceof _transactions.InviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      if (this.transaction instanceof _transactions.NonInviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Trying || this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      throw new Error("Unknown transaction type.");
    }
  }, {
    key: "tryingable",
    get: function get() {
      if (this.transaction instanceof _transactions.InviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Proceeding;
      }

      if (this.transaction instanceof _transactions.NonInviteServerTransaction) {
        return this.transaction.state === _transactions.TransactionState.Trying;
      }

      throw new Error("Unknown transaction type.");
    }
    /**
     * When a UAS wishes to construct a response to a request, it follows
     * the general procedures detailed in the following subsections.
     * Additional behaviors specific to the response code in question, which
     * are not detailed in this section, may also be required.
     *
     * Once all procedures associated with the creation of a response have
     * been completed, the UAS hands the response back to the server
     * transaction from which it received the request.
     * https://tools.ietf.org/html/rfc3261#section-8.2.6
     * @param statusCode - Status code to reply with.
     * @param options - Reply options bucket.
     */

  }, {
    key: "reply",
    value: function reply(options) {
      if (!options.toTag && options.statusCode !== 100) {
        options.toTag = this.toTag;
      }

      options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
      options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
      var response = (0, _messages.constructOutgoingResponse)(this.message, options);
      this.transaction.receiveResponse(options.statusCode, response.message);
      return response;
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;

      // We are the transaction user.
      var user = {
        loggerFactory: this.loggerFactory,
        onStateChange: function onStateChange(newState) {
          if (newState === _transactions.TransactionState.Terminated) {
            // Remove the terminated transaction from the core.
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            _this.core.userAgentServers.delete(userAgentServerId);

            _this.dispose();
          }
        },
        onTransportError: function onTransportError(error) {
          _this.logger.error(error.message);

          if (_this.delegate && _this.delegate.onTransportError) {
            _this.delegate.onTransportError(error);
          } else {
            _this.logger.error("User agent server response transport error.");
          }
        }
      }; // Create a new transaction with us as the user.

      var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
      this._transaction = transaction; // Add the new transaction to the core.

      var userAgentServerId = transaction.id;
      this.core.userAgentServers.set(transaction.id, this);
    }
  }]);

  return UserAgentServer;
}();

exports.UserAgentServer = UserAgentServer;
},{"../exceptions":"node_modules/sip.js/lib/core/exceptions/index.js","../messages":"node_modules/sip.js/lib/core/messages/index.js","../messages/utils":"node_modules/sip.js/lib/core/messages/utils.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js"}],"node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ByeUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * BYE UAS.
 * @public
 */
var ByeUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(ByeUserAgentServer, _UserAgentServer);

  var _super = _createSuper(ByeUserAgentServer);

  function ByeUserAgentServer(dialog, message, delegate) {
    _classCallCheck(this, ByeUserAgentServer);

    return _super.call(this, _transactions.NonInviteServerTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(ByeUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.ByeUserAgentServer = ByeUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INFO UAC.
 * @public
 */
var InfoUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(InfoUserAgentClient, _UserAgentClient);

  var _super = _createSuper(InfoUserAgentClient);

  function InfoUserAgentClient(dialog, delegate, options) {
    _classCallCheck(this, InfoUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.INFO, options);
    return _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(InfoUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.InfoUserAgentClient = InfoUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INFO UAS.
 * @public
 */
var InfoUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(InfoUserAgentServer, _UserAgentServer);

  var _super = _createSuper(InfoUserAgentServer);

  function InfoUserAgentServer(dialog, message, delegate) {
    _classCallCheck(this, InfoUserAgentServer);

    return _super.call(this, _transactions.NonInviteServerTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(InfoUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.InfoUserAgentServer = InfoUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageUserAgentClient = void 0;

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * MESSAGE UAC.
 * @public
 */
var MessageUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(MessageUserAgentClient, _UserAgentClient);

  var _super = _createSuper(MessageUserAgentClient);

  function MessageUserAgentClient(core, message, delegate) {
    _classCallCheck(this, MessageUserAgentClient);

    return _super.call(this, _transactions.NonInviteClientTransaction, core, message, delegate);
  }

  return _createClass(MessageUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.MessageUserAgentClient = MessageUserAgentClient;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * MESSAGE UAS.
 * @public
 */
var MessageUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(MessageUserAgentServer, _UserAgentServer);

  var _super = _createSuper(MessageUserAgentServer);

  function MessageUserAgentServer(core, message, delegate) {
    _classCallCheck(this, MessageUserAgentServer);

    return _super.call(this, _transactions.NonInviteServerTransaction, core, message, delegate);
  }

  return _createClass(MessageUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.MessageUserAgentServer = MessageUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotifyUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * NOTIFY UAS.
 * @public
 */
var NotifyUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(NotifyUserAgentClient, _UserAgentClient);

  var _super = _createSuper(NotifyUserAgentClient);

  function NotifyUserAgentClient(dialog, delegate, options) {
    _classCallCheck(this, NotifyUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.NOTIFY, options);
    return _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(NotifyUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.NotifyUserAgentClient = NotifyUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotifyUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfDialog(object) {
  return object.userAgentCore !== undefined;
}
/**
 * NOTIFY UAS.
 * @public
 */


var NotifyUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(NotifyUserAgentServer, _UserAgentServer);

  var _super = _createSuper(NotifyUserAgentServer);

  /**
   * NOTIFY UAS constructor.
   * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
   * @param message - Incoming NOTIFY request message.
   */
  function NotifyUserAgentServer(dialogOrCore, message, delegate) {
    _classCallCheck(this, NotifyUserAgentServer);

    var userAgentCore = instanceOfDialog(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    return _super.call(this, _transactions.NonInviteServerTransaction, userAgentCore, message, delegate);
  }

  return _createClass(NotifyUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.NotifyUserAgentServer = NotifyUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrackUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * PRACK UAC.
 * @public
 */
var PrackUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(PrackUserAgentClient, _UserAgentClient);

  var _super = _createSuper(PrackUserAgentClient);

  function PrackUserAgentClient(dialog, delegate, options) {
    var _this;

    _classCallCheck(this, PrackUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.PRACK, options);
    _this = _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
    dialog.signalingStateTransition(message);
    return _this;
  }

  return _createClass(PrackUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.PrackUserAgentClient = PrackUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrackUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * PRACK UAS.
 * @public
 */
var PrackUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(PrackUserAgentServer, _UserAgentServer);

  var _super = _createSuper(PrackUserAgentServer);

  function PrackUserAgentServer(dialog, message, delegate) {
    var _this;

    _classCallCheck(this, PrackUserAgentServer);

    _this = _super.call(this, _transactions.NonInviteServerTransaction, dialog.userAgentCore, message, delegate); // Update dialog signaling state with offer/answer in body

    dialog.signalingStateTransition(message);
    _this.dialog = dialog;
    return _this;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */


  _createClass(PrackUserAgentServer, [{
    key: "accept",
    value: function accept() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 200
      };

      if (options.body) {
        // Update dialog signaling state with offer/answer in body
        this.dialog.signalingStateTransition(options.body);
      }

      return _get(_getPrototypeOf(PrackUserAgentServer.prototype), "accept", this).call(this, options);
    }
  }]);

  return PrackUserAgentServer;
}(_userAgentServer.UserAgentServer);

exports.PrackUserAgentServer = PrackUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReInviteUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Re-INVITE UAC.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.1 UAC Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.1
 * @public
 */
var ReInviteUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(ReInviteUserAgentClient, _UserAgentClient);

  var _super = _createSuper(ReInviteUserAgentClient);

  function ReInviteUserAgentClient(dialog, delegate, options) {
    var _this;

    _classCallCheck(this, ReInviteUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.INVITE, options);
    _this = _super.call(this, _transactions.InviteClientTransaction, dialog.userAgentCore, message, delegate);
    _this.delegate = delegate;
    dialog.signalingStateTransition(message); // FIXME: TODO: next line obviously needs to be improved...

    dialog.reinviteUserAgentClient = _assertThisInitialized(_this); // let the dialog know re-invite request sent

    _this.dialog = dialog;
    return _this;
  }

  _createClass(ReInviteUserAgentClient, [{
    key: "receiveResponse",
    value: function receiveResponse(message) {
      var _this2 = this;

      if (!this.authenticationGuard(message, this.dialog)) {
        return;
      }

      var statusCode = message.statusCode ? message.statusCode.toString() : "";

      if (!statusCode) {
        throw new Error("Response status code undefined.");
      }

      switch (true) {
        case /^100$/.test(statusCode):
          if (this.delegate && this.delegate.onTrying) {
            this.delegate.onTrying({
              message: message
            });
          }

          break;

        case /^1[0-9]{2}$/.test(statusCode):
          if (this.delegate && this.delegate.onProgress) {
            this.delegate.onProgress({
              message: message,
              session: this.dialog,
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              prack: function prack(options) {
                throw new Error("Unimplemented.");
              }
            });
          }

          break;

        case /^2[0-9]{2}$/.test(statusCode):
          // Update dialog signaling state with offer/answer in body
          this.dialog.signalingStateTransition(message);

          if (this.delegate && this.delegate.onAccept) {
            this.delegate.onAccept({
              message: message,
              session: this.dialog,
              ack: function ack(options) {
                var outgoingAckRequest = _this2.dialog.ack(options);

                return outgoingAckRequest;
              }
            });
          }

          break;

        case /^3[0-9]{2}$/.test(statusCode):
          this.dialog.signalingStateRollback();
          this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction

          if (this.delegate && this.delegate.onRedirect) {
            this.delegate.onRedirect({
              message: message
            });
          }

          break;

        case /^[4-6][0-9]{2}$/.test(statusCode):
          this.dialog.signalingStateRollback();
          this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction

          if (this.delegate && this.delegate.onReject) {
            this.delegate.onReject({
              message: message
            });
          } else {// If a UA receives a non-2xx final response to a re-INVITE, the session
            // parameters MUST remain unchanged, as if no re-INVITE had been issued.
            // Note that, as stated in Section 12.2.1.2, if the non-2xx final
            // response is a 481 (Call/Transaction Does Not Exist), or a 408
            // (Request Timeout), or no response at all is received for the re-
            // INVITE (that is, a timeout is returned by the INVITE client
            // transaction), the UAC will terminate the dialog.
            //
            // If a UAC receives a 491 response to a re-INVITE, it SHOULD start a
            // timer with a value T chosen as follows:
            //
            //    1. If the UAC is the owner of the Call-ID of the dialog ID
            //       (meaning it generated the value), T has a randomly chosen value
            //       between 2.1 and 4 seconds in units of 10 ms.
            //
            //    2. If the UAC is not the owner of the Call-ID of the dialog ID, T
            //       has a randomly chosen value of between 0 and 2 seconds in units
            //       of 10 ms.
            //
            // When the timer fires, the UAC SHOULD attempt the re-INVITE once more,
            // if it still desires for that session modification to take place.  For
            // example, if the call was already hung up with a BYE, the re-INVITE
            // would not take place.
            // https://tools.ietf.org/html/rfc3261#section-14.1
            // FIXME: TODO: The above.
          }

          break;

        default:
          throw new Error("Invalid status code ".concat(statusCode));
      }
    }
  }]);

  return ReInviteUserAgentClient;
}(_userAgentClient.UserAgentClient);

exports.ReInviteUserAgentClient = ReInviteUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReInviteUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Re-INVITE UAS.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.2 UAS Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.2
 * @public
 */
var ReInviteUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(ReInviteUserAgentServer, _UserAgentServer);

  var _super = _createSuper(ReInviteUserAgentServer);

  function ReInviteUserAgentServer(dialog, message, delegate) {
    var _this;

    _classCallCheck(this, ReInviteUserAgentServer);

    _this = _super.call(this, _transactions.InviteServerTransaction, dialog.userAgentCore, message, delegate);
    dialog.reinviteUserAgentServer = _assertThisInitialized(_this);
    _this.dialog = dialog;
    return _this;
  }
  /**
   * Update the dialog signaling state on a 2xx response.
   * @param options - Options bucket.
   */


  _createClass(ReInviteUserAgentServer, [{
    key: "accept",
    value: function accept() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 200
      };
      // FIXME: The next two lines SHOULD go away, but I suppose it's technically harmless...
      // These are here because some versions of SIP.js prior to 0.13.8 set the route set
      // of all in dialog ACKs based on the Record-Route headers in the associated 2xx
      // response. While this worked for dialog forming 2xx responses, it was technically
      // broken for re-INVITE ACKS as it only worked if the UAS populated the Record-Route
      // headers in the re-INVITE 2xx response (which is not required and a waste of bandwidth
      // as the should be ignored if present in re-INVITE ACKS) and the UAS populated
      // the Record-Route headers with the correct values (would be weird not too, but...).
      // Anyway, for now the technically useless Record-Route headers are being added
      // to maintain "backwards compatibility" with the older broken versions of SIP.js.
      options.extraHeaders = options.extraHeaders || [];
      options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map(function (route) {
        return "Record-Route: ".concat(route);
      })); // Send and return the response

      var response = _get(_getPrototypeOf(ReInviteUserAgentServer.prototype), "accept", this).call(this, options);

      var session = this.dialog;
      var result = Object.assign(Object.assign({}, response), {
        session: session
      });

      if (options.body) {
        // Update dialog signaling state with offer/answer in body
        this.dialog.signalingStateTransition(options.body);
      } // Update dialog


      this.dialog.reConfirm();
      return result;
    }
    /**
     * Update the dialog signaling state on a 1xx response.
     * @param options - Progress options bucket.
     */

  }, {
    key: "progress",
    value: function progress() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 180
      };

      // Send and return the response
      var response = _get(_getPrototypeOf(ReInviteUserAgentServer.prototype), "progress", this).call(this, options);

      var session = this.dialog;
      var result = Object.assign(Object.assign({}, response), {
        session: session
      }); // Update dialog signaling state

      if (options.body) {
        this.dialog.signalingStateTransition(options.body);
      }

      return result;
    }
    /**
     * TODO: Not Yet Supported
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "redirect",
    value: function redirect(contacts) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        statusCode: 302
      };
      this.dialog.signalingStateRollback();
      this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction

      throw new Error("Unimplemented.");
    }
    /**
     * 3.1 Background on Re-INVITE Handling by UASs
     * An error response to a re-INVITE has the following semantics.  As
     * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
     * rejected, no state changes are performed.
     * https://tools.ietf.org/html/rfc6141#section-3.1
     * @param options - Reject options bucket.
     */

  }, {
    key: "reject",
    value: function reject() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 488
      };
      this.dialog.signalingStateRollback();
      this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction

      return _get(_getPrototypeOf(ReInviteUserAgentServer.prototype), "reject", this).call(this, options);
    }
  }]);

  return ReInviteUserAgentServer;
}(_userAgentServer.UserAgentServer);

exports.ReInviteUserAgentServer = ReInviteUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * REFER UAC.
 * @public
 */
var ReferUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(ReferUserAgentClient, _UserAgentClient);

  var _super = _createSuper(ReferUserAgentClient);

  function ReferUserAgentClient(dialog, delegate, options) {
    _classCallCheck(this, ReferUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.REFER, options);
    return _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(ReferUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.ReferUserAgentClient = ReferUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfSessionDialog(object) {
  return object.userAgentCore !== undefined;
}
/**
 * REFER UAS.
 * @public
 */


var ReferUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(ReferUserAgentServer, _UserAgentServer);

  var _super = _createSuper(ReferUserAgentServer);

  /**
   * REFER UAS constructor.
   * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
   * @param message - Incoming REFER request message.
   */
  function ReferUserAgentServer(dialogOrCore, message, delegate) {
    _classCallCheck(this, ReferUserAgentServer);

    var userAgentCore = instanceOfSessionDialog(dialogOrCore) ? dialogOrCore.userAgentCore : dialogOrCore;
    return _super.call(this, _transactions.NonInviteServerTransaction, userAgentCore, message, delegate);
  }

  return _createClass(ReferUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.ReferUserAgentServer = ReferUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/dialogs/session-dialog.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionDialog = void 0;

var _messages = require("../messages");

var _session = require("../session");

var _timers = require("../timers");

var _transactions = require("../transactions");

var _byeUserAgentClient = require("../user-agents/bye-user-agent-client");

var _byeUserAgentServer = require("../user-agents/bye-user-agent-server");

var _infoUserAgentClient = require("../user-agents/info-user-agent-client");

var _infoUserAgentServer = require("../user-agents/info-user-agent-server");

var _messageUserAgentClient = require("../user-agents/message-user-agent-client");

var _messageUserAgentServer = require("../user-agents/message-user-agent-server");

var _notifyUserAgentClient = require("../user-agents/notify-user-agent-client");

var _notifyUserAgentServer = require("../user-agents/notify-user-agent-server");

var _prackUserAgentClient = require("../user-agents/prack-user-agent-client");

var _prackUserAgentServer = require("../user-agents/prack-user-agent-server");

var _reInviteUserAgentClient = require("../user-agents/re-invite-user-agent-client");

var _reInviteUserAgentServer = require("../user-agents/re-invite-user-agent-server");

var _referUserAgentClient = require("../user-agents/refer-user-agent-client");

var _referUserAgentServer = require("../user-agents/refer-user-agent-server");

var _dialog = require("./dialog");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Session Dialog.
 * @public
 */
var SessionDialog = /*#__PURE__*/function (_Dialog) {
  _inherits(SessionDialog, _Dialog);

  var _super = _createSuper(SessionDialog);

  function SessionDialog(initialTransaction, core, state, delegate) {
    var _this;

    _classCallCheck(this, SessionDialog);

    _this = _super.call(this, core, state);
    _this.initialTransaction = initialTransaction;
    /** The state of the offer/answer exchange. */

    _this._signalingState = _session.SignalingState.Initial;
    /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */

    _this.ackWait = false;
    /** True if processing an ACK to the initial transaction 2xx (UAS only). */

    _this.ackProcessing = false;
    _this.delegate = delegate;

    if (initialTransaction instanceof _transactions.InviteServerTransaction) {
      // If we're created by an invite server transaction, we're
      // going to be waiting for an ACK if are to be confirmed.
      _this.ackWait = true;
    } // If we're confirmed upon creation start the retransmitting whatever
    // the 2xx final response was that confirmed us into existence.


    if (!_this.early) {
      _this.start2xxRetransmissionTimer();
    }

    _this.signalingStateTransition(initialTransaction.request);

    _this.logger = core.loggerFactory.getLogger("sip.invite-dialog");

    _this.logger.log("INVITE dialog ".concat(_this.id, " constructed"));

    return _this;
  }

  _createClass(SessionDialog, [{
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(SessionDialog.prototype), "dispose", this).call(this);

      this._signalingState = _session.SignalingState.Closed;
      this._offer = undefined;
      this._answer = undefined;

      if (this.invite2xxTimer) {
        clearTimeout(this.invite2xxTimer);
        this.invite2xxTimer = undefined;
      } // The UAS MUST still respond to any pending requests received for that
      // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
      // be generated to those pending requests.
      // https://tools.ietf.org/html/rfc3261#section-15.1.2
      // TODO:
      // this.userAgentServers.forEach((uas) => uas.reply(487));


      this.logger.log("INVITE dialog ".concat(this.id, " destroyed"));
    } // FIXME: Need real state machine

  }, {
    key: "sessionState",
    get: function get() {
      if (this.early) {
        return _session.SessionState.Early;
      } else if (this.ackWait) {
        return _session.SessionState.AckWait;
      } else if (this._signalingState === _session.SignalingState.Closed) {
        return _session.SessionState.Terminated;
      } else {
        return _session.SessionState.Confirmed;
      }
    }
    /** The state of the offer/answer exchange. */

  }, {
    key: "signalingState",
    get: function get() {
      return this._signalingState;
    }
    /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */

  }, {
    key: "offer",
    get: function get() {
      return this._offer;
    }
    /** The current answer. Undefined unless signaling state Stable. */

  }, {
    key: "answer",
    get: function get() {
      return this._answer;
    }
    /** Confirm the dialog. Only matters if dialog is currently early. */

  }, {
    key: "confirm",
    value: function confirm() {
      // When we're confirmed start the retransmitting whatever
      // the 2xx final response that may have confirmed us.
      if (this.early) {
        this.start2xxRetransmissionTimer();
      }

      _get(_getPrototypeOf(SessionDialog.prototype), "confirm", this).call(this);
    }
    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */

  }, {
    key: "reConfirm",
    value: function reConfirm() {
      // When we're confirmed start the retransmitting whatever
      // the 2xx final response that may have confirmed us.
      if (this.reinviteUserAgentServer) {
        this.startReInvite2xxRetransmissionTimer();
      }
    }
    /**
     * The UAC core MUST generate an ACK request for each 2xx received from
     * the transaction layer.  The header fields of the ACK are constructed
     * in the same way as for any request sent within a dialog (see Section
     * 12) with the exception of the CSeq and the header fields related to
     * authentication.  The sequence number of the CSeq header field MUST be
     * the same as the INVITE being acknowledged, but the CSeq method MUST
     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
     * the 2xx contains an offer (based on the rules above), the ACK MUST
     * carry an answer in its body.  If the offer in the 2xx response is not
     * acceptable, the UAC core MUST generate a valid answer in the ACK and
     * then send a BYE immediately.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     * @param options - ACK options bucket.
     */

  }, {
    key: "ack",
    value: function ack() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("INVITE dialog ".concat(this.id, " sending ACK request"));
      var transaction;

      if (this.reinviteUserAgentClient) {
        // We're sending ACK for a re-INVITE
        if (!(this.reinviteUserAgentClient.transaction instanceof _transactions.InviteClientTransaction)) {
          throw new Error("Transaction not instance of InviteClientTransaction.");
        }

        transaction = this.reinviteUserAgentClient.transaction;
        this.reinviteUserAgentClient = undefined;
      } else {
        // We're sending ACK for the initial INVITE
        if (!(this.initialTransaction instanceof _transactions.InviteClientTransaction)) {
          throw new Error("Initial transaction not instance of InviteClientTransaction.");
        }

        transaction = this.initialTransaction;
      }

      var message = this.createOutgoingRequestMessage(_messages.C.ACK, {
        cseq: transaction.request.cseq,
        extraHeaders: options.extraHeaders,
        body: options.body
      });
      transaction.ackResponse(message); // See InviteClientTransaction for details.

      this.signalingStateTransition(message);
      return {
        message: message
      };
    }
    /**
     * Terminating a Session
     *
     * This section describes the procedures for terminating a session
     * established by SIP.  The state of the session and the state of the
     * dialog are very closely related.  When a session is initiated with an
     * INVITE, each 1xx or 2xx response from a distinct UAS creates a
     * dialog, and if that response completes the offer/answer exchange, it
     * also creates a session.  As a result, each session is "associated"
     * with a single dialog - the one which resulted in its creation.  If an
     * initial INVITE generates a non-2xx final response, that terminates
     * all sessions (if any) and all dialogs (if any) that were created
     * through responses to the request.  By virtue of completing the
     * transaction, a non-2xx final response also prevents further sessions
     * from being created as a result of the INVITE.  The BYE request is
     * used to terminate a specific session or attempted session.  In this
     * case, the specific session is the one with the peer UA on the other
     * side of the dialog.  When a BYE is received on a dialog, any session
     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
     * confirmed or early dialogs, and the callee's UA MAY send a BYE on
     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
     *
     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
     * until it has received an ACK for its 2xx response or until the server
     * transaction times out.  If no SIP extensions have defined other
     * application layer states associated with the dialog, the BYE also
     * terminates the dialog.
     *
     * https://tools.ietf.org/html/rfc3261#section-15
     * FIXME: Make these proper Exceptions...
     * @param options - BYE options bucket.
     * @returns
     * Throws `Error` if callee's UA attempts a BYE on an early dialog.
     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
     *                while it's waiting on the ACK for its 2xx response.
     */

  }, {
    key: "bye",
    value: function bye(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending BYE request")); // The caller's UA MAY send a BYE for either
      // confirmed or early dialogs, and the callee's UA MAY send a BYE on
      // confirmed dialogs, but MUST NOT send a BYE on early dialogs.
      //
      // However, the callee's UA MUST NOT send a BYE on a confirmed dialog
      // until it has received an ACK for its 2xx response or until the server
      // transaction times out.
      // https://tools.ietf.org/html/rfc3261#section-15

      if (this.initialTransaction instanceof _transactions.InviteServerTransaction) {
        if (this.early) {
          // FIXME: TODO: This should throw a proper exception.
          throw new Error("UAS MUST NOT send a BYE on early dialogs.");
        }

        if (this.ackWait && this.initialTransaction.state !== _transactions.TransactionState.Terminated) {
          // FIXME: TODO: This should throw a proper exception.
          throw new Error("UAS MUST NOT send a BYE on a confirmed dialog " + "until it has received an ACK for its 2xx response " + "or until the server transaction times out.");
        }
      } // A BYE request is constructed as would any other request within a
      // dialog, as described in Section 12.
      //
      // Once the BYE is constructed, the UAC core creates a new non-INVITE
      // client transaction, and passes it the BYE request.  The UAC MUST
      // consider the session terminated (and therefore stop sending or
      // listening for media) as soon as the BYE request is passed to the
      // client transaction.  If the response for the BYE is a 481
      // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no
      // response at all is received for the BYE (that is, a timeout is
      // returned by the client transaction), the UAC MUST consider the
      // session and the dialog terminated.
      // https://tools.ietf.org/html/rfc3261#section-15.1.1


      return new _byeUserAgentClient.ByeUserAgentClient(this, delegate, options);
    }
    /**
     * An INFO request can be associated with an Info Package (see
     * Section 5), or associated with a legacy INFO usage (see Section 2).
     *
     * The construction of the INFO request is the same as any other
     * non-target refresh request within an existing invite dialog usage as
     * described in Section 12.2 of RFC 3261.
     * https://tools.ietf.org/html/rfc6086#section-4.2.1
     * @param options - Options bucket.
     */

  }, {
    key: "info",
    value: function info(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending INFO request"));

      if (this.early) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("Dialog not confirmed.");
      }

      return new _infoUserAgentClient.InfoUserAgentClient(this, delegate, options);
    }
    /**
     * Modifying an Existing Session
     *
     * A successful INVITE request (see Section 13) establishes both a
     * dialog between two user agents and a session using the offer-answer
     * model.  Section 12 explains how to modify an existing dialog using a
     * target refresh request (for example, changing the remote target URI
     * of the dialog).  This section describes how to modify the actual
     * session.  This modification can involve changing addresses or ports,
     * adding a media stream, deleting a media stream, and so on.  This is
     * accomplished by sending a new INVITE request within the same dialog
     * that established the session.  An INVITE request sent within an
     * existing dialog is known as a re-INVITE.
     *
     *    Note that a single re-INVITE can modify the dialog and the
     *    parameters of the session at the same time.
     *
     * Either the caller or callee can modify an existing session.
     * https://tools.ietf.org/html/rfc3261#section-14
     * @param options - Options bucket
     */

  }, {
    key: "invite",
    value: function invite(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending INVITE request"));

      if (this.early) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("Dialog not confirmed.");
      } // Note that a UAC MUST NOT initiate a new INVITE transaction within a
      // dialog while another INVITE transaction is in progress in either
      // direction.
      //
      //    1. If there is an ongoing INVITE client transaction, the TU MUST
      //       wait until the transaction reaches the completed or terminated
      //       state before initiating the new INVITE.
      //
      //    2. If there is an ongoing INVITE server transaction, the TU MUST
      //       wait until the transaction reaches the confirmed or terminated
      //       state before initiating the new INVITE.
      //
      // However, a UA MAY initiate a regular transaction while an INVITE
      // transaction is in progress.  A UA MAY also initiate an INVITE
      // transaction while a regular transaction is in progress.
      // https://tools.ietf.org/html/rfc3261#section-14.1


      if (this.reinviteUserAgentClient) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("There is an ongoing re-INVITE client transaction.");
      }

      if (this.reinviteUserAgentServer) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("There is an ongoing re-INVITE server transaction.");
      }

      return new _reInviteUserAgentClient.ReInviteUserAgentClient(this, delegate, options);
    }
    /**
     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a
     * MESSAGE request is sent within a dialog, it is "associated" with any
     * media session or sessions associated with that dialog.
     * https://tools.ietf.org/html/rfc3428#section-4
     * @param options - Options bucket.
     */

  }, {
    key: "message",
    value: function message(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending MESSAGE request"));

      if (this.early) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("Dialog not confirmed.");
      }

      var message = this.createOutgoingRequestMessage(_messages.C.MESSAGE, options);
      return new _messageUserAgentClient.MessageUserAgentClient(this.core, message, delegate);
    }
    /**
     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
     * sending the REFER of the status of the reference.
     * https://tools.ietf.org/html/rfc3515#section-2.4.4
     * @param options - Options bucket.
     */

  }, {
    key: "notify",
    value: function notify(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending NOTIFY request"));

      if (this.early) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("Dialog not confirmed.");
      }

      return new _notifyUserAgentClient.NotifyUserAgentClient(this, delegate, options);
    }
    /**
     * Assuming the response is to be transmitted reliably, the UAC MUST
     * create a new request with method PRACK.  This request is sent within
     * the dialog associated with the provisional response (indeed, the
     * provisional response may have created the dialog).  PRACK requests
     * MAY contain bodies, which are interpreted according to their type and
     * disposition.
     * https://tools.ietf.org/html/rfc3262#section-4
     * @param options - Options bucket.
     */

  }, {
    key: "prack",
    value: function prack(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending PRACK request"));
      return new _prackUserAgentClient.PrackUserAgentClient(this, delegate, options);
    }
    /**
     * REFER is a SIP request and is constructed as defined in [1].  A REFER
     * request MUST contain exactly one Refer-To header field value.
     * https://tools.ietf.org/html/rfc3515#section-2.4.1
     * @param options - Options bucket.
     */

  }, {
    key: "refer",
    value: function refer(delegate, options) {
      this.logger.log("INVITE dialog ".concat(this.id, " sending REFER request"));

      if (this.early) {
        // FIXME: TODO: This should throw a proper exception.
        throw new Error("Dialog not confirmed.");
      } // FIXME: TODO: Validate Refer-To header field value.


      return new _referUserAgentClient.ReferUserAgentClient(this, delegate, options);
    }
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */

  }, {
    key: "receiveRequest",
    value: function receiveRequest(message) {
      var _this2 = this;

      this.logger.log("INVITE dialog ".concat(this.id, " received ").concat(message.method, " request")); // Response retransmissions cease when an ACK request for the
      // response is received.  This is independent of whatever transport
      // protocols are used to send the response.
      // https://tools.ietf.org/html/rfc6026#section-8.1

      if (message.method === _messages.C.ACK) {
        // If ackWait is true, then this is the ACK to the initial INVITE,
        // otherwise this is an ACK to an in dialog INVITE. In either case,
        // guard to make sure the sequence number of the ACK matches the INVITE.
        if (this.ackWait) {
          if (this.initialTransaction instanceof _transactions.InviteClientTransaction) {
            this.logger.warn("INVITE dialog ".concat(this.id, " received unexpected ").concat(message.method, " request, dropping."));
            return;
          }

          if (this.initialTransaction.request.cseq !== message.cseq) {
            this.logger.warn("INVITE dialog ".concat(this.id, " received unexpected ").concat(message.method, " request, dropping."));
            return;
          } // Update before the delegate has a chance to handle the
          // message as delegate may callback into this dialog.


          this.ackWait = false;
        } else {
          if (!this.reinviteUserAgentServer) {
            this.logger.warn("INVITE dialog ".concat(this.id, " received unexpected ").concat(message.method, " request, dropping."));
            return;
          }

          if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {
            this.logger.warn("INVITE dialog ".concat(this.id, " received unexpected ").concat(message.method, " request, dropping."));
            return;
          }

          this.reinviteUserAgentServer = undefined;
        }

        this.signalingStateTransition(message);

        if (this.delegate && this.delegate.onAck) {
          var promiseOrVoid = this.delegate.onAck({
            message: message
          });

          if (promiseOrVoid instanceof Promise) {
            this.ackProcessing = true; // make sure this is always reset to false

            promiseOrVoid.then(function () {
              return _this2.ackProcessing = false;
            }).catch(function () {
              return _this2.ackProcessing = false;
            });
          }
        }

        return;
      } // Request within a dialog out of sequence guard.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      if (!this.sequenceGuard(message)) {
        this.logger.log("INVITE dialog ".concat(this.id, " rejected out of order ").concat(message.method, " request."));
        return;
      } // Request within a dialog common processing.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      _get(_getPrototypeOf(SessionDialog.prototype), "receiveRequest", this).call(this, message); // Handle various INVITE related cross-over, glare and race conditions


      if (message.method === _messages.C.INVITE) {
        // Hopefully this message is helpful...
        var warning = function warning() {
          var reason = _this2.ackWait ? "waiting for initial ACK" : "processing initial ACK";

          _this2.logger.warn("INVITE dialog ".concat(_this2.id, " received re-INVITE while ").concat(reason));

          var msg = "RFC 5407 suggests the following to avoid this race condition... ";
          msg += " Note: Implementation issues are outside the scope of this document,";
          msg += " but the following tip is provided for avoiding race conditions of";
          msg += " this type.  The caller can delay sending re-INVITE F6 for some period";
          msg += " of time (2 seconds, perhaps), after which the caller can reasonably";
          msg += " assume that its ACK has been received.  Implementors can decouple the";
          msg += " actions of the user (e.g., pressing the hold button) from the actions";
          msg += " of the protocol (the sending of re-INVITE F6), so that the UA can";
          msg += " behave like this.  In this case, it is the implementor's choice as to";
          msg += " how long to wait.  In most cases, such an implementation may be";
          msg += " useful to prevent the type of race condition shown in this section.";
          msg += " This document expresses no preference about whether or not they";
          msg += " should wait for an ACK to be delivered.  After considering the impact";
          msg += " on user experience, implementors should decide whether or not to wait";
          msg += " for a while, because the user experience depends on the";
          msg += " implementation and has no direct bearing on protocol behavior.";

          _this2.logger.warn(msg);

          return; // drop re-INVITE request message
        }; // A UAS that receives a second INVITE before it sends the final
        // response to a first INVITE with a lower CSeq sequence number on the
        // same dialog MUST return a 500 (Server Internal Error) response to the
        // second INVITE and MUST include a Retry-After header field with a
        // randomly chosen value of between 0 and 10 seconds.
        // https://tools.ietf.org/html/rfc3261#section-14.2


        var retryAfter = Math.floor(Math.random() * 10) + 1;
        var extraHeaders = ["Retry-After: ".concat(retryAfter)]; // There may be ONLY ONE offer/answer negotiation in progress for a
        // single dialog at any point in time.  Section 4 explains how to ensure
        // this.
        // https://tools.ietf.org/html/rfc6337#section-2.2

        if (this.ackProcessing) {
          // UAS-IsI:  While an INVITE server transaction is incomplete or ACK
          //           transaction associated with an offer/answer is incomplete,
          //           a UA must reject another INVITE request with a 500
          //           response.
          // https://tools.ietf.org/html/rfc6337#section-4.3
          this.core.replyStateless(message, {
            statusCode: 500,
            extraHeaders: extraHeaders
          });
          warning();
          return;
        } // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the
        // Moratorium State (Case 1)
        // https://tools.ietf.org/html/rfc5407#section-3.1.4
        // 3.1.5.  Callee Receives re-INVITE (Established State) While in the
        // Moratorium State (Case 2)
        // https://tools.ietf.org/html/rfc5407#section-3.1.5


        if (this.ackWait && this.signalingState !== _session.SignalingState.Stable) {
          // This scenario is basically the same as that of Section 3.1.4, but
          // differs in sending an offer in the 200 and an answer in the ACK.  In
          // contrast to the previous case, the offer in the 200 (F3) and the
          // offer in the re-INVITE (F6) collide with each other.
          //
          // Bob sends a 491 to the re-INVITE (F6) since he is not able to
          // properly handle a new request until he receives an answer.  (Note:
          // 500 with a Retry-After header may be returned if the 491 response is
          // understood to indicate request collision.  However, 491 is
          // recommended here because 500 applies to so many cases that it is
          // difficult to determine what the real problem was.)
          // https://tools.ietf.org/html/rfc5407#section-3.1.5
          // UAS-IsI:  While an INVITE server transaction is incomplete or ACK
          //           transaction associated with an offer/answer is incomplete,
          //           a UA must reject another INVITE request with a 500
          //           response.
          // https://tools.ietf.org/html/rfc6337#section-4.3
          this.core.replyStateless(message, {
            statusCode: 500,
            extraHeaders: extraHeaders
          });
          warning();
          return;
        } // A UAS that receives a second INVITE before it sends the final
        // response to a first INVITE with a lower CSeq sequence number on the
        // same dialog MUST return a 500 (Server Internal Error) response to the
        // second INVITE and MUST include a Retry-After header field with a
        // randomly chosen value of between 0 and 10 seconds.
        // https://tools.ietf.org/html/rfc3261#section-14.2


        if (this.reinviteUserAgentServer) {
          this.core.replyStateless(message, {
            statusCode: 500,
            extraHeaders: extraHeaders
          });
          return;
        } // A UAS that receives an INVITE on a dialog while an INVITE it had sent
        // on that dialog is in progress MUST return a 491 (Request Pending)
        // response to the received INVITE.
        // https://tools.ietf.org/html/rfc3261#section-14.2


        if (this.reinviteUserAgentClient) {
          this.core.replyStateless(message, {
            statusCode: 491
          });
          return;
        }
      } // Requests within a dialog MAY contain Record-Route and Contact header
      // fields.  However, these requests do not cause the dialog's route set
      // to be modified, although they may modify the remote target URI.
      // Specifically, requests that are not target refresh requests do not
      // modify the dialog's remote target URI, and requests that are target
      // refresh requests do.  For dialogs that have been established with an
      // INVITE, the only target refresh request defined is re-INVITE (see
      // Section 14).  Other extensions may define different target refresh
      // requests for dialogs established in other ways.
      //
      //    Note that an ACK is NOT a target refresh request.
      //
      // Target refresh requests only update the dialog's remote target URI,
      // and not the route set formed from the Record-Route.  Updating the
      // latter would introduce severe backwards compatibility problems with
      // RFC 2543-compliant systems.
      // https://tools.ietf.org/html/rfc3261#section-15


      if (message.method === _messages.C.INVITE) {
        // FIXME: parser needs to be typed...
        var contact = message.parseHeader("contact");

        if (!contact) {
          // TODO: Review to make sure this will never happen
          throw new Error("Contact undefined.");
        }

        if (!(contact instanceof _messages.NameAddrHeader)) {
          throw new Error("Contact not instance of NameAddrHeader.");
        }

        this.dialogState.remoteTarget = contact.uri;
      } // Switch on method and then delegate.


      switch (message.method) {
        case _messages.C.BYE:
          // A UAS core receiving a BYE request for an existing dialog MUST follow
          // the procedures of Section 12.2.2 to process the request.  Once done,
          // the UAS SHOULD terminate the session (and therefore stop sending and
          // listening for media).  The only case where it can elect not to are
          // multicast sessions, where participation is possible even if the other
          // participant in the dialog has terminated its involvement in the
          // session.  Whether or not it ends its participation on the session,
          // the UAS core MUST generate a 2xx response to the BYE, and MUST pass
          // that to the server transaction for transmission.
          //
          // The UAS MUST still respond to any pending requests received for that
          // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
          // be generated to those pending requests.
          // https://tools.ietf.org/html/rfc3261#section-15.1.2
          {
            var uas = new _byeUserAgentServer.ByeUserAgentServer(this, message);
            this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();
            this.dispose();
          }
          break;

        case _messages.C.INFO:
          // If a UA receives an INFO request associated with an Info Package that
          // the UA has not indicated willingness to receive, the UA MUST send a
          // 469 (Bad Info Package) response (see Section 11.6), which contains a
          // Recv-Info header field with Info Packages for which the UA is willing
          // to receive INFO requests.
          {
            var _uas = new _infoUserAgentServer.InfoUserAgentServer(this, message);

            this.delegate && this.delegate.onInfo ? this.delegate.onInfo(_uas) : _uas.reject({
              statusCode: 469,
              extraHeaders: ["Recv-Info:"]
            });
          }
          break;

        case _messages.C.INVITE:
          // If the new session description is not acceptable, the UAS can reject
          // it by returning a 488 (Not Acceptable Here) response for the re-
          // INVITE.  This response SHOULD include a Warning header field.
          // https://tools.ietf.org/html/rfc3261#section-14.2
          {
            var _uas2 = new _reInviteUserAgentServer.ReInviteUserAgentServer(this, message);

            this.signalingStateTransition(message);
            this.delegate && this.delegate.onInvite ? this.delegate.onInvite(_uas2) : _uas2.reject({
              statusCode: 488
            }); // TODO: Warning header field.
          }
          break;

        case _messages.C.MESSAGE:
          {
            var _uas3 = new _messageUserAgentServer.MessageUserAgentServer(this.core, message);

            this.delegate && this.delegate.onMessage ? this.delegate.onMessage(_uas3) : _uas3.accept();
          }
          break;

        case _messages.C.NOTIFY:
          // https://tools.ietf.org/html/rfc3515#section-2.4.4
          {
            var _uas4 = new _notifyUserAgentServer.NotifyUserAgentServer(this, message);

            this.delegate && this.delegate.onNotify ? this.delegate.onNotify(_uas4) : _uas4.accept();
          }
          break;

        case _messages.C.PRACK:
          // https://tools.ietf.org/html/rfc3262#section-4
          {
            var _uas5 = new _prackUserAgentServer.PrackUserAgentServer(this, message);

            this.delegate && this.delegate.onPrack ? this.delegate.onPrack(_uas5) : _uas5.accept();
          }
          break;

        case _messages.C.REFER:
          // https://tools.ietf.org/html/rfc3515#section-2.4.2
          {
            var _uas6 = new _referUserAgentServer.ReferUserAgentServer(this, message);

            this.delegate && this.delegate.onRefer ? this.delegate.onRefer(_uas6) : _uas6.reject();
          }
          break;

        default:
          {
            this.logger.log("INVITE dialog ".concat(this.id, " received unimplemented ").concat(message.method, " request"));
            this.core.replyStateless(message, {
              statusCode: 501
            });
          }
          break;
      }
    }
    /**
     * Guard against out of order reliable provisional responses and retransmissions.
     * Returns false if the response should be discarded, otherwise true.
     * @param message - Incoming response message within this dialog.
     */

  }, {
    key: "reliableSequenceGuard",
    value: function reliableSequenceGuard(message) {
      var statusCode = message.statusCode;

      if (!statusCode) {
        throw new Error("Status code undefined");
      }

      if (statusCode > 100 && statusCode < 200) {
        // If a provisional response is received for an initial request, and
        // that response contains a Require header field containing the option
        // tag 100rel, the response is to be sent reliably.  If the response is
        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
        // ignored, and the procedures below MUST NOT be used.
        // https://tools.ietf.org/html/rfc3262#section-4
        var requireHeader = message.getHeader("require");
        var rseqHeader = message.getHeader("rseq");
        var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;

        if (rseq) {
          // Handling of subsequent reliable provisional responses for the same
          // initial request follows the same rules as above, with the following
          // difference: reliable provisional responses are guaranteed to be in
          // order.  As a result, if the UAC receives another reliable provisional
          // response to the same request, and its RSeq value is not one higher
          // than the value of the sequence number, that response MUST NOT be
          // acknowledged with a PRACK, and MUST NOT be processed further by the
          // UAC.  An implementation MAY discard the response, or MAY cache the
          // response in the hopes of receiving the missing responses.
          // https://tools.ietf.org/html/rfc3262#section-4
          if (this.rseq && this.rseq + 1 !== rseq) {
            return false;
          } // Once a reliable provisional response is received, retransmissions of
          // that response MUST be discarded.  A response is a retransmission when
          // its dialog ID, CSeq, and RSeq match the original response.  The UAC
          // MUST maintain a sequence number that indicates the most recently
          // received in-order reliable provisional response for the initial
          // request.  This sequence number MUST be maintained until a final
          // response is received for the initial request.  Its value MUST be
          // initialized to the RSeq header field in the first reliable
          // provisional response received for the initial request.
          // https://tools.ietf.org/html/rfc3262#section-4


          this.rseq = this.rseq ? this.rseq + 1 : rseq;
        }
      }

      return true;
    }
    /**
     * If not in a stable signaling state, rollback to prior stable signaling state.
     */

  }, {
    key: "signalingStateRollback",
    value: function signalingStateRollback() {
      if (this._signalingState === _session.SignalingState.HaveLocalOffer || this.signalingState === _session.SignalingState.HaveRemoteOffer) {
        if (this._rollbackOffer && this._rollbackAnswer) {
          this._signalingState = _session.SignalingState.Stable;
          this._offer = this._rollbackOffer;
          this._answer = this._rollbackAnswer;
        }
      }
    }
    /**
     * Update the signaling state of the dialog.
     * @param message - The message to base the update off of.
     */

  }, {
    key: "signalingStateTransition",
    value: function signalingStateTransition(message) {
      var body = (0, _messages.getBody)(message); // No body, no session. No, woman, no cry.

      if (!body || body.contentDisposition !== "session") {
        return;
      } // We've got an existing offer and answer which we may wish to rollback to


      if (this._signalingState === _session.SignalingState.Stable) {
        this._rollbackOffer = this._offer;
        this._rollbackAnswer = this._answer;
      } // We're in UAS role, receiving incoming request with session description


      if (message instanceof _messages.IncomingRequestMessage) {
        switch (this._signalingState) {
          case _session.SignalingState.Initial:
          case _session.SignalingState.Stable:
            this._signalingState = _session.SignalingState.HaveRemoteOffer;
            this._offer = body;
            this._answer = undefined;
            break;

          case _session.SignalingState.HaveLocalOffer:
            this._signalingState = _session.SignalingState.Stable;
            this._answer = body;
            break;

          case _session.SignalingState.HaveRemoteOffer:
            // You cannot make a new offer while one is in progress.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // FIXME: What to do here?
            break;

          case _session.SignalingState.Closed:
            break;

          default:
            throw new Error("Unexpected signaling state.");
        }
      } // We're in UAC role, receiving incoming response with session description


      if (message instanceof _messages.IncomingResponseMessage) {
        switch (this._signalingState) {
          case _session.SignalingState.Initial:
          case _session.SignalingState.Stable:
            this._signalingState = _session.SignalingState.HaveRemoteOffer;
            this._offer = body;
            this._answer = undefined;
            break;

          case _session.SignalingState.HaveLocalOffer:
            this._signalingState = _session.SignalingState.Stable;
            this._answer = body;
            break;

          case _session.SignalingState.HaveRemoteOffer:
            // You cannot make a new offer while one is in progress.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // FIXME: What to do here?
            break;

          case _session.SignalingState.Closed:
            break;

          default:
            throw new Error("Unexpected signaling state.");
        }
      } // We're in UAC role, sending outgoing request with session description


      if (message instanceof _messages.OutgoingRequestMessage) {
        switch (this._signalingState) {
          case _session.SignalingState.Initial:
          case _session.SignalingState.Stable:
            this._signalingState = _session.SignalingState.HaveLocalOffer;
            this._offer = body;
            this._answer = undefined;
            break;

          case _session.SignalingState.HaveLocalOffer:
            // You cannot make a new offer while one is in progress.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // FIXME: What to do here?
            break;

          case _session.SignalingState.HaveRemoteOffer:
            this._signalingState = _session.SignalingState.Stable;
            this._answer = body;
            break;

          case _session.SignalingState.Closed:
            break;

          default:
            throw new Error("Unexpected signaling state.");
        }
      } // We're in UAS role, sending outgoing response with session description


      if ((0, _messages.isBody)(message)) {
        switch (this._signalingState) {
          case _session.SignalingState.Initial:
          case _session.SignalingState.Stable:
            this._signalingState = _session.SignalingState.HaveLocalOffer;
            this._offer = body;
            this._answer = undefined;
            break;

          case _session.SignalingState.HaveLocalOffer:
            // You cannot make a new offer while one is in progress.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // FIXME: What to do here?
            break;

          case _session.SignalingState.HaveRemoteOffer:
            this._signalingState = _session.SignalingState.Stable;
            this._answer = body;
            break;

          case _session.SignalingState.Closed:
            break;

          default:
            throw new Error("Unexpected signaling state.");
        }
      }
    }
  }, {
    key: "start2xxRetransmissionTimer",
    value: function start2xxRetransmissionTimer() {
      var _this3 = this;

      if (this.initialTransaction instanceof _transactions.InviteServerTransaction) {
        var transaction = this.initialTransaction; // Once the response has been constructed, it is passed to the INVITE
        // server transaction.  In order to ensure reliable end-to-end
        // transport of the response, it is necessary to periodically pass
        // the response directly to the transport until the ACK arrives.  The
        // 2xx response is passed to the transport with an interval that
        // starts at T1 seconds and doubles for each retransmission until it
        // reaches T2 seconds (T1 and T2 are defined in Section 17).
        // Response retransmissions cease when an ACK request for the
        // response is received.  This is independent of whatever transport
        // protocols are used to send the response.
        // https://tools.ietf.org/html/rfc6026#section-8.1

        var timeout = _timers.Timers.T1;

        var retransmission = function retransmission() {
          if (!_this3.ackWait) {
            _this3.invite2xxTimer = undefined;
            return;
          }

          _this3.logger.log("No ACK for 2xx response received, attempting retransmission");

          transaction.retransmitAcceptedResponse();
          timeout = Math.min(timeout * 2, _timers.Timers.T2);
          _this3.invite2xxTimer = setTimeout(retransmission, timeout);
        };

        this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without
        // receiving an ACK, the dialog is confirmed, but the session SHOULD be
        // terminated.  This is accomplished with a BYE, as described in Section 15.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4

        var stateChanged = function stateChanged() {
          if (transaction.state === _transactions.TransactionState.Terminated) {
            transaction.removeStateChangeListener(stateChanged);

            if (_this3.invite2xxTimer) {
              clearTimeout(_this3.invite2xxTimer);
              _this3.invite2xxTimer = undefined;
            }

            if (_this3.ackWait) {
              if (_this3.delegate && _this3.delegate.onAckTimeout) {
                _this3.delegate.onAckTimeout();
              } else {
                _this3.bye();
              }
            }
          }
        };

        transaction.addStateChangeListener(stateChanged);
      }
    } // FIXME: Refactor

  }, {
    key: "startReInvite2xxRetransmissionTimer",
    value: function startReInvite2xxRetransmissionTimer() {
      var _this4 = this;

      if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof _transactions.InviteServerTransaction) {
        var transaction = this.reinviteUserAgentServer.transaction; // Once the response has been constructed, it is passed to the INVITE
        // server transaction.  In order to ensure reliable end-to-end
        // transport of the response, it is necessary to periodically pass
        // the response directly to the transport until the ACK arrives.  The
        // 2xx response is passed to the transport with an interval that
        // starts at T1 seconds and doubles for each retransmission until it
        // reaches T2 seconds (T1 and T2 are defined in Section 17).
        // Response retransmissions cease when an ACK request for the
        // response is received.  This is independent of whatever transport
        // protocols are used to send the response.
        // https://tools.ietf.org/html/rfc6026#section-8.1

        var timeout = _timers.Timers.T1;

        var retransmission = function retransmission() {
          if (!_this4.reinviteUserAgentServer) {
            _this4.invite2xxTimer = undefined;
            return;
          }

          _this4.logger.log("No ACK for 2xx response received, attempting retransmission");

          transaction.retransmitAcceptedResponse();
          timeout = Math.min(timeout * 2, _timers.Timers.T2);
          _this4.invite2xxTimer = setTimeout(retransmission, timeout);
        };

        this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without
        // receiving an ACK, the dialog is confirmed, but the session SHOULD be
        // terminated.  This is accomplished with a BYE, as described in Section 15.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4

        var stateChanged = function stateChanged() {
          if (transaction.state === _transactions.TransactionState.Terminated) {
            transaction.removeStateChangeListener(stateChanged);

            if (_this4.invite2xxTimer) {
              clearTimeout(_this4.invite2xxTimer);
              _this4.invite2xxTimer = undefined;
            }

            if (_this4.reinviteUserAgentServer) {// FIXME: TODO: What to do here
            }
          }
        };

        transaction.addStateChangeListener(stateChanged);
      }
    }
  }]);

  return SessionDialog;
}(_dialog.Dialog);

exports.SessionDialog = SessionDialog;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../session":"node_modules/sip.js/lib/core/session/index.js","../timers":"node_modules/sip.js/lib/core/timers.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","../user-agents/bye-user-agent-client":"node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js","../user-agents/bye-user-agent-server":"node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js","../user-agents/info-user-agent-client":"node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js","../user-agents/info-user-agent-server":"node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js","../user-agents/message-user-agent-client":"node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js","../user-agents/message-user-agent-server":"node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js","../user-agents/notify-user-agent-client":"node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js","../user-agents/notify-user-agent-server":"node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js","../user-agents/prack-user-agent-client":"node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js","../user-agents/prack-user-agent-server":"node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js","../user-agents/re-invite-user-agent-client":"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js","../user-agents/re-invite-user-agent-server":"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js","../user-agents/refer-user-agent-client":"node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js","../user-agents/refer-user-agent-server":"node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js","./dialog":"node_modules/sip.js/lib/core/dialogs/dialog.js"}],"node_modules/sip.js/lib/core/subscription/subscription.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscriptionState = void 0;

/**
 * Subscription state.
 * @remarks
 * https://tools.ietf.org/html/rfc6665#section-4.1.2
 * @public
 */
var SubscriptionState;
exports.SubscriptionState = SubscriptionState;

(function (SubscriptionState) {
  SubscriptionState["Initial"] = "Initial";
  SubscriptionState["NotifyWait"] = "NotifyWait";
  SubscriptionState["Pending"] = "Pending";
  SubscriptionState["Active"] = "Active";
  SubscriptionState["Terminated"] = "Terminated";
})(SubscriptionState || (exports.SubscriptionState = SubscriptionState = {}));
},{}],"node_modules/sip.js/lib/core/subscription/subscription-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/subscription/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _subscription = require("./subscription");

Object.keys(_subscription).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscription[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscription[key];
    }
  });
});

var _subscriptionDelegate = require("./subscription-delegate");

Object.keys(_subscriptionDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionDelegate[key];
    }
  });
});
},{"./subscription":"node_modules/sip.js/lib/core/subscription/subscription.js","./subscription-delegate":"node_modules/sip.js/lib/core/subscription/subscription-delegate.js"}],"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AllowedMethods = void 0;

var _messages = require("../messages");

/**
 * FIXME: TODO: Should be configurable/variable.
 */
var AllowedMethods = [_messages.C.ACK, _messages.C.BYE, _messages.C.CANCEL, _messages.C.INFO, _messages.C.INVITE, _messages.C.MESSAGE, _messages.C.NOTIFY, _messages.C.OPTIONS, _messages.C.PRACK, _messages.C.REFER, _messages.C.REGISTER, _messages.C.SUBSCRIBE];
exports.AllowedMethods = AllowedMethods;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js"}],"node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReSubscribeUserAgentClient = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Re-SUBSCRIBE UAC.
 * @public
 */
var ReSubscribeUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(ReSubscribeUserAgentClient, _UserAgentClient);

  var _super = _createSuper(ReSubscribeUserAgentClient);

  function ReSubscribeUserAgentClient(dialog, delegate, options) {
    var _this;

    _classCallCheck(this, ReSubscribeUserAgentClient);

    var message = dialog.createOutgoingRequestMessage(_messages.C.SUBSCRIBE, options);
    _this = _super.call(this, _transactions.NonInviteClientTransaction, dialog.userAgentCore, message, delegate);
    _this.dialog = dialog;
    return _this;
  }

  _createClass(ReSubscribeUserAgentClient, [{
    key: "waitNotifyStop",
    value: function waitNotifyStop() {
      // TODO: Placeholder. Not utilized currently.
      return;
    }
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(message) {
      if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
        //  The "Expires" header field in a 200-class response to SUBSCRIBE
        //  request indicates the actual duration for which the subscription will
        //  remain active (unless refreshed).  The received value might be
        //  smaller than the value indicated in the SUBSCRIBE request but cannot
        //  be larger; see Section 4.2.1 for details.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
        var expires = message.getHeader("Expires");

        if (!expires) {
          this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
        } else {
          var subscriptionExpiresReceived = Number(expires);

          if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
            this.dialog.subscriptionExpires = subscriptionExpiresReceived;
          }
        }
      }

      if (message.statusCode && message.statusCode >= 400 && message.statusCode < 700) {
        // If a SUBSCRIBE request to refresh a subscription receives a 404, 405,
        // 410, 416, 480-485, 489, 501, or 604 response, the subscriber MUST
        // consider the subscription terminated.  (See [RFC5057] for further
        // details and notes about the effect of error codes on dialogs and
        // usages within dialog, such as subscriptions).  If the subscriber
        // wishes to re-subscribe to the state, he does so by composing an
        // unrelated initial SUBSCRIBE request with a freshly generated Call-ID
        // and a new, unique "From" tag (see Section 4.1.2.1).
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
        var errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];

        if (errorCodes.includes(message.statusCode)) {
          this.dialog.terminate();
        } // If a SUBSCRIBE request to refresh a subscription fails with any error
        // code other than those listed above, the original subscription is
        // still considered valid for the duration of the most recently known
        // "Expires" value as negotiated by the most recent successful SUBSCRIBE
        // transaction, or as communicated by a NOTIFY request in its
        // "Subscription-State" header field "expires" parameter.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2

      }

      _get(_getPrototypeOf(ReSubscribeUserAgentClient.prototype), "receiveResponse", this).call(this, message);
    }
  }]);

  return ReSubscribeUserAgentClient;
}(_userAgentClient.UserAgentClient);

exports.ReSubscribeUserAgentClient = ReSubscribeUserAgentClient;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/dialogs/subscription-dialog.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscriptionDialog = void 0;

var _messages = require("../messages");

var _subscription = require("../subscription");

var _timers = require("../timers");

var _allowedMethods = require("../user-agent-core/allowed-methods");

var _notifyUserAgentServer = require("../user-agents/notify-user-agent-server");

var _reSubscribeUserAgentClient = require("../user-agents/re-subscribe-user-agent-client");

var _dialog = require("./dialog");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Subscription Dialog.
 * @remarks
 * SIP-Specific Event Notification
 *
 * Abstract
 *
 *    This document describes an extension to the Session Initiation
 *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is
 *    to provide an extensible framework by which SIP nodes can request
 *    notification from remote nodes indicating that certain events have
 *    occurred.
 *
 *    Note that the event notification mechanisms defined herein are NOT
 *    intended to be a general-purpose infrastructure for all classes of
 *    event subscription and notification.
 *
 *    This document represents a backwards-compatible improvement on the
 *    original mechanism described by RFC 3265, taking into account several
 *    years of implementation experience.  Accordingly, this document
 *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to
 *    accommodate some small changes to the mechanism that were discussed
 *    in that document.
 *
 *  https://tools.ietf.org/html/rfc6665
 * @public
 */
var SubscriptionDialog = /*#__PURE__*/function (_Dialog) {
  _inherits(SubscriptionDialog, _Dialog);

  var _super = _createSuper(SubscriptionDialog);

  function SubscriptionDialog(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {
    var _this;

    _classCallCheck(this, SubscriptionDialog);

    _this = _super.call(this, core, state);
    _this.delegate = delegate;
    _this._autoRefresh = false;
    _this._subscriptionEvent = subscriptionEvent;
    _this._subscriptionExpires = subscriptionExpires;
    _this._subscriptionExpiresInitial = subscriptionExpires;
    _this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
    _this._subscriptionRefresh = undefined;
    _this._subscriptionRefreshLastSet = undefined;
    _this._subscriptionState = subscriptionState;
    _this.logger = core.loggerFactory.getLogger("sip.subscribe-dialog");

    _this.logger.log("SUBSCRIBE dialog ".concat(_this.id, " constructed"));

    return _this;
  }
  /**
   * When a UAC receives a response that establishes a dialog, it
   * constructs the state of the dialog.  This state MUST be maintained
   * for the duration of the dialog.
   * https://tools.ietf.org/html/rfc3261#section-12.1.2
   * @param outgoingRequestMessage - Outgoing request message for dialog.
   * @param incomingResponseMessage - Incoming response message creating dialog.
   */


  _createClass(SubscriptionDialog, [{
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(SubscriptionDialog.prototype), "dispose", this).call(this);

      if (this.N) {
        clearTimeout(this.N);
        this.N = undefined;
      }

      this.refreshTimerClear();
      this.logger.log("SUBSCRIBE dialog ".concat(this.id, " destroyed"));
    }
  }, {
    key: "autoRefresh",
    get: function get() {
      return this._autoRefresh;
    },
    set: function set(autoRefresh) {
      this._autoRefresh = true;
      this.refreshTimerSet();
    }
  }, {
    key: "subscriptionEvent",
    get: function get() {
      return this._subscriptionEvent;
    }
    /** Number of seconds until subscription expires. */

  }, {
    key: "subscriptionExpires",
    get: function get() {
      var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;

      var secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
      return Math.max(secondsUntilExpires, 0);
    },
    set: function set(expires) {
      if (expires < 0) {
        throw new Error("Expires must be greater than or equal to zero.");
      }

      this._subscriptionExpires = expires;
      this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);

      if (this.autoRefresh) {
        var refresh = this.subscriptionRefresh;

        if (refresh === undefined || refresh >= expires) {
          this.refreshTimerSet();
        }
      }
    }
  }, {
    key: "subscriptionExpiresInitial",
    get: function get() {
      return this._subscriptionExpiresInitial;
    }
    /** Number of seconds until subscription auto refresh. */

  }, {
    key: "subscriptionRefresh",
    get: function get() {
      if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {
        return undefined;
      }

      var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;

      var secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
      return Math.max(secondsUntilExpires, 0);
    }
  }, {
    key: "subscriptionState",
    get: function get() {
      return this._subscriptionState;
    }
    /**
     * Receive in dialog request message from transport.
     * @param message -  The incoming request message.
     */

  }, {
    key: "receiveRequest",
    value: function receiveRequest(message) {
      this.logger.log("SUBSCRIBE dialog ".concat(this.id, " received ").concat(message.method, " request")); // Request within a dialog out of sequence guard.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2

      if (!this.sequenceGuard(message)) {
        this.logger.log("SUBSCRIBE dialog ".concat(this.id, " rejected out of order ").concat(message.method, " request."));
        return;
      } // Request within a dialog common processing.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      _get(_getPrototypeOf(SubscriptionDialog.prototype), "receiveRequest", this).call(this, message); // Switch on method and then delegate.


      switch (message.method) {
        case _messages.C.NOTIFY:
          this.onNotify(message);
          break;

        default:
          this.logger.log("SUBSCRIBE dialog ".concat(this.id, " received unimplemented ").concat(message.method, " request"));
          this.core.replyStateless(message, {
            statusCode: 501
          });
          break;
      }
    }
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

      var options = {};
      options.extraHeaders = (options.extraHeaders || []).slice();
      options.extraHeaders.push(allowHeader);
      options.extraHeaders.push("Event: " + this.subscriptionEvent);
      options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
      options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
      return this.subscribe(undefined, options);
    }
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     * @param delegate - Delegate to handle responses.
     * @param options - Options bucket.
     */

  }, {
    key: "subscribe",
    value: function subscribe(delegate) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.subscriptionState !== _subscription.SubscriptionState.Pending && this.subscriptionState !== _subscription.SubscriptionState.Active) {
        // FIXME: This needs to be a proper exception
        throw new Error("Invalid state ".concat(this.subscriptionState, ". May only re-subscribe while in state \"pending\" or \"active\"."));
      }

      this.logger.log("SUBSCRIBE dialog ".concat(this.id, " sending SUBSCRIBE request"));
      var uac = new _reSubscribeUserAgentClient.ReSubscribeUserAgentClient(this, delegate, options); // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).

      if (this.N) {
        clearTimeout(this.N);
        this.N = undefined;
      } // When refreshing a subscription, a subscriber starts Timer N, set to
      // 64*T1, when it sends the SUBSCRIBE request.
      // https://tools.ietf.org/html/rfc6665#section-4.1.2.2


      this.N = setTimeout(function () {
        return _this2.timerN();
      }, _timers.Timers.TIMER_N);
      return uac;
    }
    /**
     * 4.4.1.  Dialog Creation and Termination
     * A subscription is destroyed after a notifier sends a NOTIFY request
     * with a "Subscription-State" of "terminated", or in certain error
     * situations described elsewhere in this document.
     * https://tools.ietf.org/html/rfc6665#section-4.4.1
     */

  }, {
    key: "terminate",
    value: function terminate() {
      this.stateTransition(_subscription.SubscriptionState.Terminated);
      this.onTerminated();
    }
    /**
     * 4.1.2.3.  Unsubscribing
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

      var options = {};
      options.extraHeaders = (options.extraHeaders || []).slice();
      options.extraHeaders.push(allowHeader);
      options.extraHeaders.push("Event: " + this.subscriptionEvent);
      options.extraHeaders.push("Expires: 0");
      options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
      return this.subscribe(undefined, options);
    }
    /**
     * Handle in dialog NOTIFY requests.
     * This does not include the first NOTIFY which created the dialog.
     * @param message - The incoming NOTIFY request message.
     */

  }, {
    key: "onNotify",
    value: function onNotify(message) {
      // If, for some reason, the event package designated in the "Event"
      // header field of the NOTIFY request is not supported, the subscriber
      // will respond with a 489 (Bad Event) response.
      // https://tools.ietf.org/html/rfc6665#section-4.1.3
      var event = message.parseHeader("Event").event;

      if (!event || event !== this.subscriptionEvent) {
        this.core.replyStateless(message, {
          statusCode: 489
        });
        return;
      } // In the state diagram, "Re-subscription times out" means that an
      // attempt to refresh or update the subscription using a new SUBSCRIBE
      // request does not result in a NOTIFY request before the corresponding
      // Timer N expires.
      // https://tools.ietf.org/html/rfc6665#section-4.1.2


      if (this.N) {
        clearTimeout(this.N);
        this.N = undefined;
      } // NOTIFY requests MUST contain "Subscription-State" header fields that
      // indicate the status of the subscription.
      // https://tools.ietf.org/html/rfc6665#section-4.1.3


      var subscriptionState = message.parseHeader("Subscription-State");

      if (!subscriptionState || !subscriptionState.state) {
        this.core.replyStateless(message, {
          statusCode: 489
        });
        return;
      }

      var state = subscriptionState.state;
      var expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined; // Update our state and expiration.

      switch (state) {
        case "pending":
          this.stateTransition(_subscription.SubscriptionState.Pending, expires);
          break;

        case "active":
          this.stateTransition(_subscription.SubscriptionState.Active, expires);
          break;

        case "terminated":
          this.stateTransition(_subscription.SubscriptionState.Terminated, expires);
          break;

        default:
          this.logger.warn("Unrecognized subscription state.");
          break;
      } // Delegate remainder of NOTIFY handling.


      var uas = new _notifyUserAgentServer.NotifyUserAgentServer(this, message);

      if (this.delegate && this.delegate.onNotify) {
        this.delegate.onNotify(uas);
      } else {
        uas.accept();
      }
    }
  }, {
    key: "onRefresh",
    value: function onRefresh(request) {
      if (this.delegate && this.delegate.onRefresh) {
        this.delegate.onRefresh(request);
      }
    }
  }, {
    key: "onTerminated",
    value: function onTerminated() {
      if (this.delegate && this.delegate.onTerminated) {
        this.delegate.onTerminated();
      }
    }
  }, {
    key: "refreshTimerClear",
    value: function refreshTimerClear() {
      if (this.refreshTimer) {
        clearTimeout(this.refreshTimer);
        this.refreshTimer = undefined;
      }
    }
  }, {
    key: "refreshTimerSet",
    value: function refreshTimerSet() {
      var _this3 = this;

      this.refreshTimerClear();

      if (this.autoRefresh && this.subscriptionExpires > 0) {
        var refresh = this.subscriptionExpires * 900;
        this._subscriptionRefresh = Math.floor(refresh / 1000);
        this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);
        this.refreshTimer = setTimeout(function () {
          _this3.refreshTimer = undefined;
          _this3._subscriptionRefresh = undefined;
          _this3._subscriptionRefreshLastSet = undefined;

          _this3.onRefresh(_this3.refresh());
        }, refresh);
      }
    }
  }, {
    key: "stateTransition",
    value: function stateTransition(newState, newExpires) {
      var _this4 = this;

      // Assert valid state transitions.
      var invalidStateTransition = function invalidStateTransition() {
        _this4.logger.warn("Invalid subscription state transition from ".concat(_this4.subscriptionState, " to ").concat(newState));
      };

      switch (newState) {
        case _subscription.SubscriptionState.Initial:
          invalidStateTransition();
          return;

        case _subscription.SubscriptionState.NotifyWait:
          invalidStateTransition();
          return;

        case _subscription.SubscriptionState.Pending:
          if (this.subscriptionState !== _subscription.SubscriptionState.NotifyWait && this.subscriptionState !== _subscription.SubscriptionState.Pending) {
            invalidStateTransition();
            return;
          }

          break;

        case _subscription.SubscriptionState.Active:
          if (this.subscriptionState !== _subscription.SubscriptionState.NotifyWait && this.subscriptionState !== _subscription.SubscriptionState.Pending && this.subscriptionState !== _subscription.SubscriptionState.Active) {
            invalidStateTransition();
            return;
          }

          break;

        case _subscription.SubscriptionState.Terminated:
          if (this.subscriptionState !== _subscription.SubscriptionState.NotifyWait && this.subscriptionState !== _subscription.SubscriptionState.Pending && this.subscriptionState !== _subscription.SubscriptionState.Active) {
            invalidStateTransition();
            return;
          }

          break;

        default:
          invalidStateTransition();
          return;
      } // If the "Subscription-State" value is "pending", the subscription has
      // been received by the notifier, but there is insufficient policy
      // information to grant or deny the subscription yet.  If the header
      // field also contains an "expires" parameter, the subscriber SHOULD
      // take it as the authoritative subscription duration and adjust
      // accordingly.  No further action is necessary on the part of the
      // subscriber.  The "retry-after" and "reason" parameters have no
      // semantics for "pending".
      // https://tools.ietf.org/html/rfc6665#section-4.1.3


      if (newState === _subscription.SubscriptionState.Pending) {
        if (newExpires) {
          this.subscriptionExpires = newExpires;
        }
      } // If the "Subscription-State" header field value is "active", it means
      // that the subscription has been accepted and (in general) has been
      // authorized.  If the header field also contains an "expires"
      // parameter, the subscriber SHOULD take it as the authoritative
      // subscription duration and adjust accordingly.  The "retry-after" and
      // "reason" parameters have no semantics for "active".
      // https://tools.ietf.org/html/rfc6665#section-4.1.3


      if (newState === _subscription.SubscriptionState.Active) {
        if (newExpires) {
          this.subscriptionExpires = newExpires;
        }
      } // If the "Subscription-State" value is "terminated", the subscriber
      // MUST consider the subscription terminated.  The "expires" parameter
      // has no semantics for "terminated" -- notifiers SHOULD NOT include an
      // "expires" parameter on a "Subscription-State" header field with a
      // value of "terminated", and subscribers MUST ignore any such
      // parameter, if present.


      if (newState === _subscription.SubscriptionState.Terminated) {
        this.dispose();
      }

      this._subscriptionState = newState;
    }
    /**
     * When refreshing a subscription, a subscriber starts Timer N, set to
     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription terminated.  If the subscriber receives a success
     * response to the SUBSCRIBE request that indicates that no NOTIFY
     * request will be generated -- such as the 204 response defined for use
     * with the optional extension described in [RFC5839] -- then it MUST
     * cancel Timer N.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */

  }, {
    key: "timerN",
    value: function timerN() {
      this.logger.warn("Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.");

      if (this.subscriptionState !== _subscription.SubscriptionState.Terminated) {
        this.stateTransition(_subscription.SubscriptionState.Terminated);
        this.onTerminated();
      }
    }
  }], [{
    key: "initialDialogStateForSubscription",
    value: function initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
      // If the request was sent over TLS, and the Request-URI contained a
      // SIPS URI, the "secure" flag is set to TRUE.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2
      var secure = false; // FIXME: Currently no support for TLS.
      // The route set MUST be set to the list of URIs in the Record-Route
      // header field from the response, taken in reverse order and preserving
      // all URI parameters.  If no Record-Route header field is present in
      // the response, the route set MUST be set to the empty set.  This route
      // set, even if empty, overrides any pre-existing route set for future
      // requests in this dialog.  The remote target MUST be set to the URI
      // from the Contact header field of the response.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2

      var routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
      var contact = incomingNotifyRequestMessage.parseHeader("contact");

      if (!contact) {
        // TODO: Review to make sure this will never happen
        throw new Error("Contact undefined.");
      }

      if (!(contact instanceof _messages.NameAddrHeader)) {
        throw new Error("Contact not instance of NameAddrHeader.");
      }

      var remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence
      // number in the CSeq header field of the request.  The remote sequence
      // number MUST be empty (it is established when the remote UA sends a
      // request within the dialog).  The call identifier component of the
      // dialog ID MUST be set to the value of the Call-ID in the request.
      // The local tag component of the dialog ID MUST be set to the tag in
      // the From field in the request, and the remote tag component of the
      // dialog ID MUST be set to the tag in the To field of the response.  A
      // UAC MUST be prepared to receive a response without a tag in the To
      // field, in which case the tag is considered to have a value of null.
      //
      //    This is to maintain backwards compatibility with RFC 2543, which
      //    did not mandate To tags.
      //
      // https://tools.ietf.org/html/rfc3261#section-12.1.2

      var localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
      var remoteSequenceNumber = undefined;
      var callId = outgoingSubscribeRequestMessage.callId;
      var localTag = outgoingSubscribeRequestMessage.fromTag;
      var remoteTag = incomingNotifyRequestMessage.fromTag;

      if (!callId) {
        // TODO: Review to make sure this will never happen
        throw new Error("Call id undefined.");
      }

      if (!localTag) {
        // TODO: Review to make sure this will never happen
        throw new Error("From tag undefined.");
      }

      if (!remoteTag) {
        // TODO: Review to make sure this will never happen
        throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
      } // The remote URI MUST be set to the URI in the To field, and the local
      // URI MUST be set to the URI in the From field.
      // https://tools.ietf.org/html/rfc3261#section-12.1.2


      if (!outgoingSubscribeRequestMessage.from) {
        // TODO: Review to make sure this will never happen
        throw new Error("From undefined.");
      }

      if (!outgoingSubscribeRequestMessage.to) {
        // TODO: Review to make sure this will never happen
        throw new Error("To undefined.");
      }

      var localURI = outgoingSubscribeRequestMessage.from.uri;
      var remoteURI = outgoingSubscribeRequestMessage.to.uri; // A dialog can also be in the "early" state, which occurs when it is
      // created with a provisional response, and then transition to the
      // "confirmed" state when a 2xx final response arrives.
      // https://tools.ietf.org/html/rfc3261#section-12

      var early = false;
      var dialogState = {
        id: callId + localTag + remoteTag,
        early: early,
        callId: callId,
        localTag: localTag,
        remoteTag: remoteTag,
        localSequenceNumber: localSequenceNumber,
        remoteSequenceNumber: remoteSequenceNumber,
        localURI: localURI,
        remoteURI: remoteURI,
        remoteTarget: remoteTarget,
        routeSet: routeSet,
        secure: secure
      };
      return dialogState;
    }
  }]);

  return SubscriptionDialog;
}(_dialog.Dialog);

exports.SubscriptionDialog = SubscriptionDialog;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../subscription":"node_modules/sip.js/lib/core/subscription/index.js","../timers":"node_modules/sip.js/lib/core/timers.js","../user-agent-core/allowed-methods":"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js","../user-agents/notify-user-agent-server":"node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js","../user-agents/re-subscribe-user-agent-client":"node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js","./dialog":"node_modules/sip.js/lib/core/dialogs/dialog.js"}],"node_modules/sip.js/lib/core/dialogs/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dialog = require("./dialog");

Object.keys(_dialog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dialog[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dialog[key];
    }
  });
});

var _dialogState = require("./dialog-state");

Object.keys(_dialogState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dialogState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dialogState[key];
    }
  });
});

var _sessionDialog = require("./session-dialog");

Object.keys(_sessionDialog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDialog[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDialog[key];
    }
  });
});

var _subscriptionDialog = require("./subscription-dialog");

Object.keys(_subscriptionDialog).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionDialog[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionDialog[key];
    }
  });
});
},{"./dialog":"node_modules/sip.js/lib/core/dialogs/dialog.js","./dialog-state":"node_modules/sip.js/lib/core/dialogs/dialog-state.js","./session-dialog":"node_modules/sip.js/lib/core/dialogs/session-dialog.js","./subscription-dialog":"node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"}],"node_modules/sip.js/lib/core/log/levels.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Levels = void 0;

/**
 * Log levels.
 * @public
 */
var Levels;
exports.Levels = Levels;

(function (Levels) {
  Levels[Levels["error"] = 0] = "error";
  Levels[Levels["warn"] = 1] = "warn";
  Levels[Levels["log"] = 2] = "log";
  Levels[Levels["debug"] = 3] = "debug";
})(Levels || (exports.Levels = Levels = {}));
},{}],"node_modules/sip.js/lib/core/log/logger.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;

var _levels = require("./levels");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Logger.
 * @public
 */
var Logger = /*#__PURE__*/function () {
  function Logger(logger, category, label) {
    _classCallCheck(this, Logger);

    this.logger = logger;
    this.category = category;
    this.label = label;
  }

  _createClass(Logger, [{
    key: "error",
    value: function error(content) {
      this.genericLog(_levels.Levels.error, content);
    }
  }, {
    key: "warn",
    value: function warn(content) {
      this.genericLog(_levels.Levels.warn, content);
    }
  }, {
    key: "log",
    value: function log(content) {
      this.genericLog(_levels.Levels.log, content);
    }
  }, {
    key: "debug",
    value: function debug(content) {
      this.genericLog(_levels.Levels.debug, content);
    }
  }, {
    key: "genericLog",
    value: function genericLog(level, content) {
      this.logger.genericLog(level, this.category, this.label, content);
    }
  }, {
    key: "level",
    get: function get() {
      return this.logger.level;
    },
    set: function set(newLevel) {
      this.logger.level = newLevel;
    }
  }]);

  return Logger;
}();

exports.Logger = Logger;
},{"./levels":"node_modules/sip.js/lib/core/log/levels.js"}],"node_modules/sip.js/lib/core/log/logger-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoggerFactory = void 0;

var _levels = require("./levels");

var _logger = require("./logger");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Logger.
 * @public
 */
var LoggerFactory = /*#__PURE__*/function () {
  function LoggerFactory() {
    _classCallCheck(this, LoggerFactory);

    this.builtinEnabled = true;
    this._level = _levels.Levels.log; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    this.loggers = {};
    this.logger = this.getLogger("sip:loggerfactory");
  }

  _createClass(LoggerFactory, [{
    key: "level",
    get: function get() {
      return this._level;
    },
    set: function set(newLevel) {
      if (newLevel >= 0 && newLevel <= 3) {
        this._level = newLevel;
      } else if (newLevel > 3) {
        this._level = 3; // eslint-disable-next-line no-prototype-builtins
      } else if (_levels.Levels.hasOwnProperty(newLevel)) {
        this._level = newLevel;
      } else {
        this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
      }
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "connector",
    get: function get() {
      return this._connector;
    },
    set: function set(value) {
      if (!value) {
        this._connector = undefined;
      } else if (typeof value === "function") {
        this._connector = value;
      } else {
        this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value));
      }
    }
  }, {
    key: "getLogger",
    value: function getLogger(category, label) {
      if (label && this.level === 3) {
        return new _logger.Logger(this, category, label);
      } else if (this.loggers[category]) {
        return this.loggers[category];
      } else {
        var logger = new _logger.Logger(this, category);
        this.loggers[category] = logger;
        return logger;
      }
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "genericLog",
    value: function genericLog(levelToLog, category, label, content) {
      if (this.level >= levelToLog) {
        if (this.builtinEnabled) {
          this.print(levelToLog, category, label, content);
        }
      }

      if (this.connector) {
        this.connector(_levels.Levels[levelToLog], category, label, content);
      }
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "print",
    value: function print(levelToLog, category, label, content) {
      if (typeof content === "string") {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var prefix = [new Date(), category];

        if (label) {
          prefix.push(label);
        }

        content = prefix.concat(content).join(" | ");
      }

      switch (levelToLog) {
        case _levels.Levels.error:
          // eslint-disable-next-line no-console
          console.error(content);
          break;

        case _levels.Levels.warn:
          // eslint-disable-next-line no-console
          console.warn(content);
          break;

        case _levels.Levels.log:
          // eslint-disable-next-line no-console
          console.log(content);
          break;

        case _levels.Levels.debug:
          // eslint-disable-next-line no-console
          console.debug(content);
          break;

        default:
          break;
      }
    }
  }]);

  return LoggerFactory;
}();

exports.LoggerFactory = LoggerFactory;
},{"./levels":"node_modules/sip.js/lib/core/log/levels.js","./logger":"node_modules/sip.js/lib/core/log/logger.js"}],"node_modules/sip.js/lib/core/log/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _levels = require("./levels");

Object.keys(_levels).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _levels[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _levels[key];
    }
  });
});

var _loggerFactory = require("./logger-factory");

Object.keys(_loggerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _loggerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _loggerFactory[key];
    }
  });
});

var _logger = require("./logger");

Object.keys(_logger).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _logger[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _logger[key];
    }
  });
});
},{"./levels":"node_modules/sip.js/lib/core/log/levels.js","./logger-factory":"node_modules/sip.js/lib/core/log/logger-factory.js","./logger":"node_modules/sip.js/lib/core/log/logger.js"}],"node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CancelUserAgentClient = void 0;

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * CANCEL UAC.
 * @public
 */
var CancelUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(CancelUserAgentClient, _UserAgentClient);

  var _super = _createSuper(CancelUserAgentClient);

  function CancelUserAgentClient(core, message, delegate) {
    _classCallCheck(this, CancelUserAgentClient);

    return _super.call(this, _transactions.NonInviteClientTransaction, core, message, delegate);
  }

  return _createClass(CancelUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.CancelUserAgentClient = CancelUserAgentClient;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InviteUserAgentClient = void 0;

var _dialogs = require("../dialogs");

var _session2 = require("../session");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INVITE UAC.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.2 UAC Processing
 * https://tools.ietf.org/html/rfc3261#section-13.2
 * @public
 */
var InviteUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(InviteUserAgentClient, _UserAgentClient);

  var _super = _createSuper(InviteUserAgentClient);

  function InviteUserAgentClient(core, message, delegate) {
    var _this;

    _classCallCheck(this, InviteUserAgentClient);

    _this = _super.call(this, _transactions.InviteClientTransaction, core, message, delegate);
    _this.confirmedDialogAcks = new Map();
    _this.confirmedDialogs = new Map();
    _this.earlyDialogs = new Map();
    _this.delegate = delegate;
    return _this;
  }

  _createClass(InviteUserAgentClient, [{
    key: "dispose",
    value: function dispose() {
      // The UAC core considers the INVITE transaction completed 64*T1 seconds
      // after the reception of the first 2xx response.  At this point all the
      // early dialogs that have not transitioned to established dialogs are
      // terminated.  Once the INVITE transaction is considered completed by
      // the UAC core, no more new 2xx responses are expected to arrive.
      //
      // If, after acknowledging any 2xx response to an INVITE, the UAC does
      // not want to continue with that dialog, then the UAC MUST terminate
      // the dialog by sending a BYE request as described in Section 15.
      // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
      this.earlyDialogs.forEach(function (earlyDialog) {
        return earlyDialog.dispose();
      });
      this.earlyDialogs.clear();

      _get(_getPrototypeOf(InviteUserAgentClient.prototype), "dispose", this).call(this);
    }
    /**
     * Special case for transport error while sending ACK.
     * @param error - Transport error
     */

  }, {
    key: "onTransportError",
    value: function onTransportError(error) {
      if (this.transaction.state === _transactions.TransactionState.Calling) {
        return _get(_getPrototypeOf(InviteUserAgentClient.prototype), "onTransportError", this).call(this, error);
      } // If not in 'calling' state, the transport error occurred while sending an ACK.


      this.logger.error(error.message);
      this.logger.error("User agent client request transport error while sending ACK.");
    }
    /**
     * Once the INVITE has been passed to the INVITE client transaction, the
     * UAC waits for responses for the INVITE.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2
     * @param incomingResponse - Incoming response to INVITE request.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(message) {
      var _this2 = this;

      if (!this.authenticationGuard(message)) {
        return;
      }

      var statusCode = message.statusCode ? message.statusCode.toString() : "";

      if (!statusCode) {
        throw new Error("Response status code undefined.");
      }

      switch (true) {
        case /^100$/.test(statusCode):
          if (this.delegate && this.delegate.onTrying) {
            this.delegate.onTrying({
              message: message
            });
          }

          return;

        case /^1[0-9]{2}$/.test(statusCode):
          // Zero, one or multiple provisional responses may arrive before one or
          // more final responses are received.  Provisional responses for an
          // INVITE request can create "early dialogs".  If a provisional response
          // has a tag in the To field, and if the dialog ID of the response does
          // not match an existing dialog, one is constructed using the procedures
          // defined in Section 12.1.2.
          //
          // The early dialog will only be needed if the UAC needs to send a
          // request to its peer within the dialog before the initial INVITE
          // transaction completes.  Header fields present in a provisional
          // response are applicable as long as the dialog is in the early state
          // (for example, an Allow header field in a provisional response
          // contains the methods that can be used in the dialog while this is in
          // the early state).
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.1
          {
            // Dialogs are created through the generation of non-failure responses
            // to requests with specific methods.  Within this specification, only
            // 2xx and 101-199 responses with a To tag, where the request was
            // INVITE, will establish a dialog.  A dialog established by a non-final
            // response to a request is in the "early" state and it is called an
            // early dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.1
            // Provisional without to tag, no dialog to create.
            if (!message.toTag) {
              this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
              return;
            } // When a UAS responds to a request with a response that establishes a
            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
            // header field values from the request into the response (including the
            // URIs, URI parameters, and any Record-Route header field parameters,
            // whether they are known or unknown to the UAS) and MUST maintain the
            // order of those values.  The UAS MUST add a Contact header field to
            // the response.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            // Provisional without Contact header field, malformed response.


            var contact = message.parseHeader("contact");

            if (!contact) {
              this.logger.error("Non-100 1xx INVITE response received without a Contact header field, dropping.");
              return;
            } // Compute dialog state.


            var dialogState = _dialogs.Dialog.initialDialogStateForUserAgentClient(this.message, message); // Have existing early dialog or create a new one.


            var earlyDialog = this.earlyDialogs.get(dialogState.id);

            if (!earlyDialog) {
              var transaction = this.transaction;

              if (!(transaction instanceof _transactions.InviteClientTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
              }

              earlyDialog = new _dialogs.SessionDialog(transaction, this.core, dialogState);
              this.earlyDialogs.set(earlyDialog.id, earlyDialog);
            } // Guard against out of order reliable provisional responses.
            // Note that this is where the rseq tracking is done.


            if (!earlyDialog.reliableSequenceGuard(message)) {
              this.logger.warn("1xx INVITE reliable response received out of order or is a retransmission, dropping.");
              return;
            } // If the initial offer is in an INVITE, the answer MUST be in a
            // reliable non-failure message from UAS back to UAC which is
            // correlated to that INVITE.  For this specification, that is
            // only the final 2xx response to that INVITE.  That same exact
            // answer MAY also be placed in any provisional responses sent
            // prior to the answer.  The UAC MUST treat the first session
            // description it receives as the answer, and MUST ignore any
            // session descriptions in subsequent responses to the initial
            // INVITE.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1


            if (earlyDialog.signalingState === _session2.SignalingState.Initial || earlyDialog.signalingState === _session2.SignalingState.HaveLocalOffer) {
              earlyDialog.signalingStateTransition(message);
            } // Pass response to delegate.


            var session = earlyDialog;

            if (this.delegate && this.delegate.onProgress) {
              this.delegate.onProgress({
                message: message,
                session: session,
                prack: function prack(options) {
                  var outgoingPrackRequest = session.prack(undefined, options);
                  return outgoingPrackRequest;
                }
              });
            }
          }
          return;

        case /^2[0-9]{2}$/.test(statusCode):
          // Multiple 2xx responses may arrive at the UAC for a single INVITE
          // request due to a forking proxy.  Each response is distinguished by
          // the tag parameter in the To header field, and each represents a
          // distinct dialog, with a distinct dialog identifier.
          //
          // If the dialog identifier in the 2xx response matches the dialog
          // identifier of an existing dialog, the dialog MUST be transitioned to
          // the "confirmed" state, and the route set for the dialog MUST be
          // recomputed based on the 2xx response using the procedures of Section
          // 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
          // constructed using the procedures of Section 12.1.2.
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
          {
            // Dialogs are created through the generation of non-failure responses
            // to requests with specific methods.  Within this specification, only
            // 2xx and 101-199 responses with a To tag, where the request was
            // INVITE, will establish a dialog.  A dialog established by a non-final
            // response to a request is in the "early" state and it is called an
            // early dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.1
            // Final without to tag, malformed response.
            if (!message.toTag) {
              this.logger.error("2xx INVITE response received without a to tag, dropping.");
              return;
            } // When a UAS responds to a request with a response that establishes a
            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
            // header field values from the request into the response (including the
            // URIs, URI parameters, and any Record-Route header field parameters,
            // whether they are known or unknown to the UAS) and MUST maintain the
            // order of those values.  The UAS MUST add a Contact header field to
            // the response.
            // https://tools.ietf.org/html/rfc3261#section-12.1.1
            // Final without Contact header field, malformed response.


            var _contact = message.parseHeader("contact");

            if (!_contact) {
              this.logger.error("2xx INVITE response received without a Contact header field, dropping.");
              return;
            } // Compute dialog state.


            var _dialogState = _dialogs.Dialog.initialDialogStateForUserAgentClient(this.message, message); // NOTE: Currently our transaction layer is caching the 2xx ACKs and
            // handling retransmissions of the ACK which is an approach which is
            // not to spec. In any event, this block is intended to provide a to
            // spec implementation of ACK retransmissions, but it should not be
            // hit currently.


            var dialog = this.confirmedDialogs.get(_dialogState.id);

            if (dialog) {
              // Once the ACK has been constructed, the procedures of [4] are used to
              // determine the destination address, port and transport.  However, the
              // request is passed to the transport layer directly for transmission,
              // rather than a client transaction.  This is because the UAC core
              // handles retransmissions of the ACK, not the transaction layer.  The
              // ACK MUST be passed to the client transport every time a
              // retransmission of the 2xx final response that triggered the ACK
              // arrives.
              // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
              var outgoingAckRequest = this.confirmedDialogAcks.get(_dialogState.id);

              if (outgoingAckRequest) {
                var _transaction = this.transaction;

                if (!(_transaction instanceof _transactions.InviteClientTransaction)) {
                  throw new Error("Client transaction not instance of InviteClientTransaction.");
                }

                _transaction.ackResponse(outgoingAckRequest.message);
              } else {// If still waiting for an ACK, drop the retransmission of the 2xx final response.
              }

              return;
            } // If the dialog identifier in the 2xx response matches the dialog
            // identifier of an existing dialog, the dialog MUST be transitioned to
            // the "confirmed" state, and the route set for the dialog MUST be
            // recomputed based on the 2xx response using the procedures of Section
            // 12.2.1.2. Otherwise, a new dialog in the "confirmed" state MUST be
            // constructed using the procedures of Section 12.1.2.
            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4


            dialog = this.earlyDialogs.get(_dialogState.id);

            if (dialog) {
              dialog.confirm();
              dialog.recomputeRouteSet(message);
              this.earlyDialogs.delete(dialog.id);
              this.confirmedDialogs.set(dialog.id, dialog);
            } else {
              var _transaction2 = this.transaction;

              if (!(_transaction2 instanceof _transactions.InviteClientTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
              }

              dialog = new _dialogs.SessionDialog(_transaction2, this.core, _dialogState);
              this.confirmedDialogs.set(dialog.id, dialog);
            } // If the initial offer is in an INVITE, the answer MUST be in a
            // reliable non-failure message from UAS back to UAC which is
            // correlated to that INVITE.  For this specification, that is
            // only the final 2xx response to that INVITE.  That same exact
            // answer MAY also be placed in any provisional responses sent
            // prior to the answer.  The UAC MUST treat the first session
            // description it receives as the answer, and MUST ignore any
            // session descriptions in subsequent responses to the initial
            // INVITE.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1


            if (dialog.signalingState === _session2.SignalingState.Initial || dialog.signalingState === _session2.SignalingState.HaveLocalOffer) {
              dialog.signalingStateTransition(message);
            } // Session Initiated! :)


            var _session = dialog; // The UAC core MUST generate an ACK request for each 2xx received from
            // the transaction layer.  The header fields of the ACK are constructed
            // in the same way as for any request sent within a dialog (see Section
            // 12) with the exception of the CSeq and the header fields related to
            // authentication.  The sequence number of the CSeq header field MUST be
            // the same as the INVITE being acknowledged, but the CSeq method MUST
            // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
            // the 2xx contains an offer (based on the rules above), the ACK MUST
            // carry an answer in its body.  If the offer in the 2xx response is not
            // acceptable, the UAC core MUST generate a valid answer in the ACK and
            // then send a BYE immediately.
            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4

            if (this.delegate && this.delegate.onAccept) {
              this.delegate.onAccept({
                message: message,
                session: _session,
                ack: function ack(options) {
                  var outgoingAckRequest = _session.ack(options);

                  _this2.confirmedDialogAcks.set(_session.id, outgoingAckRequest);

                  return outgoingAckRequest;
                }
              });
            } else {
              var _outgoingAckRequest = _session.ack();

              this.confirmedDialogAcks.set(_session.id, _outgoingAckRequest);
            }
          }
          return;

        case /^3[0-9]{2}$/.test(statusCode):
          // 12.3 Termination of a Dialog
          //
          // Independent of the method, if a request outside of a dialog generates
          // a non-2xx final response, any early dialogs created through
          // provisional responses to that request are terminated.  The mechanism
          // for terminating confirmed dialogs is method specific.  In this
          // specification, the BYE method terminates a session and the dialog
          // associated with it.  See Section 15 for details.
          // https://tools.ietf.org/html/rfc3261#section-12.3
          // All early dialogs are considered terminated upon reception of the
          // non-2xx final response.
          //
          // After having received the non-2xx final response the UAC core
          // considers the INVITE transaction completed.  The INVITE client
          // transaction handles the generation of ACKs for the response (see
          // Section 17).
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
          this.earlyDialogs.forEach(function (earlyDialog) {
            return earlyDialog.dispose();
          });
          this.earlyDialogs.clear(); // A 3xx response may contain one or more Contact header field values
          // providing new addresses where the callee might be reachable.
          // Depending on the status code of the 3xx response (see Section 21.3),
          // the UAC MAY choose to try those new addresses.
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.2

          if (this.delegate && this.delegate.onRedirect) {
            this.delegate.onRedirect({
              message: message
            });
          }

          return;

        case /^[4-6][0-9]{2}$/.test(statusCode):
          // 12.3 Termination of a Dialog
          //
          // Independent of the method, if a request outside of a dialog generates
          // a non-2xx final response, any early dialogs created through
          // provisional responses to that request are terminated.  The mechanism
          // for terminating confirmed dialogs is method specific.  In this
          // specification, the BYE method terminates a session and the dialog
          // associated with it.  See Section 15 for details.
          // https://tools.ietf.org/html/rfc3261#section-12.3
          // All early dialogs are considered terminated upon reception of the
          // non-2xx final response.
          //
          // After having received the non-2xx final response the UAC core
          // considers the INVITE transaction completed.  The INVITE client
          // transaction handles the generation of ACKs for the response (see
          // Section 17).
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
          this.earlyDialogs.forEach(function (earlyDialog) {
            return earlyDialog.dispose();
          });
          this.earlyDialogs.clear(); // A single non-2xx final response may be received for the INVITE.  4xx,
          // 5xx and 6xx responses may contain a Contact header field value
          // indicating the location where additional information about the error
          // can be found.  Subsequent final responses (which would only arrive
          // under error conditions) MUST be ignored.
          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3

          if (this.delegate && this.delegate.onReject) {
            this.delegate.onReject({
              message: message
            });
          }

          return;

        default:
          throw new Error("Invalid status code ".concat(statusCode));
      }

      throw new Error("Executing what should be an unreachable code path receiving ".concat(statusCode, " response."));
    }
  }]);

  return InviteUserAgentClient;
}(_userAgentClient.UserAgentClient);

exports.InviteUserAgentClient = InviteUserAgentClient;
},{"../dialogs":"node_modules/sip.js/lib/core/dialogs/index.js","../session":"node_modules/sip.js/lib/core/session/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InviteUserAgentServer = void 0;

var _dialogs = require("../dialogs");

var _exceptions = require("../exceptions");

var _session = require("../session");

var _transactions = require("../transactions");

var _allowedMethods = require("../user-agent-core/allowed-methods");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * INVITE UAS.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.3 UAS Processing
 * https://tools.ietf.org/html/rfc3261#section-13.3
 * @public
 */
var InviteUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(InviteUserAgentServer, _UserAgentServer);

  var _super = _createSuper(InviteUserAgentServer);

  function InviteUserAgentServer(core, message, delegate) {
    var _this;

    _classCallCheck(this, InviteUserAgentServer);

    _this = _super.call(this, _transactions.InviteServerTransaction, core, message, delegate);
    _this.core = core;
    return _this;
  }

  _createClass(InviteUserAgentServer, [{
    key: "dispose",
    value: function dispose() {
      if (this.earlyDialog) {
        this.earlyDialog.dispose();
      }

      _get(_getPrototypeOf(InviteUserAgentServer.prototype), "dispose", this).call(this);
    }
    /**
     * 13.3.1.4 The INVITE is Accepted
     * The UAS core generates a 2xx response.  This response establishes a
     * dialog, and therefore follows the procedures of Section 12.1.1 in
     * addition to those of Section 8.2.6.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
     * @param options - Accept options bucket.
     */

  }, {
    key: "accept",
    value: function accept() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 200
      };

      if (!this.acceptable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not acceptable in state ").concat(this.transaction.state, "."));
      } // This response establishes a dialog...
      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4


      if (!this.confirmedDialog) {
        if (this.earlyDialog) {
          this.earlyDialog.confirm();
          this.confirmedDialog = this.earlyDialog;
          this.earlyDialog = undefined;
        } else {
          var transaction = this.transaction;

          if (!(transaction instanceof _transactions.InviteServerTransaction)) {
            throw new Error("Transaction not instance of InviteClientTransaction.");
          }

          var state = _dialogs.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);

          this.confirmedDialog = new _dialogs.SessionDialog(transaction, this.core, state);
        }
      } // When a UAS responds to a request with a response that establishes a
      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
      // header field values from the request into the response (including the
      // URIs, URI parameters, and any Record-Route header field parameters,
      // whether they are known or unknown to the UAS) and MUST maintain the
      // order of those values.  The UAS MUST add a Contact header field to
      // the response.  The Contact header field contains an address where the
      // UAS would like to be contacted for subsequent requests in the dialog
      // (which includes the ACK for a 2xx response in the case of an INVITE).
      // Generally, the host portion of this URI is the IP address or FQDN of
      // the host.  The URI provided in the Contact header field MUST be a SIP
      // or SIPS URI.  If the request that initiated the dialog contained a
      // SIPS URI in the Request-URI or in the top Record-Route header field
      // value, if there was any, or the Contact header field if there was no
      // Record-Route header field, the Contact header field in the response
      // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
      // same URI can be used in messages outside this dialog).  The same way,
      // the scope of the URI in the Contact header field of the INVITE is not
      // limited to this dialog either.  It can therefore be used in messages
      // to the UAC even outside this dialog.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1


      var recordRouteHeader = this.message.getHeaders("record-route").map(function (header) {
        return "Record-Route: ".concat(header);
      });
      var contactHeader = "Contact: ".concat(this.core.configuration.contact.toString()); // A 2xx response to an INVITE SHOULD contain the Allow header field and
      // the Supported header field, and MAY contain the Accept header field.
      // Including these header fields allows the UAC to determine the
      // features and extensions supported by the UAS for the duration of the
      // call, without probing.
      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
      // FIXME: TODO: This should not be hard coded.

      var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString(); // FIXME: TODO: Supported header (see reply())
      // FIXME: TODO: Accept header
      // If the INVITE request contained an offer, and the UAS had not yet
      // sent an answer, the 2xx MUST contain an answer.  If the INVITE did
      // not contain an offer, the 2xx MUST contain an offer if the UAS had
      // not yet sent an offer.
      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4


      if (!options.body) {
        if (this.confirmedDialog.signalingState === _session.SignalingState.Stable) {
          options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response
        } else if (this.confirmedDialog.signalingState === _session.SignalingState.Initial || this.confirmedDialog.signalingState === _session.SignalingState.HaveRemoteOffer) {
          throw new Error("Response must have a body.");
        }
      }

      options.statusCode = options.statusCode || 200;
      options.extraHeaders = options.extraHeaders || [];
      options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
      options.extraHeaders.push(allowHeader);
      options.extraHeaders.push(contactHeader);

      var response = _get(_getPrototypeOf(InviteUserAgentServer.prototype), "accept", this).call(this, options);

      var session = this.confirmedDialog;
      var result = Object.assign(Object.assign({}, response), {
        session: session
      }); // Update dialog signaling state

      if (options.body) {
        // Once the UAS has sent or received an answer to the initial
        // offer, it MUST NOT generate subsequent offers in any responses
        // to the initial INVITE.  This means that a UAS based on this
        // specification alone can never generate subsequent offers until
        // completion of the initial transaction.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        if (this.confirmedDialog.signalingState !== _session.SignalingState.Stable) {
          this.confirmedDialog.signalingStateTransition(options.body);
        }
      }

      return result;
    }
    /**
     * 13.3.1.1 Progress
     * If the UAS is not able to answer the invitation immediately, it can
     * choose to indicate some kind of progress to the UAC (for example, an
     * indication that a phone is ringing).  This is accomplished with a
     * provisional response between 101 and 199.  These provisional
     * responses establish early dialogs and therefore follow the procedures
     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
     * send as many provisional responses as it likes.  Each of these MUST
     * indicate the same dialog ID.  However, these will not be delivered
     * reliably.
     *
     * If the UAS desires an extended period of time to answer the INVITE,
     * it will need to ask for an "extension" in order to prevent proxies
     * from canceling the transaction.  A proxy has the option of canceling
     * a transaction when there is a gap of 3 minutes between responses in a
     * transaction.  To prevent cancellation, the UAS MUST send a non-100
     * provisional response at every minute, to handle the possibility of
     * lost provisional responses.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
     * @param options - Progress options bucket.
     */

  }, {
    key: "progress",
    value: function progress() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 180
      };

      if (!this.progressable) {
        throw new _exceptions.TransactionStateError("".concat(this.message.method, " not progressable in state ").concat(this.transaction.state, "."));
      } // This response establishes a dialog...
      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4


      if (!this.earlyDialog) {
        var transaction = this.transaction;

        if (!(transaction instanceof _transactions.InviteServerTransaction)) {
          throw new Error("Transaction not instance of InviteClientTransaction.");
        }

        var state = _dialogs.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);

        this.earlyDialog = new _dialogs.SessionDialog(transaction, this.core, state);
      } // When a UAS responds to a request with a response that establishes a
      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
      // header field values from the request into the response (including the
      // URIs, URI parameters, and any Record-Route header field parameters,
      // whether they are known or unknown to the UAS) and MUST maintain the
      // order of those values.  The UAS MUST add a Contact header field to
      // the response.  The Contact header field contains an address where the
      // UAS would like to be contacted for subsequent requests in the dialog
      // (which includes the ACK for a 2xx response in the case of an INVITE).
      // Generally, the host portion of this URI is the IP address or FQDN of
      // the host.  The URI provided in the Contact header field MUST be a SIP
      // or SIPS URI.  If the request that initiated the dialog contained a
      // SIPS URI in the Request-URI or in the top Record-Route header field
      // value, if there was any, or the Contact header field if there was no
      // Record-Route header field, the Contact header field in the response
      // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
      // same URI can be used in messages outside this dialog).  The same way,
      // the scope of the URI in the Contact header field of the INVITE is not
      // limited to this dialog either.  It can therefore be used in messages
      // to the UAC even outside this dialog.
      // https://tools.ietf.org/html/rfc3261#section-12.1.1


      var recordRouteHeader = this.message.getHeaders("record-route").map(function (header) {
        return "Record-Route: ".concat(header);
      });
      var contactHeader = "Contact: ".concat(this.core.configuration.contact);
      options.extraHeaders = options.extraHeaders || [];
      options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
      options.extraHeaders.push(contactHeader);

      var response = _get(_getPrototypeOf(InviteUserAgentServer.prototype), "progress", this).call(this, options);

      var session = this.earlyDialog;
      var result = Object.assign(Object.assign({}, response), {
        session: session
      }); // Update dialog signaling state

      if (options.body) {
        // Once the UAS has sent or received an answer to the initial
        // offer, it MUST NOT generate subsequent offers in any responses
        // to the initial INVITE.  This means that a UAS based on this
        // specification alone can never generate subsequent offers until
        // completion of the initial transaction.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        if (this.earlyDialog.signalingState !== _session.SignalingState.Stable) {
          this.earlyDialog.signalingStateTransition(options.body);
        }
      }

      return result;
    }
    /**
     * 13.3.1.2 The INVITE is Redirected
     * If the UAS decides to redirect the call, a 3xx response is sent.  A
     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
     * Temporarily) response SHOULD contain a Contact header field
     * containing one or more URIs of new addresses to be tried.  The
     * response is passed to the INVITE server transaction, which will deal
     * with its retransmissions.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */

  }, {
    key: "redirect",
    value: function redirect(contacts) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        statusCode: 302
      };
      return _get(_getPrototypeOf(InviteUserAgentServer.prototype), "redirect", this).call(this, contacts, options);
    }
    /**
     * 13.3.1.3 The INVITE is Rejected
     * A common scenario occurs when the callee is currently not willing or
     * able to take additional calls at this end system.  A 486 (Busy Here)
     * SHOULD be returned in such a scenario.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
     * @param options - Reject options bucket.
     */

  }, {
    key: "reject",
    value: function reject() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 486
      };
      return _get(_getPrototypeOf(InviteUserAgentServer.prototype), "reject", this).call(this, options);
    }
  }]);

  return InviteUserAgentServer;
}(_userAgentServer.UserAgentServer);

exports.InviteUserAgentServer = InviteUserAgentServer;
},{"../dialogs":"node_modules/sip.js/lib/core/dialogs/index.js","../exceptions":"node_modules/sip.js/lib/core/exceptions/index.js","../session":"node_modules/sip.js/lib/core/session/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","../user-agent-core/allowed-methods":"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PublishUserAgentClient = void 0;

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * PUBLISH UAC.
 * @public
 */
var PublishUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(PublishUserAgentClient, _UserAgentClient);

  var _super = _createSuper(PublishUserAgentClient);

  function PublishUserAgentClient(core, message, delegate) {
    _classCallCheck(this, PublishUserAgentClient);

    return _super.call(this, _transactions.NonInviteClientTransaction, core, message, delegate);
  }

  return _createClass(PublishUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.PublishUserAgentClient = PublishUserAgentClient;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReSubscribeUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Re-SUBSCRIBE UAS.
 * @public
 */
var ReSubscribeUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(ReSubscribeUserAgentServer, _UserAgentServer);

  var _super = _createSuper(ReSubscribeUserAgentServer);

  function ReSubscribeUserAgentServer(dialog, message, delegate) {
    _classCallCheck(this, ReSubscribeUserAgentServer);

    return _super.call(this, _transactions.NonInviteServerTransaction, dialog.userAgentCore, message, delegate);
  }

  return _createClass(ReSubscribeUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.ReSubscribeUserAgentServer = ReSubscribeUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegisterUserAgentClient = void 0;

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * REGISTER UAC.
 * @public
 */
var RegisterUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(RegisterUserAgentClient, _UserAgentClient);

  var _super = _createSuper(RegisterUserAgentClient);

  function RegisterUserAgentClient(core, message, delegate) {
    _classCallCheck(this, RegisterUserAgentClient);

    return _super.call(this, _transactions.NonInviteClientTransaction, core, message, delegate);
  }

  return _createClass(RegisterUserAgentClient);
}(_userAgentClient.UserAgentClient);

exports.RegisterUserAgentClient = RegisterUserAgentClient;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegisterUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * REGISTER UAS.
 * @public
 */
var RegisterUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(RegisterUserAgentServer, _UserAgentServer);

  var _super = _createSuper(RegisterUserAgentServer);

  function RegisterUserAgentServer(core, message, delegate) {
    var _this;

    _classCallCheck(this, RegisterUserAgentServer);

    _this = _super.call(this, _transactions.NonInviteServerTransaction, core, message, delegate);
    _this.core = core;
    return _this;
  }

  return _createClass(RegisterUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.RegisterUserAgentServer = RegisterUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscribeUserAgentClient = void 0;

var _subscriptionDialog = require("../dialogs/subscription-dialog");

var _subscription = require("../subscription");

var _timers = require("../timers");

var _transactions = require("../transactions");

var _userAgentClient = require("./user-agent-client");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * SUBSCRIBE UAC.
 * @remarks
 * 4.1.  Subscriber Behavior
 * https://tools.ietf.org/html/rfc6665#section-4.1
 *
 * User agent client for installation of a single subscription per SUBSCRIBE request.
 * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.
 * @public
 */
var SubscribeUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {
  _inherits(SubscribeUserAgentClient, _UserAgentClient);

  var _super = _createSuper(SubscribeUserAgentClient);

  function SubscribeUserAgentClient(core, message, delegate) {
    var _this;

    _classCallCheck(this, SubscribeUserAgentClient);

    // Get event from request message.
    var event = message.getHeader("Event");

    if (!event) {
      throw new Error("Event undefined");
    } // Get expires from request message.


    var expires = message.getHeader("Expires");

    if (!expires) {
      throw new Error("Expires undefined");
    }

    _this = _super.call(this, _transactions.NonInviteClientTransaction, core, message, delegate);
    _this.delegate = delegate; // FIXME: Subscriber id should also be matching on event id.

    _this.subscriberId = message.callId + message.fromTag + event;
    _this.subscriptionExpiresRequested = _this.subscriptionExpires = Number(expires);
    _this.subscriptionEvent = event;
    _this.subscriptionState = _subscription.SubscriptionState.NotifyWait; // Start waiting for a NOTIFY we can use to create a subscription.

    _this.waitNotifyStart();

    return _this;
  }
  /**
   * Destructor.
   * Note that Timer N may live on waiting for an initial NOTIFY and
   * the delegate may still receive that NOTIFY. If you don't want
   * that behavior then either clear the delegate so the delegate
   * doesn't get called (a 200 will be sent in response to the NOTIFY)
   * or call `waitNotifyStop` which will clear Timer N and remove this
   * UAC from the core (a 481 will be sent in response to the NOTIFY).
   */


  _createClass(SubscribeUserAgentClient, [{
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(SubscribeUserAgentClient.prototype), "dispose", this).call(this);
    }
    /**
     * Handle out of dialog NOTIFY associated with SUBSCRIBE request.
     * This is the first NOTIFY received after the SUBSCRIBE request.
     * @param uas - User agent server handling the subscription creating NOTIFY.
     */

  }, {
    key: "onNotify",
    value: function onNotify(uas) {
      // NOTIFY requests are matched to such SUBSCRIBE requests if they
      // contain the same "Call-ID", a "To" header field "tag" parameter that
      // matches the "From" header field "tag" parameter of the SUBSCRIBE
      // request, and the same "Event" header field.  Rules for comparisons of
      // the "Event" header fields are described in Section 8.2.1.
      // https://tools.ietf.org/html/rfc6665#section-4.4.1
      var event = uas.message.parseHeader("Event").event;

      if (!event || event !== this.subscriptionEvent) {
        this.logger.warn("Failed to parse event.");
        uas.reject({
          statusCode: 489
        });
        return;
      } // NOTIFY requests MUST contain "Subscription-State" header fields that
      // indicate the status of the subscription.
      // https://tools.ietf.org/html/rfc6665#section-4.1.3


      var subscriptionState = uas.message.parseHeader("Subscription-State");

      if (!subscriptionState || !subscriptionState.state) {
        this.logger.warn("Failed to parse subscription state.");
        uas.reject({
          statusCode: 489
        });
        return;
      } // Validate subscription state.


      var state = subscriptionState.state;

      switch (state) {
        case "pending":
          break;

        case "active":
          break;

        case "terminated":
          break;

        default:
          this.logger.warn("Invalid subscription state ".concat(state));
          uas.reject({
            statusCode: 489
          });
          return;
      } // Dialogs usages are created upon completion of a NOTIFY transaction
      // for a new subscription, unless the NOTIFY request contains a
      // "Subscription-State" of "terminated."
      // https://tools.ietf.org/html/rfc6665#section-4.4.1


      if (state !== "terminated") {
        // The Contact header field MUST be present and contain exactly one SIP
        // or SIPS URI in any request that can result in the establishment of a
        // dialog.
        // https://tools.ietf.org/html/rfc3261#section-8.1.1.8
        var contact = uas.message.parseHeader("contact");

        if (!contact) {
          this.logger.warn("Failed to parse contact.");
          uas.reject({
            statusCode: 489
          });
          return;
        }
      } // In accordance with the rules for proxying non-INVITE requests as
      // defined in [RFC3261], successful SUBSCRIBE requests will receive only
      // one 200-class response; however, due to forking, the subscription may
      // have been accepted by multiple nodes.  The subscriber MUST therefore
      // be prepared to receive NOTIFY requests with "From:" tags that differ
      // from the "To:" tag received in the SUBSCRIBE 200-class response.
      //
      // If multiple NOTIFY requests are received in different dialogs in
      // response to a single SUBSCRIBE request, each dialog represents a
      // different destination to which the SUBSCRIBE request was forked.
      // Subscriber handling in such situations varies by event package; see
      // Section 5.4.9 for details.
      // https://tools.ietf.org/html/rfc6665#section-4.1.4
      // Each event package MUST specify whether forked SUBSCRIBE requests are
      // allowed to install multiple subscriptions.
      //
      // If such behavior is not allowed, the first potential dialog-
      // establishing message will create a dialog.  All subsequent NOTIFY
      // requests that correspond to the SUBSCRIBE request (i.e., have
      // matching "To", "From", "Call-ID", and "Event" header fields, as well
      // as "From" header field "tag" parameter and "Event" header field "id"
      // parameter) but that do not match the dialog would be rejected with a
      // 481 response.  Note that the 200-class response to the SUBSCRIBE
      // request can arrive after a matching NOTIFY request has been received;
      // such responses might not correlate to the same dialog established by
      // the NOTIFY request.  Except as required to complete the SUBSCRIBE
      // transaction, such non-matching 200-class responses are ignored.
      //
      // If installing of multiple subscriptions by way of a single forked
      // SUBSCRIBE request is allowed, the subscriber establishes a new dialog
      // towards each notifier by returning a 200-class response to each
      // NOTIFY request.  Each dialog is then handled as its own entity and is
      // refreshed independently of the other dialogs.
      //
      // In the case that multiple subscriptions are allowed, the event
      // package MUST specify whether merging of the notifications to form a
      // single state is required, and how such merging is to be performed.
      // Note that it is possible that some event packages may be defined in
      // such a way that each dialog is tied to a mutually exclusive state
      // that is unaffected by the other dialogs; this MUST be clearly stated
      // if it is the case.
      // https://tools.ietf.org/html/rfc6665#section-5.4.9
      // *** NOTE: This implementation is only for event packages which
      // do not allow forked requests to install multiple subscriptions.
      // As such and in accordance with the specification, we stop waiting
      // and any future NOTIFY requests will be rejected with a 481.


      if (this.dialog) {
        throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
      }

      this.waitNotifyStop(); // Update expires.

      this.subscriptionExpires = subscriptionState.expires ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) : this.subscriptionExpires; // Update subscription state.

      switch (state) {
        case "pending":
          this.subscriptionState = _subscription.SubscriptionState.Pending;
          break;

        case "active":
          this.subscriptionState = _subscription.SubscriptionState.Active;
          break;

        case "terminated":
          this.subscriptionState = _subscription.SubscriptionState.Terminated;
          break;

        default:
          throw new Error("Unrecognized state ".concat(state, "."));
      } // Dialogs usages are created upon completion of a NOTIFY transaction
      // for a new subscription, unless the NOTIFY request contains a
      // "Subscription-State" of "terminated."
      // https://tools.ietf.org/html/rfc6665#section-4.4.1


      if (this.subscriptionState !== _subscription.SubscriptionState.Terminated) {
        // Because the dialog usage is established by the NOTIFY request, the
        // route set at the subscriber is taken from the NOTIFY request itself,
        // as opposed to the route set present in the 200-class response to the
        // SUBSCRIBE request.
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        var dialogState = _subscriptionDialog.SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message); // Subscription Initiated! :)


        this.dialog = new _subscriptionDialog.SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
      } // Delegate.


      if (this.delegate && this.delegate.onNotify) {
        var request = uas;
        var subscription = this.dialog;
        this.delegate.onNotify({
          request: request,
          subscription: subscription
        });
      } else {
        uas.accept();
      }
    }
  }, {
    key: "waitNotifyStart",
    value: function waitNotifyStart() {
      var _this2 = this;

      if (!this.N) {
        // Add ourselves to the core's subscriber map.
        // This allows the core to route out of dialog NOTIFY messages to us.
        this.core.subscribers.set(this.subscriberId, this);
        this.N = setTimeout(function () {
          return _this2.timerN();
        }, _timers.Timers.TIMER_N);
      }
    }
  }, {
    key: "waitNotifyStop",
    value: function waitNotifyStop() {
      if (this.N) {
        // Remove ourselves to the core's subscriber map.
        // Any future out of dialog NOTIFY messages will be rejected with a 481.
        this.core.subscribers.delete(this.subscriberId);
        clearTimeout(this.N);
        this.N = undefined;
      }
    }
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(message) {
      if (!this.authenticationGuard(message)) {
        return;
      }

      if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
        //  The "Expires" header field in a 200-class response to SUBSCRIBE
        //  request indicates the actual duration for which the subscription will
        //  remain active (unless refreshed).  The received value might be
        //  smaller than the value indicated in the SUBSCRIBE request but cannot
        //  be larger; see Section 4.2.1 for details.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
        // The "Expires" values present in SUBSCRIBE 200-class responses behave
        // in the same way as they do in REGISTER responses: the server MAY
        // shorten the interval but MUST NOT lengthen it.
        //
        //    If the duration specified in a SUBSCRIBE request is unacceptably
        //    short, the notifier may be able to send a 423 response, as
        //    described earlier in this section.
        //
        // 200-class responses to SUBSCRIBE requests will not generally contain
        // any useful information beyond subscription duration; their primary
        // purpose is to serve as a reliability mechanism.  State information
        // will be communicated via a subsequent NOTIFY request from the
        // notifier.
        // https://tools.ietf.org/html/rfc6665#section-4.2.1.1
        var expires = message.getHeader("Expires");

        if (!expires) {
          this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
        } else {
          var subscriptionExpiresReceived = Number(expires);

          if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
            this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
          }

          if (subscriptionExpiresReceived < this.subscriptionExpires) {
            this.subscriptionExpires = subscriptionExpiresReceived;
          }
        } // If a NOTIFY arrived before 200-class response a dialog may have been created.
        // Updated the dialogs expiration only if this indicates earlier expiration.


        if (this.dialog) {
          if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
            this.dialog.subscriptionExpires = this.subscriptionExpires;
          }
        }
      }

      if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {
        this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.
      }

      _get(_getPrototypeOf(SubscribeUserAgentClient.prototype), "receiveResponse", this).call(this, message);
    }
    /**
     * To ensure that subscribers do not wait indefinitely for a
     * subscription to be established, a subscriber starts a Timer N, set to
     * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription failed, and cleans up any state associated with the
     * subscription attempt.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
     */

  }, {
    key: "timerN",
    value: function timerN() {
      this.logger.warn("Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.");
      this.waitNotifyStop();

      if (this.delegate && this.delegate.onNotifyTimeout) {
        this.delegate.onNotifyTimeout();
      }
    }
  }]);

  return SubscribeUserAgentClient;
}(_userAgentClient.UserAgentClient);

exports.SubscribeUserAgentClient = SubscribeUserAgentClient;
},{"../dialogs/subscription-dialog":"node_modules/sip.js/lib/core/dialogs/subscription-dialog.js","../subscription":"node_modules/sip.js/lib/core/subscription/index.js","../timers":"node_modules/sip.js/lib/core/timers.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js"}],"node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscribeUserAgentServer = void 0;

var _transactions = require("../transactions");

var _userAgentServer = require("./user-agent-server");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * SUBSCRIBE UAS.
 * @public
 */
var SubscribeUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {
  _inherits(SubscribeUserAgentServer, _UserAgentServer);

  var _super = _createSuper(SubscribeUserAgentServer);

  function SubscribeUserAgentServer(core, message, delegate) {
    var _this;

    _classCallCheck(this, SubscribeUserAgentServer);

    _this = _super.call(this, _transactions.NonInviteServerTransaction, core, message, delegate);
    _this.core = core;
    return _this;
  }

  return _createClass(SubscribeUserAgentServer);
}(_userAgentServer.UserAgentServer);

exports.SubscribeUserAgentServer = SubscribeUserAgentServer;
},{"../transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agents/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _byeUserAgentClient = require("./bye-user-agent-client");

Object.keys(_byeUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _byeUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _byeUserAgentClient[key];
    }
  });
});

var _byeUserAgentServer = require("./bye-user-agent-server");

Object.keys(_byeUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _byeUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _byeUserAgentServer[key];
    }
  });
});

var _cancelUserAgentClient = require("./cancel-user-agent-client");

Object.keys(_cancelUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cancelUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cancelUserAgentClient[key];
    }
  });
});

var _infoUserAgentClient = require("./info-user-agent-client");

Object.keys(_infoUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _infoUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _infoUserAgentClient[key];
    }
  });
});

var _infoUserAgentServer = require("./info-user-agent-server");

Object.keys(_infoUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _infoUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _infoUserAgentServer[key];
    }
  });
});

var _inviteUserAgentClient = require("./invite-user-agent-client");

Object.keys(_inviteUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviteUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviteUserAgentClient[key];
    }
  });
});

var _inviteUserAgentServer = require("./invite-user-agent-server");

Object.keys(_inviteUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviteUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviteUserAgentServer[key];
    }
  });
});

var _messageUserAgentClient = require("./message-user-agent-client");

Object.keys(_messageUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messageUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messageUserAgentClient[key];
    }
  });
});

var _messageUserAgentServer = require("./message-user-agent-server");

Object.keys(_messageUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messageUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messageUserAgentServer[key];
    }
  });
});

var _notifyUserAgentClient = require("./notify-user-agent-client");

Object.keys(_notifyUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _notifyUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _notifyUserAgentClient[key];
    }
  });
});

var _notifyUserAgentServer = require("./notify-user-agent-server");

Object.keys(_notifyUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _notifyUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _notifyUserAgentServer[key];
    }
  });
});

var _publishUserAgentClient = require("./publish-user-agent-client");

Object.keys(_publishUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publishUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publishUserAgentClient[key];
    }
  });
});

var _prackUserAgentClient = require("./prack-user-agent-client");

Object.keys(_prackUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _prackUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prackUserAgentClient[key];
    }
  });
});

var _prackUserAgentServer = require("./prack-user-agent-server");

Object.keys(_prackUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _prackUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prackUserAgentServer[key];
    }
  });
});

var _reInviteUserAgentClient = require("./re-invite-user-agent-client");

Object.keys(_reInviteUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _reInviteUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _reInviteUserAgentClient[key];
    }
  });
});

var _reInviteUserAgentServer = require("./re-invite-user-agent-server");

Object.keys(_reInviteUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _reInviteUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _reInviteUserAgentServer[key];
    }
  });
});

var _reSubscribeUserAgentClient = require("./re-subscribe-user-agent-client");

Object.keys(_reSubscribeUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _reSubscribeUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _reSubscribeUserAgentClient[key];
    }
  });
});

var _reSubscribeUserAgentServer = require("./re-subscribe-user-agent-server");

Object.keys(_reSubscribeUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _reSubscribeUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _reSubscribeUserAgentServer[key];
    }
  });
});

var _referUserAgentClient = require("./refer-user-agent-client");

Object.keys(_referUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _referUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referUserAgentClient[key];
    }
  });
});

var _referUserAgentServer = require("./refer-user-agent-server");

Object.keys(_referUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _referUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referUserAgentServer[key];
    }
  });
});

var _registerUserAgentClient = require("./register-user-agent-client");

Object.keys(_registerUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registerUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registerUserAgentClient[key];
    }
  });
});

var _registerUserAgentServer = require("./register-user-agent-server");

Object.keys(_registerUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registerUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registerUserAgentServer[key];
    }
  });
});

var _subscribeUserAgentClient = require("./subscribe-user-agent-client");

Object.keys(_subscribeUserAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscribeUserAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscribeUserAgentClient[key];
    }
  });
});

var _subscribeUserAgentServer = require("./subscribe-user-agent-server");

Object.keys(_subscribeUserAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscribeUserAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscribeUserAgentServer[key];
    }
  });
});

var _userAgentClient = require("./user-agent-client");

Object.keys(_userAgentClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentClient[key];
    }
  });
});

var _userAgentServer = require("./user-agent-server");

Object.keys(_userAgentServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentServer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentServer[key];
    }
  });
});
},{"./bye-user-agent-client":"node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js","./bye-user-agent-server":"node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js","./cancel-user-agent-client":"node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js","./info-user-agent-client":"node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js","./info-user-agent-server":"node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js","./invite-user-agent-client":"node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js","./invite-user-agent-server":"node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js","./message-user-agent-client":"node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js","./message-user-agent-server":"node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js","./notify-user-agent-client":"node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js","./notify-user-agent-server":"node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js","./publish-user-agent-client":"node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js","./prack-user-agent-client":"node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js","./prack-user-agent-server":"node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js","./re-invite-user-agent-client":"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js","./re-invite-user-agent-server":"node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js","./re-subscribe-user-agent-client":"node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js","./re-subscribe-user-agent-server":"node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js","./refer-user-agent-client":"node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js","./refer-user-agent-server":"node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js","./register-user-agent-client":"node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js","./register-user-agent-server":"node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js","./subscribe-user-agent-client":"node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js","./subscribe-user-agent-server":"node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js","./user-agent-client":"node_modules/sip.js/lib/core/user-agents/user-agent-client.js","./user-agent-server":"node_modules/sip.js/lib/core/user-agents/user-agent-server.js"}],"node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgentCore = void 0;

var _messages = require("../messages");

var _transactions = require("../transactions");

var _userAgents = require("../user-agents");

var _allowedMethods = require("./allowed-methods");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * This is ported from UA.C.ACCEPTED_BODY_TYPES.
 * FIXME: TODO: Should be configurable/variable.
 */
var acceptedBodyTypes = ["application/sdp", "application/dtmf-relay"];
/**
 * User Agent Core.
 * @remarks
 * Core designates the functions specific to a particular type
 * of SIP entity, i.e., specific to either a stateful or stateless
 * proxy, a user agent or registrar.  All cores, except those for
 * the stateless proxy, are transaction users.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAC Core: The set of processing functions required of a UAC that
 * reside above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAS Core: The set of processing functions required at a UAS that
 * resides above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */

var UserAgentCore = /*#__PURE__*/function () {
  /**
   * Constructor.
   * @param configuration - Configuration.
   * @param delegate - Delegate.
   */
  function UserAgentCore(configuration) {
    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, UserAgentCore);

    /** UACs. */
    this.userAgentClients = new Map();
    /** UASs. */

    this.userAgentServers = new Map();
    this.configuration = configuration;
    this.delegate = delegate;
    this.dialogs = new Map();
    this.subscribers = new Map();
    this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
  }
  /** Destructor. */


  _createClass(UserAgentCore, [{
    key: "dispose",
    value: function dispose() {
      this.reset();
    }
    /** Reset. */

  }, {
    key: "reset",
    value: function reset() {
      this.dialogs.forEach(function (dialog) {
        return dialog.dispose();
      });
      this.dialogs.clear();
      this.subscribers.forEach(function (subscriber) {
        return subscriber.dispose();
      });
      this.subscribers.clear();
      this.userAgentClients.forEach(function (uac) {
        return uac.dispose();
      });
      this.userAgentClients.clear();
      this.userAgentServers.forEach(function (uac) {
        return uac.dispose();
      });
      this.userAgentServers.clear();
    }
    /** Logger factory. */

  }, {
    key: "loggerFactory",
    get: function get() {
      return this.configuration.loggerFactory;
    }
    /** Transport. */

  }, {
    key: "transport",
    get: function get() {
      var transport = this.configuration.transportAccessor();

      if (!transport) {
        throw new Error("Transport undefined.");
      }

      return transport;
    }
    /**
     * Send INVITE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "invite",
    value: function invite(request, delegate) {
      return new _userAgents.InviteUserAgentClient(this, request, delegate);
    }
    /**
     * Send MESSAGE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "message",
    value: function message(request, delegate) {
      return new _userAgents.MessageUserAgentClient(this, request, delegate);
    }
    /**
     * Send PUBLISH.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "publish",
    value: function publish(request, delegate) {
      return new _userAgents.PublishUserAgentClient(this, request, delegate);
    }
    /**
     * Send REGISTER.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "register",
    value: function register(request, delegate) {
      return new _userAgents.RegisterUserAgentClient(this, request, delegate);
    }
    /**
     * Send SUBSCRIBE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "subscribe",
    value: function subscribe(request, delegate) {
      return new _userAgents.SubscribeUserAgentClient(this, request, delegate);
    }
    /**
     * Send a request.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */

  }, {
    key: "request",
    value: function request(_request, delegate) {
      return new _userAgents.UserAgentClient(_transactions.NonInviteClientTransaction, this, _request, delegate);
    }
    /**
     * Outgoing request message factory function.
     * @param method - Method.
     * @param requestURI - Request-URI.
     * @param fromURI - From URI.
     * @param toURI - To URI.
     * @param options - Request options.
     * @param extraHeaders - Extra headers to add.
     * @param body - Message body.
     */

  }, {
    key: "makeOutgoingRequestMessage",
    value: function makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {
      // default values from user agent configuration
      var callIdPrefix = this.configuration.sipjsId;
      var fromDisplayName = this.configuration.displayName;
      var forceRport = this.configuration.viaForceRport;
      var hackViaTcp = this.configuration.hackViaTcp;
      var optionTags = this.configuration.supportedOptionTags.slice();

      if (method === _messages.C.REGISTER) {
        optionTags.push("path", "gruu");
      }

      if (method === _messages.C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
        optionTags.push("gruu");
      }

      var routeSet = this.configuration.routeSet;
      var userAgentString = this.configuration.userAgentHeaderFieldValue;
      var viaHost = this.configuration.viaHost;
      var defaultOptions = {
        callIdPrefix: callIdPrefix,
        forceRport: forceRport,
        fromDisplayName: fromDisplayName,
        hackViaTcp: hackViaTcp,
        optionTags: optionTags,
        routeSet: routeSet,
        userAgentString: userAgentString,
        viaHost: viaHost
      }; // merge provided options with default options

      var requestOptions = Object.assign(Object.assign({}, defaultOptions), options);
      return new _messages.OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
    }
    /**
     * Handle an incoming request message from the transport.
     * @param message - Incoming request message from transport layer.
     */

  }, {
    key: "receiveIncomingRequestFromTransport",
    value: function receiveIncomingRequestFromTransport(message) {
      this.receiveRequestFromTransport(message);
    }
    /**
     * Handle an incoming response message from the transport.
     * @param message - Incoming response message from transport layer.
     */

  }, {
    key: "receiveIncomingResponseFromTransport",
    value: function receiveIncomingResponseFromTransport(message) {
      this.receiveResponseFromTransport(message);
    }
    /**
     * A stateless UAS is a UAS that does not maintain transaction state.
     * It replies to requests normally, but discards any state that would
     * ordinarily be retained by a UAS after a response has been sent.  If a
     * stateless UAS receives a retransmission of a request, it regenerates
     * the response and re-sends it, just as if it were replying to the first
     * instance of the request. A UAS cannot be stateless unless the request
     * processing for that method would always result in the same response
     * if the requests are identical. This rules out stateless registrars,
     * for example.  Stateless UASs do not use a transaction layer; they
     * receive requests directly from the transport layer and send responses
     * directly to the transport layer.
     * https://tools.ietf.org/html/rfc3261#section-8.2.7
     * @param message - Incoming request message to reply to.
     * @param statusCode - Status code to reply with.
     */

  }, {
    key: "replyStateless",
    value: function replyStateless(message, options) {
      var _this = this;

      var userAgent = this.configuration.userAgentHeaderFieldValue;
      var supported = this.configuration.supportedOptionTagsResponse;
      options = Object.assign(Object.assign({}, options), {
        userAgent: userAgent,
        supported: supported
      });
      var response = (0, _messages.constructOutgoingResponse)(message, options);
      this.transport.send(response.message).catch(function (error) {
        // If the transport rejects, it SHOULD reject with a TransportError.
        // But the transport may be external code, so we are careful...
        if (error instanceof Error) {
          _this.logger.error(error.message);
        }

        _this.logger.error("Transport error occurred sending stateless reply to ".concat(message.method, " request.")); // TODO: Currently there is no hook to provide notification that a transport error occurred
        // and throwing would result in an uncaught error (in promise), so we silently eat the error.
        // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.

      });
      return response;
    }
    /**
     * In Section 18.2.1, replace the last paragraph with:
     *
     * Next, the server transport attempts to match the request to a
     * server transaction.  It does so using the matching rules described
     * in Section 17.2.3.  If a matching server transaction is found, the
     * request is passed to that transaction for processing.  If no match
     * is found, the request is passed to the core, which may decide to
     * construct a new server transaction for that request.
     * https://tools.ietf.org/html/rfc6026#section-8.10
     * @param message - Incoming request message from transport layer.
     */

  }, {
    key: "receiveRequestFromTransport",
    value: function receiveRequestFromTransport(message) {
      // When a request is received from the network by the server, it has to
      // be matched to an existing transaction.  This is accomplished in the
      // following manner.
      //
      // The branch parameter in the topmost Via header field of the request
      // is examined.  If it is present and begins with the magic cookie
      // "z9hG4bK", the request was generated by a client transaction
      // compliant to this specification.  Therefore, the branch parameter
      // will be unique across all transactions sent by that client.  The
      // request matches a transaction if:
      //
      //    1. the branch parameter in the request is equal to the one in the
      //       top Via header field of the request that created the
      //       transaction, and
      //
      //    2. the sent-by value in the top Via of the request is equal to the
      //       one in the request that created the transaction, and
      //
      //    3. the method of the request matches the one that created the
      //       transaction, except for ACK, where the method of the request
      //       that created the transaction is INVITE.
      //
      // This matching rule applies to both INVITE and non-INVITE transactions
      // alike.
      //
      //    The sent-by value is used as part of the matching process because
      //    there could be accidental or malicious duplication of branch
      //    parameters from different clients.
      // https://tools.ietf.org/html/rfc3261#section-17.2.3
      var transactionId = message.viaBranch; // FIXME: Currently only using rule 1...

      var uas = this.userAgentServers.get(transactionId); // When receiving an ACK that matches an existing INVITE server
      // transaction and that does not contain a branch parameter containing
      // the magic cookie defined in RFC 3261, the matching transaction MUST
      // be checked to see if it is in the "Accepted" state.  If it is, then
      // the ACK must be passed directly to the transaction user instead of
      // being absorbed by the transaction state machine.  This is necessary
      // as requests from RFC 2543 clients will not include a unique branch
      // parameter, and the mechanisms for calculating the transaction ID from
      // such a request will be the same for both INVITE and ACKs.
      // https://tools.ietf.org/html/rfc6026#section-6
      // Any ACKs received from the network while in the "Accepted" state MUST be
      // passed directly to the TU and not absorbed.
      // https://tools.ietf.org/html/rfc6026#section-7.1

      if (message.method === _messages.C.ACK) {
        if (uas && uas.transaction.state === _transactions.TransactionState.Accepted) {
          if (uas instanceof _userAgents.InviteUserAgentServer) {
            // These are ACKs matching an INVITE server transaction.
            // These should never happen with RFC 3261 compliant user agents
            // (would be a broken ACK to negative final response or something)
            // but is apparently how RFC 2543 user agents do things.
            // We are not currently supporting this case.
            // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
            this.logger.warn("Discarding out of dialog ACK after 2xx response sent on transaction ".concat(transactionId, "."));
            return;
          }
        }
      } // The CANCEL method requests that the TU at the server side cancel a
      // pending transaction.  The TU determines the transaction to be
      // cancelled by taking the CANCEL request, and then assuming that the
      // request method is anything but CANCEL or ACK and applying the
      // transaction matching procedures of Section 17.2.3.  The matching
      // transaction is the one to be cancelled.
      // https://tools.ietf.org/html/rfc3261#section-9.2


      if (message.method === _messages.C.CANCEL) {
        if (uas) {
          // Regardless of the method of the original request, as long as the
          // CANCEL matched an existing transaction, the UAS answers the CANCEL
          // request itself with a 200 (OK) response.
          // https://tools.ietf.org/html/rfc3261#section-9.2
          this.replyStateless(message, {
            statusCode: 200
          }); // If the transaction for the original request still exists, the behavior
          // of the UAS on receiving a CANCEL request depends on whether it has already
          // sent a final response for the original request. If it has, the CANCEL
          // request has no effect on the processing of the original request, no
          // effect on any session state, and no effect on the responses generated
          // for the original request. If the UAS has not issued a final response
          // for the original request, its behavior depends on the method of the
          // original request. If the original request was an INVITE, the UAS
          // SHOULD immediately respond to the INVITE with a 487 (Request
          // Terminated).
          // https://tools.ietf.org/html/rfc3261#section-9.2

          if (uas.transaction instanceof _transactions.InviteServerTransaction && uas.transaction.state === _transactions.TransactionState.Proceeding) {
            if (uas instanceof _userAgents.InviteUserAgentServer) {
              uas.receiveCancel(message);
            } // A CANCEL request has no impact on the processing of
            // transactions with any other method defined in this specification.
            // https://tools.ietf.org/html/rfc3261#section-9.2

          }
        } else {
          // If the UAS did not find a matching transaction for the CANCEL
          // according to the procedure above, it SHOULD respond to the CANCEL
          // with a 481 (Call Leg/Transaction Does Not Exist).
          // https://tools.ietf.org/html/rfc3261#section-9.2
          this.replyStateless(message, {
            statusCode: 481
          });
        }

        return;
      } // If a matching server transaction is found, the request is passed to that
      // transaction for processing.
      // https://tools.ietf.org/html/rfc6026#section-8.10


      if (uas) {
        uas.transaction.receiveRequest(message);
        return;
      } // If no match is found, the request is passed to the core, which may decide to
      // construct a new server transaction for that request.
      // https://tools.ietf.org/html/rfc6026#section-8.10


      this.receiveRequest(message);
      return;
    }
    /**
     * UAC and UAS procedures depend strongly on two factors.  First, based
     * on whether the request or response is inside or outside of a dialog,
     * and second, based on the method of a request.  Dialogs are discussed
     * thoroughly in Section 12; they represent a peer-to-peer relationship
     * between user agents and are established by specific SIP methods, such
     * as INVITE.
     * @param message - Incoming request message.
     */

  }, {
    key: "receiveRequest",
    value: function receiveRequest(message) {
      // 8.2 UAS Behavior
      // UASs SHOULD process the requests in the order of the steps that
      // follow in this section (that is, starting with authentication, then
      // inspecting the method, the header fields, and so on throughout the
      // remainder of this section).
      // https://tools.ietf.org/html/rfc3261#section-8.2
      // 8.2.1 Method Inspection
      // Once a request is authenticated (or authentication is skipped), the
      // UAS MUST inspect the method of the request.  If the UAS recognizes
      // but does not support the method of a request, it MUST generate a 405
      // (Method Not Allowed) response.  Procedures for generating responses
      // are described in Section 8.2.6.  The UAS MUST also add an Allow
      // header field to the 405 (Method Not Allowed) response.  The Allow
      // header field MUST list the set of methods supported by the UAS
      // generating the message.
      // https://tools.ietf.org/html/rfc3261#section-8.2.1
      if (!_allowedMethods.AllowedMethods.includes(message.method)) {
        var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

        this.replyStateless(message, {
          statusCode: 405,
          extraHeaders: [allowHeader]
        });
        return;
      } // 8.2.2 Header Inspection
      // https://tools.ietf.org/html/rfc3261#section-8.2.2


      if (!message.ruri) {
        // FIXME: A request message should always have an ruri
        throw new Error("Request-URI undefined.");
      } // 8.2.2.1 To and Request-URI
      // If the Request-URI uses a scheme not supported by the UAS, it SHOULD
      // reject the request with a 416 (Unsupported URI Scheme) response.
      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1


      if (message.ruri.scheme !== "sip") {
        this.replyStateless(message, {
          statusCode: 416
        });
        return;
      } // 8.2.2.1 To and Request-URI
      // If the Request-URI does not identify an address that the
      // UAS is willing to accept requests for, it SHOULD reject
      // the request with a 404 (Not Found) response.
      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1


      var ruri = message.ruri;

      var ruriMatches = function ruriMatches(uri) {
        return !!uri && uri.user === ruri.user;
      };

      if (!ruriMatches(this.configuration.aor) && !(ruriMatches(this.configuration.contact.uri) || ruriMatches(this.configuration.contact.pubGruu) || ruriMatches(this.configuration.contact.tempGruu))) {
        this.logger.warn("Request-URI does not point to us.");

        if (message.method !== _messages.C.ACK) {
          this.replyStateless(message, {
            statusCode: 404
          });
        }

        return;
      } // 8.2.2.1 To and Request-URI
      // Other potential sources of received Request-URIs include
      // the Contact header fields of requests and responses sent by the UA
      // that establish or refresh dialogs.
      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1


      if (message.method === _messages.C.INVITE) {
        if (!message.hasHeader("Contact")) {
          this.replyStateless(message, {
            statusCode: 400,
            reasonPhrase: "Missing Contact Header"
          });
          return;
        }
      } // 8.2.2.2 Merged Requests
      // If the request has no tag in the To header field, the UAS core MUST
      // check the request against ongoing transactions.  If the From tag,
      // Call-ID, and CSeq exactly match those associated with an ongoing
      // transaction, but the request does not match that transaction (based
      // on the matching rules in Section 17.2.3), the UAS core SHOULD
      // generate a 482 (Loop Detected) response and pass it to the server
      // transaction.
      //
      //    The same request has arrived at the UAS more than once, following
      //    different paths, most likely due to forking.  The UAS processes
      //    the first such request received and responds with a 482 (Loop
      //    Detected) to the rest of them.
      // https://tools.ietf.org/html/rfc3261#section-8.2.2.2


      if (!message.toTag) {
        var transactionId = message.viaBranch;

        if (!this.userAgentServers.has(transactionId)) {
          var mergedRequest = Array.from(this.userAgentServers.values()).some(function (uas) {
            return uas.transaction.request.fromTag === message.fromTag && uas.transaction.request.callId === message.callId && uas.transaction.request.cseq === message.cseq;
          });

          if (mergedRequest) {
            this.replyStateless(message, {
              statusCode: 482
            });
            return;
          }
        }
      } // 8.2.2.3 Require
      // https://tools.ietf.org/html/rfc3261#section-8.2.2.3
      // TODO
      // 8.2.3 Content Processing
      // https://tools.ietf.org/html/rfc3261#section-8.2.3
      // TODO
      // 8.2.4 Applying Extensions
      // https://tools.ietf.org/html/rfc3261#section-8.2.4
      // TODO
      // 8.2.5 Processing the Request
      // Assuming all of the checks in the previous subsections are passed,
      // the UAS processing becomes method-specific.
      // https://tools.ietf.org/html/rfc3261#section-8.2.5
      // The UAS will receive the request from the transaction layer.  If the
      // request has a tag in the To header field, the UAS core computes the
      // dialog identifier corresponding to the request and compares it with
      // existing dialogs.  If there is a match, this is a mid-dialog request.
      // In that case, the UAS first applies the same processing rules for
      // requests outside of a dialog, discussed in Section 8.2.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      if (message.toTag) {
        this.receiveInsideDialogRequest(message);
      } else {
        this.receiveOutsideDialogRequest(message);
      }

      return;
    }
    /**
     * Once a dialog has been established between two UAs, either of them
     * MAY initiate new transactions as needed within the dialog.  The UA
     * sending the request will take the UAC role for the transaction.  The
     * UA receiving the request will take the UAS role.  Note that these may
     * be different roles than the UAs held during the transaction that
     * established the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2
     * @param message - Incoming request message.
     */

  }, {
    key: "receiveInsideDialogRequest",
    value: function receiveInsideDialogRequest(message) {
      // NOTIFY requests are matched to such SUBSCRIBE requests if they
      // contain the same "Call-ID", a "To" header field "tag" parameter that
      // matches the "From" header field "tag" parameter of the SUBSCRIBE
      // request, and the same "Event" header field.  Rules for comparisons of
      // the "Event" header fields are described in Section 8.2.1.
      // https://tools.ietf.org/html/rfc6665#section-4.4.1
      if (message.method === _messages.C.NOTIFY) {
        var event = message.parseHeader("Event");

        if (!event || !event.event) {
          this.replyStateless(message, {
            statusCode: 489
          });
          return;
        } // FIXME: Subscriber id should also matching on event id.


        var subscriberId = message.callId + message.toTag + event.event;
        var subscriber = this.subscribers.get(subscriberId);

        if (subscriber) {
          var uas = new _userAgents.NotifyUserAgentServer(this, message);
          subscriber.onNotify(uas);
          return;
        }
      } // Requests sent within a dialog, as any other requests, are atomic.  If
      // a particular request is accepted by the UAS, all the state changes
      // associated with it are performed.  If the request is rejected, none
      // of the state changes are performed.
      //
      //    Note that some requests, such as INVITEs, affect several pieces of
      //    state.
      //
      // The UAS will receive the request from the transaction layer.  If the
      // request has a tag in the To header field, the UAS core computes the
      // dialog identifier corresponding to the request and compares it with
      // existing dialogs.  If there is a match, this is a mid-dialog request.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      var dialogId = message.callId + message.toTag + message.fromTag;
      var dialog = this.dialogs.get(dialogId);

      if (dialog) {
        // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS
        // You got the question right.
        //
        // And you got the right answer too. :-)
        //
        //   Thanks,
        //   Paul
        //
        // Robert Sparks wrote:
        // > So I've lost track of the question during the musing.
        // >
        // > I _think_ the fundamental question being asked is this:
        // >
        // > Is an endpoint required to reject (with a 481) an OPTIONS request that
        // > arrives with at to-tag but does not match any existing dialog state.
        // > (Assuming some earlier requirement hasn't forced another error code). Or
        // > is it OK if it just sends
        // > a 200 OK anyhow.
        // >
        // > My take on the collection of specs is that its _not_ ok for it to send
        // > the 200 OK anyhow and that it is required to send
        // > the 481. I base this primarily on these sentences from 11.2 in 3261:
        // >
        // >    The response to an OPTIONS is constructed using the standard rules
        // >    for a SIP response as discussed in Section 8.2.6.  The response code
        // >    chosen MUST be the same that would have been chosen had the request
        // >    been an INVITE.
        // >
        // > Did I miss the point of the question?
        // >
        // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:
        // >
        // >> [Including Robert in hopes of getting his insight on this.]
        // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html
        //
        // Requests that do not change in any way the state of a dialog may be
        // received within a dialog (for example, an OPTIONS request).  They are
        // processed as if they had been received outside the dialog.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (message.method === _messages.C.OPTIONS) {
          var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

          var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
          this.replyStateless(message, {
            statusCode: 200,
            extraHeaders: [allowHeader, acceptHeader]
          });
          return;
        } // Pass the incoming request to the dialog for further handling.


        dialog.receiveRequest(message);
        return;
      } // The most important behaviors of a stateless UAS are the following:
      // ...
      // o  A stateless UAS MUST ignore ACK requests.
      // ...
      // https://tools.ietf.org/html/rfc3261#section-8.2.7


      if (message.method === _messages.C.ACK) {
        // If a final response to an INVITE was sent statelessly,
        // the corresponding ACK:
        // - will not match an existing transaction
        // - may have tag in the To header field
        // - not not match any existing dialogs
        // Absorb unmatched ACKs.
        return;
      } // If the request has a tag in the To header field, but the dialog
      // identifier does not match any existing dialogs, the UAS may have
      // crashed and restarted, or it may have received a request for a
      // different (possibly failed) UAS (the UASs can construct the To tags
      // so that a UAS can identify that the tag was for a UAS for which it is
      // providing recovery).  Another possibility is that the incoming
      // request has been simply mis-routed.  Based on the To tag, the UAS MAY
      // either accept or reject the request.  Accepting the request for
      // acceptable To tags provides robustness, so that dialogs can persist
      // even through crashes.  UAs wishing to support this capability must
      // take into consideration some issues such as choosing monotonically
      // increasing CSeq sequence numbers even across reboots, reconstructing
      // the route set, and accepting out-of-range RTP timestamps and sequence
      // numbers.
      //
      // If the UAS wishes to reject the request because it does not wish to
      // recreate the dialog, it MUST respond to the request with a 481
      // (Call/Transaction Does Not Exist) status code and pass that to the
      // server transaction.
      // https://tools.ietf.org/html/rfc3261#section-12.2.2


      this.replyStateless(message, {
        statusCode: 481
      });
      return;
    }
    /**
     * Assuming all of the checks in the previous subsections are passed,
     * the UAS processing becomes method-specific.
     *  https://tools.ietf.org/html/rfc3261#section-8.2.5
     * @param message - Incoming request message.
     */

  }, {
    key: "receiveOutsideDialogRequest",
    value: function receiveOutsideDialogRequest(message) {
      switch (message.method) {
        case _messages.C.ACK:
          // Absorb stray out of dialog ACKs
          break;

        case _messages.C.BYE:
          // If the BYE does not match an existing dialog, the UAS core SHOULD
          // generate a 481 (Call/Transaction Does Not Exist) response and pass
          // that to the server transaction. This rule means that a BYE sent
          // without tags by a UAC will be rejected.
          // https://tools.ietf.org/html/rfc3261#section-15.1.2
          this.replyStateless(message, {
            statusCode: 481
          });
          break;

        case _messages.C.CANCEL:
          throw new Error("Unexpected out of dialog request method ".concat(message.method, "."));
          break;

        case _messages.C.INFO:
          // Use of the INFO method does not constitute a separate dialog usage.
          // INFO messages are always part of, and share the fate of, an invite
          // dialog usage [RFC5057].  INFO messages cannot be sent as part of
          // other dialog usages, or outside an existing dialog.
          // https://tools.ietf.org/html/rfc6086#section-1
          this.replyStateless(message, {
            statusCode: 405
          }); // Should never happen

          break;

        case _messages.C.INVITE:
          // https://tools.ietf.org/html/rfc3261#section-13.3.1
          {
            var uas = new _userAgents.InviteUserAgentServer(this, message);
            this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();
          }
          break;

        case _messages.C.MESSAGE:
          // MESSAGE requests are discouraged inside a dialog.  Implementations
          // are restricted from creating a usage for the purpose of carrying a
          // sequence of MESSAGE requests (though some implementations use it that
          // way, against the standard recommendation).
          // https://tools.ietf.org/html/rfc5057#section-5.3
          {
            var _uas = new _userAgents.MessageUserAgentServer(this, message);

            this.delegate.onMessage ? this.delegate.onMessage(_uas) : _uas.accept();
          }
          break;

        case _messages.C.NOTIFY:
          // Obsoleted by: RFC 6665
          // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,
          // it is the responsibility of the parties defining those mechanisms to
          // ensure that correlation of a NOTIFY message to the corresponding
          // subscription is possible.  Designers of such mechanisms are also
          // warned to make a distinction between sending a NOTIFY message to a
          // subscriber who is aware of the subscription, and sending a NOTIFY
          // message to an unsuspecting node.  The latter behavior is invalid, and
          // MUST receive a "481 Subscription does not exist" response (unless
          // some other 400- or 500-class error code is more applicable), as
          // described in section 3.2.4.  In other words, knowledge of a
          // subscription must exist in both the subscriber and the notifier to be
          // valid, even if installed via a non-SUBSCRIBE mechanism.
          // https://tools.ietf.org/html/rfc3265#section-3.2
          //
          // NOTIFY requests are sent to inform subscribers of changes in state to
          // which the subscriber has a subscription.  Subscriptions are created
          // using the SUBSCRIBE method.  In legacy implementations, it is
          // possible that other means of subscription creation have been used.
          // However, this specification does not allow the creation of
          // subscriptions except through SUBSCRIBE requests and (for backwards-
          // compatibility) REFER requests [RFC3515].
          // https://tools.ietf.org/html/rfc6665#section-3.2
          {
            var _uas2 = new _userAgents.NotifyUserAgentServer(this, message);

            this.delegate.onNotify ? this.delegate.onNotify(_uas2) : _uas2.reject({
              statusCode: 405
            });
          }
          break;

        case _messages.C.OPTIONS:
          // https://tools.ietf.org/html/rfc3261#section-11.2
          {
            var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

            var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
            this.replyStateless(message, {
              statusCode: 200,
              extraHeaders: [allowHeader, acceptHeader]
            });
          }
          break;

        case _messages.C.REFER:
          // https://tools.ietf.org/html/rfc3515#section-2.4.2
          {
            var _uas3 = new _userAgents.ReferUserAgentServer(this, message);

            this.delegate.onRefer ? this.delegate.onRefer(_uas3) : _uas3.reject({
              statusCode: 405
            });
          }
          break;

        case _messages.C.REGISTER:
          // https://tools.ietf.org/html/rfc3261#section-10.3
          {
            var _uas4 = new _userAgents.RegisterUserAgentServer(this, message);

            this.delegate.onRegister ? this.delegate.onRegister(_uas4) : _uas4.reject({
              statusCode: 405
            });
          }
          break;

        case _messages.C.SUBSCRIBE:
          // https://tools.ietf.org/html/rfc6665#section-4.2
          {
            var _uas5 = new _userAgents.SubscribeUserAgentServer(this, message);

            this.delegate.onSubscribe ? this.delegate.onSubscribe(_uas5) : _uas5.reject({
              statusCode: 480
            });
          }
          break;

        default:
          throw new Error("Unexpected out of dialog request method ".concat(message.method, "."));
      }

      return;
    }
    /**
     * Responses are first processed by the transport layer and then passed
     * up to the transaction layer.  The transaction layer performs its
     * processing and then passes the response up to the TU.  The majority
     * of response processing in the TU is method specific.  However, there
     * are some general behaviors independent of the method.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3
     * @param message - Incoming response message from transport layer.
     */

  }, {
    key: "receiveResponseFromTransport",
    value: function receiveResponseFromTransport(message) {
      // 8.1.3.1 Transaction Layer Errors
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
      // Handled by transaction layer callbacks.
      // 8.1.3.2 Unrecognized Responses
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
      // TODO
      // 8.1.3.3 Vias
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.3
      if (message.getHeaders("via").length > 1) {
        this.logger.warn("More than one Via header field present in the response, dropping");
        return;
      } // 8.1.3.4 Processing 3xx Responses
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.4
      // TODO
      // 8.1.3.5 Processing 4xx Responses
      // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
      // TODO
      // When the transport layer in the client receives a response, it has to
      // determine which client transaction will handle the response, so that
      // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
      // branch parameter in the top Via header field is used for this
      // purpose.  A response matches a client transaction under two
      // conditions:
      //
      //    1.  If the response has the same value of the branch parameter in
      //        the top Via header field as the branch parameter in the top
      //        Via header field of the request that created the transaction.
      //
      //    2.  If the method parameter in the CSeq header field matches the
      //        method of the request that created the transaction.  The
      //        method is needed since a CANCEL request constitutes a
      //        different transaction, but shares the same value of the branch
      //        parameter.
      // https://tools.ietf.org/html/rfc3261#section-17.1.3


      var userAgentClientId = message.viaBranch + message.method;
      var userAgentClient = this.userAgentClients.get(userAgentClientId); // The client transport uses the matching procedures of Section
      // 17.1.3 to attempt to match the response to an existing
      // transaction.  If there is a match, the response MUST be passed to
      // that transaction.  Otherwise, any element other than a stateless
      // proxy MUST silently discard the response.
      // https://tools.ietf.org/html/rfc6026#section-8.9

      if (userAgentClient) {
        userAgentClient.transaction.receiveResponse(message);
      } else {
        this.logger.warn("Discarding unmatched ".concat(message.statusCode, " response to ").concat(message.method, " ").concat(userAgentClientId, "."));
      }
    }
  }]);

  return UserAgentCore;
}();

exports.UserAgentCore = UserAgentCore;
},{"../messages":"node_modules/sip.js/lib/core/messages/index.js","../transactions":"node_modules/sip.js/lib/core/transactions/index.js","../user-agents":"node_modules/sip.js/lib/core/user-agents/index.js","./allowed-methods":"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js"}],"node_modules/sip.js/lib/core/user-agent-core/user-agent-core-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/user-agent-core/user-agent-core-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/user-agent-core/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _userAgentCore = require("./user-agent-core");

Object.keys(_userAgentCore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentCore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentCore[key];
    }
  });
});

var _userAgentCoreConfiguration = require("./user-agent-core-configuration");

Object.keys(_userAgentCoreConfiguration).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentCoreConfiguration[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentCoreConfiguration[key];
    }
  });
});

var _userAgentCoreDelegate = require("./user-agent-core-delegate");

Object.keys(_userAgentCoreDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentCoreDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentCoreDelegate[key];
    }
  });
});
},{"./user-agent-core":"node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js","./user-agent-core-configuration":"node_modules/sip.js/lib/core/user-agent-core/user-agent-core-configuration.js","./user-agent-core-delegate":"node_modules/sip.js/lib/core/user-agent-core/user-agent-core-delegate.js"}],"node_modules/sip.js/lib/core/transport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/core/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dialogs = require("./dialogs");

Object.keys(_dialogs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dialogs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dialogs[key];
    }
  });
});

var _exceptions = require("./exceptions");

Object.keys(_exceptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exceptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exceptions[key];
    }
  });
});

var _log = require("./log");

Object.keys(_log).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _log[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _log[key];
    }
  });
});

var _messages = require("./messages");

Object.keys(_messages).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messages[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messages[key];
    }
  });
});

var _session = require("./session");

Object.keys(_session).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _session[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _session[key];
    }
  });
});

var _subscription = require("./subscription");

Object.keys(_subscription).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscription[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscription[key];
    }
  });
});

var _transactions = require("./transactions");

Object.keys(_transactions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transactions[key];
    }
  });
});

var _userAgentCore = require("./user-agent-core");

Object.keys(_userAgentCore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentCore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentCore[key];
    }
  });
});

var _userAgents = require("./user-agents");

Object.keys(_userAgents).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgents[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgents[key];
    }
  });
});

var _timers = require("./timers");

Object.keys(_timers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _timers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _timers[key];
    }
  });
});

var _transport = require("./transport");

Object.keys(_transport).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transport[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transport[key];
    }
  });
});
},{"./dialogs":"node_modules/sip.js/lib/core/dialogs/index.js","./exceptions":"node_modules/sip.js/lib/core/exceptions/index.js","./log":"node_modules/sip.js/lib/core/log/index.js","./messages":"node_modules/sip.js/lib/core/messages/index.js","./session":"node_modules/sip.js/lib/core/session/index.js","./subscription":"node_modules/sip.js/lib/core/subscription/index.js","./transactions":"node_modules/sip.js/lib/core/transactions/index.js","./user-agent-core":"node_modules/sip.js/lib/core/user-agent-core/index.js","./user-agents":"node_modules/sip.js/lib/core/user-agents/index.js","./timers":"node_modules/sip.js/lib/core/timers.js","./transport":"node_modules/sip.js/lib/core/transport.js"}],"node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContentTypeUnsupportedError = void 0;

var _core = require("../../core");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An exception indicating an unsupported content type prevented execution.
 * @public
 */
var ContentTypeUnsupportedError = /*#__PURE__*/function (_Exception) {
  _inherits(ContentTypeUnsupportedError, _Exception);

  var _super = _createSuper(ContentTypeUnsupportedError);

  function ContentTypeUnsupportedError(message) {
    _classCallCheck(this, ContentTypeUnsupportedError);

    return _super.call(this, message ? message : "Unsupported content type.");
  }

  return _createClass(ContentTypeUnsupportedError);
}(_core.Exception);

exports.ContentTypeUnsupportedError = ContentTypeUnsupportedError;
},{"../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/exceptions/request-pending.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RequestPendingError = void 0;

var _core = require("../../core");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An exception indicating an outstanding prior request prevented execution.
 * @public
 */
var RequestPendingError = /*#__PURE__*/function (_Exception) {
  _inherits(RequestPendingError, _Exception);

  var _super = _createSuper(RequestPendingError);

  /** @internal */
  function RequestPendingError(message) {
    _classCallCheck(this, RequestPendingError);

    return _super.call(this, message ? message : "Request pending.");
  }

  return _createClass(RequestPendingError);
}(_core.Exception);

exports.RequestPendingError = RequestPendingError;
},{"../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/exceptions/session-description-handler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionDescriptionHandlerError = void 0;

var _core = require("../../core");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An exception indicating a session description handler error occured.
 * @public
 */
var SessionDescriptionHandlerError = /*#__PURE__*/function (_Exception) {
  _inherits(SessionDescriptionHandlerError, _Exception);

  var _super = _createSuper(SessionDescriptionHandlerError);

  function SessionDescriptionHandlerError(message) {
    _classCallCheck(this, SessionDescriptionHandlerError);

    return _super.call(this, message ? message : "Unspecified session description handler error.");
  }

  return _createClass(SessionDescriptionHandlerError);
}(_core.Exception);

exports.SessionDescriptionHandlerError = SessionDescriptionHandlerError;
},{"../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/exceptions/session-terminated.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionTerminatedError = void 0;

var _core = require("../../core");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An exception indicating the session terminated before the action completed.
 * @public
 */
var SessionTerminatedError = /*#__PURE__*/function (_Exception) {
  _inherits(SessionTerminatedError, _Exception);

  var _super = _createSuper(SessionTerminatedError);

  function SessionTerminatedError() {
    _classCallCheck(this, SessionTerminatedError);

    return _super.call(this, "The session has terminated.");
  }

  return _createClass(SessionTerminatedError);
}(_core.Exception);

exports.SessionTerminatedError = SessionTerminatedError;
},{"../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/exceptions/state-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateTransitionError = void 0;

var _core = require("../../core");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An exception indicating an invalid state transition error occured.
 * @public
 */
var StateTransitionError = /*#__PURE__*/function (_Exception) {
  _inherits(StateTransitionError, _Exception);

  var _super = _createSuper(StateTransitionError);

  function StateTransitionError(message) {
    _classCallCheck(this, StateTransitionError);

    return _super.call(this, message ? message : "An error occurred during state transition.");
  }

  return _createClass(StateTransitionError);
}(_core.Exception);

exports.StateTransitionError = StateTransitionError;
},{"../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/exceptions/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _contentTypeUnsupported = require("./content-type-unsupported");

Object.keys(_contentTypeUnsupported).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _contentTypeUnsupported[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contentTypeUnsupported[key];
    }
  });
});

var _requestPending = require("./request-pending");

Object.keys(_requestPending).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _requestPending[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _requestPending[key];
    }
  });
});

var _sessionDescriptionHandler = require("./session-description-handler");

Object.keys(_sessionDescriptionHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandler[key];
    }
  });
});

var _sessionTerminated = require("./session-terminated");

Object.keys(_sessionTerminated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionTerminated[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionTerminated[key];
    }
  });
});

var _stateTransition = require("./state-transition");

Object.keys(_stateTransition).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stateTransition[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stateTransition[key];
    }
  });
});
},{"./content-type-unsupported":"node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js","./request-pending":"node_modules/sip.js/lib/api/exceptions/request-pending.js","./session-description-handler":"node_modules/sip.js/lib/api/exceptions/session-description-handler.js","./session-terminated":"node_modules/sip.js/lib/api/exceptions/session-terminated.js","./state-transition":"node_modules/sip.js/lib/api/exceptions/state-transition.js"}],"node_modules/sip.js/lib/api/ack.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ack = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A request to confirm a {@link Session} (incoming ACK).
 * @public
 */
var Ack = /*#__PURE__*/function () {
  /** @internal */
  function Ack(incomingAckRequest) {
    _classCallCheck(this, Ack);

    this.incomingAckRequest = incomingAckRequest;
  }
  /** Incoming ACK request message. */


  _createClass(Ack, [{
    key: "request",
    get: function get() {
      return this.incomingAckRequest.message;
    }
  }]);

  return Ack;
}();

exports.Ack = Ack;
},{}],"node_modules/sip.js/lib/api/bye.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bye = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A request to end a {@link Session} (incoming BYE).
 * @public
 */
var Bye = /*#__PURE__*/function () {
  /** @internal */
  function Bye(incomingByeRequest) {
    _classCallCheck(this, Bye);

    this.incomingByeRequest = incomingByeRequest;
  }
  /** Incoming BYE request message. */


  _createClass(Bye, [{
    key: "request",
    get: function get() {
      return this.incomingByeRequest.message;
    }
    /** Accept the request. */

  }, {
    key: "accept",
    value: function accept(options) {
      this.incomingByeRequest.accept(options);
      return Promise.resolve();
    }
    /** Reject the request. */

  }, {
    key: "reject",
    value: function reject(options) {
      this.incomingByeRequest.reject(options);
      return Promise.resolve();
    }
  }]);

  return Bye;
}();

exports.Bye = Bye;
},{}],"node_modules/sip.js/lib/api/emitter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmitterImpl = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * An {@link Emitter} implementation.
 * @internal
 */
var EmitterImpl = /*#__PURE__*/function () {
  function EmitterImpl() {
    _classCallCheck(this, EmitterImpl);

    this.listeners = new Array();
  }
  /**
   * Sets up a function that will be called whenever the target changes.
   * @param listener - Callback function.
   * @param options - An options object that specifies characteristics about the listener.
   *                  If once true, indicates that the listener should be invoked at most once after being added.
   *                  If once true, the listener would be automatically removed when invoked.
   */


  _createClass(EmitterImpl, [{
    key: "addListener",
    value: function addListener(listener, options) {
      var _this = this;

      var onceWrapper = function onceWrapper(data) {
        _this.removeListener(onceWrapper);

        listener(data);
      };

      (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);
    }
    /**
     * Emit change.
     * @param data - Data to emit.
     */

  }, {
    key: "emit",
    value: function emit(data) {
      this.listeners.slice().forEach(function (listener) {
        return listener(data);
      });
    }
    /**
     * Removes all listeners previously registered with addListener.
     */

  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this.listeners = [];
    }
    /**
     * Removes a listener previously registered with addListener.
     * @param listener - Callback function.
     */

  }, {
    key: "removeListener",
    value: function removeListener(listener) {
      this.listeners = this.listeners.filter(function (l) {
        return l !== listener;
      });
    }
    /**
     * Registers a listener.
     * @param listener - Callback function.
     * @deprecated Use addListener.
     */

  }, {
    key: "on",
    value: function on(listener) {
      return this.addListener(listener);
    }
    /**
     * Unregisters a listener.
     * @param listener - Callback function.
     * @deprecated Use removeListener.
     */

  }, {
    key: "off",
    value: function off(listener) {
      return this.removeListener(listener);
    }
    /**
     * Registers a listener then unregisters the listener after one event emission.
     * @param listener - Callback function.
     * @deprecated Use addListener.
     */

  }, {
    key: "once",
    value: function once(listener) {
      return this.addListener(listener, {
        once: true
      });
    }
  }]);

  return EmitterImpl;
}();

exports.EmitterImpl = EmitterImpl;
},{}],"node_modules/sip.js/lib/api/info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Info = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * An exchange of information (incoming INFO).
 * @public
 */
var Info = /*#__PURE__*/function () {
  /** @internal */
  function Info(incomingInfoRequest) {
    _classCallCheck(this, Info);

    this.incomingInfoRequest = incomingInfoRequest;
  }
  /** Incoming MESSAGE request message. */


  _createClass(Info, [{
    key: "request",
    get: function get() {
      return this.incomingInfoRequest.message;
    }
    /** Accept the request. */

  }, {
    key: "accept",
    value: function accept(options) {
      this.incomingInfoRequest.accept(options);
      return Promise.resolve();
    }
    /** Reject the request. */

  }, {
    key: "reject",
    value: function reject(options) {
      this.incomingInfoRequest.reject(options);
      return Promise.resolve();
    }
  }]);

  return Info;
}();

exports.Info = Info;
},{}],"node_modules/sip.js/lib/api/invitation-accept-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/invitation-progress-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/invitation-reject-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/message.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Message = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A received message (incoming MESSAGE).
 * @public
 */
var Message = /*#__PURE__*/function () {
  /** @internal */
  function Message(incomingMessageRequest) {
    _classCallCheck(this, Message);

    this.incomingMessageRequest = incomingMessageRequest;
  }
  /** Incoming MESSAGE request message. */


  _createClass(Message, [{
    key: "request",
    get: function get() {
      return this.incomingMessageRequest.message;
    }
    /** Accept the request. */

  }, {
    key: "accept",
    value: function accept(options) {
      this.incomingMessageRequest.accept(options);
      return Promise.resolve();
    }
    /** Reject the request. */

  }, {
    key: "reject",
    value: function reject(options) {
      this.incomingMessageRequest.reject(options);
      return Promise.resolve();
    }
  }]);

  return Message;
}();

exports.Message = Message;
},{}],"node_modules/sip.js/lib/api/notification.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Notification = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A notification of an event (incoming NOTIFY).
 * @public
 */
var Notification = /*#__PURE__*/function () {
  /** @internal */
  function Notification(incomingNotifyRequest) {
    _classCallCheck(this, Notification);

    this.incomingNotifyRequest = incomingNotifyRequest;
  }
  /** Incoming NOTIFY request message. */


  _createClass(Notification, [{
    key: "request",
    get: function get() {
      return this.incomingNotifyRequest.message;
    }
    /** Accept the request. */

  }, {
    key: "accept",
    value: function accept(options) {
      this.incomingNotifyRequest.accept(options);
      return Promise.resolve();
    }
    /** Reject the request. */

  }, {
    key: "reject",
    value: function reject(options) {
      this.incomingNotifyRequest.reject(options);
      return Promise.resolve();
    }
  }]);

  return Notification;
}();

exports.Notification = Notification;
},{}],"node_modules/sip.js/lib/api/referral.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Referral = void 0;

var _core = require("../core");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A request to establish a {@link Session} elsewhere (incoming REFER).
 * @public
 */
var Referral = /*#__PURE__*/function () {
  /** @internal */
  function Referral(incomingReferRequest, session) {
    _classCallCheck(this, Referral);

    this.incomingReferRequest = incomingReferRequest;
    this.session = session;
  }

  _createClass(Referral, [{
    key: "referTo",
    get: function get() {
      var referTo = this.incomingReferRequest.message.parseHeader("refer-to");

      if (!(referTo instanceof _core.NameAddrHeader)) {
        throw new Error("Failed to parse Refer-To header.");
      }

      return referTo;
    }
  }, {
    key: "referredBy",
    get: function get() {
      return this.incomingReferRequest.message.getHeader("referred-by");
    }
  }, {
    key: "replaces",
    get: function get() {
      var value = this.referTo.uri.getHeader("replaces");

      if (value instanceof Array) {
        return value[0];
      }

      return value;
    }
    /** Incoming REFER request message. */

  }, {
    key: "request",
    get: function get() {
      return this.incomingReferRequest.message;
    }
    /** Accept the request. */

  }, {
    key: "accept",
    value: function accept() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        statusCode: 202
      };
      this.incomingReferRequest.accept(options);
      return Promise.resolve();
    }
    /** Reject the request. */

  }, {
    key: "reject",
    value: function reject(options) {
      this.incomingReferRequest.reject(options);
      return Promise.resolve();
    }
    /**
     * Creates an inviter which may be used to send an out of dialog INVITE request.
     *
     * @remarks
     * This a helper method to create an Inviter which will execute the referral
     * of the `Session` which was referred. The appropriate headers are set and
     * the referred `Session` is linked to the new `Session`. Note that only a
     * single instance of the `Inviter` will be created and returned (if called
     * more than once a reference to the same `Inviter` will be returned every time).
     *
     * @param options - Options bucket.
     * @param modifiers - Session description handler modifiers.
     */

  }, {
    key: "makeInviter",
    value: function makeInviter(options) {
      if (this.inviter) {
        return this.inviter;
      }

      var targetURI = this.referTo.uri.clone();
      targetURI.clearHeaders();
      options = options || {};
      var extraHeaders = (options.extraHeaders || []).slice();
      var replaces = this.replaces;

      if (replaces) {
        // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
        extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
      }

      var referredBy = this.referredBy;

      if (referredBy) {
        extraHeaders.push("Referred-By: " + referredBy);
      }

      options.extraHeaders = extraHeaders;
      this.inviter = this.session.userAgent._makeInviter(targetURI, options);
      this.inviter._referred = this.session;
      this.session._referral = this.inviter;
      return this.inviter;
    }
  }]);

  return Referral;
}();

exports.Referral = Referral;
},{"../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/session-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionState = void 0;

/**
 * {@link Session} state.
 *
 * @remarks
 * The {@link Session} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                   ___________________________________________________________
 *                  |  ____________________________________________             |
 *                  | |            ____________________________    |            |
 * Session          | |           |                            v   v            v
 * Constructed -> Initial -> Establishing -> Established -> Terminating -> Terminated
 *                                |               |___________________________^   ^
 *                                |_______________________________________________|
 * ```
 * @public
 */
var SessionState;
exports.SessionState = SessionState;

(function (SessionState) {
  /**
   * If `Inviter`, INVITE not sent yet.
   * If `Invitation`, received INVITE (but no final response sent yet).
   */
  SessionState["Initial"] = "Initial";
  /**
   * If `Inviter`, sent INVITE and waiting for a final response.
   * If `Invitation`, received INVITE and attempting to send 200 final response (but has not sent it yet).
   */

  SessionState["Establishing"] = "Establishing";
  /**
   * If `Inviter`, sent INVITE and received 200 final response and sent ACK.
   * If `Invitation`, received INVITE and sent 200 final response.
   */

  SessionState["Established"] = "Established";
  /**
   * If `Inviter`, sent INVITE, sent CANCEL and now waiting for 487 final response to ACK (or 200 to ACK & BYE).
   * If `Invitation`, received INVITE, sent 200 final response and now waiting on ACK and upon receipt will attempt BYE
   * (as the protocol specification requires, before sending a BYE we must receive the ACK - so we are waiting).
   */

  SessionState["Terminating"] = "Terminating";
  /**
   * If `Inviter`, sent INVITE and received non-200 final response (or sent/received BYE after receiving 200).
   * If `Invitation`, received INVITE and sent non-200 final response (or sent/received BYE after sending 200).
   */

  SessionState["Terminated"] = "Terminated";
})(SessionState || (exports.SessionState = SessionState = {}));
},{}],"node_modules/sip.js/lib/api/session.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Session = void 0;

var _core = require("../core");

var _utils = require("../core/messages/utils");

var _allowedMethods = require("../core/user-agent-core/allowed-methods");

var _ack = require("./ack");

var _bye2 = require("./bye");

var _emitter = require("./emitter");

var _exceptions = require("./exceptions");

var _info2 = require("./info");

var _message2 = require("./message");

var _notification2 = require("./notification");

var _referral = require("./referral");

var _sessionState = require("./session-state");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A session provides real time communication between one or more participants.
 *
 * @remarks
 * The transport behaves in a deterministic manner according to the
 * the state defined in {@link SessionState}.
 * @public
 */
var Session = /*#__PURE__*/function () {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @internal
   */
  function Session(userAgent) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Session);

    /** True if there is an outgoing re-INVITE request outstanding. */
    this.pendingReinvite = false;
    /** True if there is an incoming re-INVITE ACK request outstanding. */

    this.pendingReinviteAck = false;
    /** Session state. */

    this._state = _sessionState.SessionState.Initial;
    this.delegate = options.delegate;
    this._stateEventEmitter = new _emitter.EmitterImpl();
    this._userAgent = userAgent;
  }
  /**
   * Destructor.
   */


  _createClass(Session, [{
    key: "dispose",
    value: function dispose() {
      var _this = this;

      this.logger.log("Session ".concat(this.id, " in state ").concat(this._state, " is being disposed")); // Remove from the user agent's session collection

      delete this.userAgent._sessions[this.id]; // Dispose of dialog media

      if (this._sessionDescriptionHandler) {
        this._sessionDescriptionHandler.close(); // TODO: The SDH needs to remain defined as it will be called after it is closed in cases
        // where an answer/offer arrives while the session is being torn down. There are a variety
        // of circumstances where this can happen - sending a BYE during a re-INVITE for example.
        // The code is currently written such that it lazily makes a new SDH when it needs one
        // and one is not yet defined. Thus if we undefined it here, it will currently make a
        // new one which is out of sync and then never gets cleaned up.
        //
        // The downside of leaving it defined are that calls this closed SDH will continue to be
        // made (think setDescription) and those should/will fail. These failures are handled, but
        // it would be nice to have it all coded up in a way where having an undefined SDH where
        // one is expected throws an error.
        //
        // this._sessionDescriptionHandler = undefined;

      }

      switch (this.state) {
        case _sessionState.SessionState.Initial:
          break;
        // the Inviter/Invitation sub class dispose method handles this case

        case _sessionState.SessionState.Establishing:
          break;
        // the Inviter/Invitation sub class dispose method handles this case

        case _sessionState.SessionState.Established:
          return new Promise(function (resolve) {
            _this._bye({
              // wait for the response to the BYE before resolving
              onAccept: function onAccept() {
                return resolve();
              },
              onRedirect: function onRedirect() {
                return resolve();
              },
              onReject: function onReject() {
                return resolve();
              }
            });
          });

        case _sessionState.SessionState.Terminating:
          break;
        // nothing to be done

        case _sessionState.SessionState.Terminated:
          break;
        // nothing to be done

        default:
          throw new Error("Unknown state.");
      }

      return Promise.resolve();
    }
    /**
     * The asserted identity of the remote user.
     */

  }, {
    key: "assertedIdentity",
    get: function get() {
      return this._assertedIdentity;
    }
    /**
     * The confirmed session dialog.
     */

  }, {
    key: "dialog",
    get: function get() {
      return this._dialog;
    }
    /**
     * A unique identifier for this session.
     */

  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * The session being replace by this one.
     */

  }, {
    key: "replacee",
    get: function get() {
      return this._replacee;
    }
    /**
     * Session description handler.
     * @remarks
     * If `this` is an instance of `Invitation`,
     * `sessionDescriptionHandler` will be defined when the session state changes to "established".
     * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
     * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
     * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
     * `sessionDescriptionHandler` will be defined when the session state changes to "established".
     * Otherwise `undefined`.
     */

  }, {
    key: "sessionDescriptionHandler",
    get: function get() {
      return this._sessionDescriptionHandler;
    }
    /**
     * Session description handler factory.
     */

  }, {
    key: "sessionDescriptionHandlerFactory",
    get: function get() {
      return this.userAgent.configuration.sessionDescriptionHandlerFactory;
    }
    /**
     * SDH modifiers for the initial INVITE transaction.
     * @remarks
     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
     * May be set directly at anytime.
     * May optionally be set via constructor option.
     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
     */

  }, {
    key: "sessionDescriptionHandlerModifiers",
    get: function get() {
      return this._sessionDescriptionHandlerModifiers || [];
    },
    set: function set(modifiers) {
      this._sessionDescriptionHandlerModifiers = modifiers.slice();
    }
    /**
     * SDH options for the initial INVITE transaction.
     * @remarks
     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
     * May be set directly at anytime.
     * May optionally be set via constructor option.
     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().
     */

  }, {
    key: "sessionDescriptionHandlerOptions",
    get: function get() {
      return this._sessionDescriptionHandlerOptions || {};
    },
    set: function set(options) {
      this._sessionDescriptionHandlerOptions = Object.assign({}, options);
    }
    /**
     * SDH modifiers for re-INVITE transactions.
     * @remarks
     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
     * May be set directly at anytime.
     * May optionally be set via constructor option.
     * May optionally be set via options passed to Session.invite().
     */

  }, {
    key: "sessionDescriptionHandlerModifiersReInvite",
    get: function get() {
      return this._sessionDescriptionHandlerModifiersReInvite || [];
    },
    set: function set(modifiers) {
      this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();
    }
    /**
     * SDH options for re-INVITE transactions.
     * @remarks
     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
     * May be set directly at anytime.
     * May optionally be set via constructor option.
     * May optionally be set via options passed to Session.invite().
     */

  }, {
    key: "sessionDescriptionHandlerOptionsReInvite",
    get: function get() {
      return this._sessionDescriptionHandlerOptionsReInvite || {};
    },
    set: function set(options) {
      this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);
    }
    /**
     * Session state.
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * Session state change emitter.
     */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /**
     * The user agent.
     */

  }, {
    key: "userAgent",
    get: function get() {
      return this._userAgent;
    }
    /**
     * End the {@link Session}. Sends a BYE.
     * @param options - Options bucket. See {@link SessionByeOptions} for details.
     */

  }, {
    key: "bye",
    value: function bye() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var message = "Session.bye() may only be called if established session.";

      switch (this.state) {
        case _sessionState.SessionState.Initial:
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if (typeof this.cancel === "function") {
            message += " However Inviter.invite() has not yet been called.";
            message += " Perhaps you should have called Inviter.cancel()?"; // eslint-disable-next-line @typescript-eslint/no-explicit-any
          } else if (typeof this.reject === "function") {
            message += " However Invitation.accept() has not yet been called.";
            message += " Perhaps you should have called Invitation.reject()?";
          }

          break;

        case _sessionState.SessionState.Establishing:
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          if (typeof this.cancel === "function") {
            message += " However a dialog does not yet exist.";
            message += " Perhaps you should have called Inviter.cancel()?"; // eslint-disable-next-line @typescript-eslint/no-explicit-any
          } else if (typeof this.reject === "function") {
            message += " However Invitation.accept() has not yet been called (or not yet resolved).";
            message += " Perhaps you should have called Invitation.reject()?";
          }

          break;

        case _sessionState.SessionState.Established:
          {
            var requestDelegate = options.requestDelegate;
            var requestOptions = this.copyRequestOptions(options.requestOptions);
            return this._bye(requestDelegate, requestOptions);
          }

        case _sessionState.SessionState.Terminating:
          message += " However this session is already terminating."; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          if (typeof this.cancel === "function") {
            message += " Perhaps you have already called Inviter.cancel()?"; // eslint-disable-next-line @typescript-eslint/no-explicit-any
          } else if (typeof this.reject === "function") {
            message += " Perhaps you have already called Session.bye()?";
          }

          break;

        case _sessionState.SessionState.Terminated:
          message += " However this session is already terminated.";
          break;

        default:
          throw new Error("Unknown state");
      }

      this.logger.error(message);
      return Promise.reject(new Error("Invalid session state ".concat(this.state)));
    }
    /**
     * Share {@link Info} with peer. Sends an INFO.
     * @param options - Options bucket. See {@link SessionInfoOptions} for details.
     */

  }, {
    key: "info",
    value: function info() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // guard session state
      if (this.state !== _sessionState.SessionState.Established) {
        var message = "Session.info() may only be called if established session.";
        this.logger.error(message);
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      var requestDelegate = options.requestDelegate;
      var requestOptions = this.copyRequestOptions(options.requestOptions);
      return this._info(requestDelegate, requestOptions);
    }
    /**
     * Renegotiate the session. Sends a re-INVITE.
     * @param options - Options bucket. See {@link SessionInviteOptions} for details.
     */

  }, {
    key: "invite",
    value: function invite() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Session.invite");

      if (this.state !== _sessionState.SessionState.Established) {
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      if (this.pendingReinvite) {
        return Promise.reject(new _exceptions.RequestPendingError("Reinvite in progress. Please wait until complete, then try again."));
      }

      this.pendingReinvite = true; // Modifiers and options for initial INVITE transaction

      if (options.sessionDescriptionHandlerModifiers) {
        this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;
      }

      if (options.sessionDescriptionHandlerOptions) {
        this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;
      }

      var delegate = {
        onAccept: function onAccept(response) {
          // A re-INVITE transaction has an offer/answer [RFC3264] exchange
          // associated with it.  The UAC (User Agent Client) generating a given
          // re-INVITE can act as the offerer or as the answerer.  A UAC willing
          // to act as the offerer includes an offer in the re-INVITE.  The UAS
          // (User Agent Server) then provides an answer in a response to the
          // re-INVITE.  A UAC willing to act as answerer does not include an
          // offer in the re-INVITE.  The UAS then provides an offer in a response
          // to the re-INVITE becoming, thus, the offerer.
          // https://tools.ietf.org/html/rfc6141#section-1
          var body = (0, _core.getBody)(response.message);

          if (!body) {
            // No way to recover, so terminate session and mark as failed.
            _this2.logger.error("Received 2xx response to re-INVITE without a session description");

            _this2.ackAndBye(response, 400, "Missing session description");

            _this2.stateTransition(_sessionState.SessionState.Terminated);

            _this2.pendingReinvite = false;
            return;
          }

          if (options.withoutSdp) {
            // INVITE without SDP - set remote offer and send an answer in the ACK
            var answerOptions = {
              sessionDescriptionHandlerOptions: _this2.sessionDescriptionHandlerOptionsReInvite,
              sessionDescriptionHandlerModifiers: _this2.sessionDescriptionHandlerModifiersReInvite
            };

            _this2.setOfferAndGetAnswer(body, answerOptions).then(function (answerBody) {
              response.ack({
                body: answerBody
              });
            }).catch(function (error) {
              // No way to recover, so terminate session and mark as failed.
              _this2.logger.error("Failed to handle offer in 2xx response to re-INVITE");

              _this2.logger.error(error.message);

              if (_this2.state === _sessionState.SessionState.Terminated) {
                // A BYE should not be sent if already terminated.
                // For example, a BYE may be sent/received while re-INVITE is outstanding.
                response.ack();
              } else {
                _this2.ackAndBye(response, 488, "Bad Media Description");

                _this2.stateTransition(_sessionState.SessionState.Terminated);
              }
            }).then(function () {
              _this2.pendingReinvite = false;

              if (options.requestDelegate && options.requestDelegate.onAccept) {
                options.requestDelegate.onAccept(response);
              }
            });
          } else {
            // INVITE with SDP - set remote answer and send an ACK
            var _answerOptions = {
              sessionDescriptionHandlerOptions: _this2.sessionDescriptionHandlerOptionsReInvite,
              sessionDescriptionHandlerModifiers: _this2.sessionDescriptionHandlerModifiersReInvite
            };

            _this2.setAnswer(body, _answerOptions).then(function () {
              response.ack();
            }).catch(function (error) {
              // No way to recover, so terminate session and mark as failed.
              _this2.logger.error("Failed to handle answer in 2xx response to re-INVITE");

              _this2.logger.error(error.message); // A BYE should only be sent if session is not already terminated.
              // For example, a BYE may be sent/received while re-INVITE is outstanding.
              // The ACK needs to be sent regardless as it was not handled by the transaction.


              if (_this2.state !== _sessionState.SessionState.Terminated) {
                _this2.ackAndBye(response, 488, "Bad Media Description");

                _this2.stateTransition(_sessionState.SessionState.Terminated);
              } else {
                response.ack();
              }
            }).then(function () {
              _this2.pendingReinvite = false;

              if (options.requestDelegate && options.requestDelegate.onAccept) {
                options.requestDelegate.onAccept(response);
              }
            });
          }
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onProgress: function onProgress(response) {
          return;
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onRedirect: function onRedirect(response) {
          return;
        },
        onReject: function onReject(response) {
          _this2.logger.warn("Received a non-2xx response to re-INVITE");

          _this2.pendingReinvite = false;

          if (options.withoutSdp) {
            if (options.requestDelegate && options.requestDelegate.onReject) {
              options.requestDelegate.onReject(response);
            }
          } else {
            _this2.rollbackOffer().catch(function (error) {
              // No way to recover, so terminate session and mark as failed.
              _this2.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");

              _this2.logger.error(error.message); // A BYE should only be sent if session is not already terminated.
              // For example, a BYE may be sent/received while re-INVITE is outstanding.
              // Note that the ACK was already sent by the transaction, so just need to send BYE.


              if (_this2.state !== _sessionState.SessionState.Terminated) {
                if (!_this2.dialog) {
                  throw new Error("Dialog undefined.");
                }

                var extraHeaders = [];
                extraHeaders.push("Reason: " + _this2.getReasonHeaderValue(500, "Internal Server Error"));

                _this2.dialog.bye(undefined, {
                  extraHeaders: extraHeaders
                });

                _this2.stateTransition(_sessionState.SessionState.Terminated);
              }
            }).then(function () {
              if (options.requestDelegate && options.requestDelegate.onReject) {
                options.requestDelegate.onReject(response);
              }
            });
          }
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onTrying: function onTrying(response) {
          return;
        }
      };
      var requestOptions = options.requestOptions || {};
      requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
      requestOptions.extraHeaders.push("Allow: " + _allowedMethods.AllowedMethods.toString());
      requestOptions.extraHeaders.push("Contact: " + this._contact); // Just send an INVITE with no sdp...

      if (options.withoutSdp) {
        if (!this.dialog) {
          this.pendingReinvite = false;
          throw new Error("Dialog undefined.");
        }

        return Promise.resolve(this.dialog.invite(delegate, requestOptions));
      } // Get an offer and send it in an INVITE


      var offerOptions = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
      };
      return this.getOffer(offerOptions).then(function (offerBody) {
        if (!_this2.dialog) {
          _this2.pendingReinvite = false;
          throw new Error("Dialog undefined.");
        }

        requestOptions.body = offerBody;
        return _this2.dialog.invite(delegate, requestOptions);
      }).catch(function (error) {
        _this2.logger.error(error.message);

        _this2.logger.error("Failed to send re-INVITE");

        _this2.pendingReinvite = false;
        throw error;
      });
    }
    /**
     * Deliver a {@link Message}. Sends a MESSAGE.
     * @param options - Options bucket. See {@link SessionMessageOptions} for details.
     */

  }, {
    key: "message",
    value: function message() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // guard session state
      if (this.state !== _sessionState.SessionState.Established) {
        var message = "Session.message() may only be called if established session.";
        this.logger.error(message);
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      var requestDelegate = options.requestDelegate;
      var requestOptions = this.copyRequestOptions(options.requestOptions);
      return this._message(requestDelegate, requestOptions);
    }
    /**
     * Proffer a {@link Referral}. Send a REFER.
     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
     * @param options - Options bucket. See {@link SessionReferOptions} for details.
     */

  }, {
    key: "refer",
    value: function refer(referTo) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // guard session state
      if (this.state !== _sessionState.SessionState.Established) {
        var message = "Session.refer() may only be called if established session.";
        this.logger.error(message);
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      var requestDelegate = options.requestDelegate;
      var requestOptions = this.copyRequestOptions(options.requestOptions);
      requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));
      return this._refer(options.onNotify, requestDelegate, requestOptions);
    }
    /**
     * Send BYE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */

  }, {
    key: "_bye",
    value: function _bye(delegate, options) {
      var _this3 = this;

      // Using core session dialog
      if (!this.dialog) {
        return Promise.reject(new Error("Session dialog undefined."));
      }

      var dialog = this.dialog; // The caller's UA MAY send a BYE for either confirmed or early dialogs,
      // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
      // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
      // BYE on a confirmed dialog until it has received an ACK for its 2xx
      // response or until the server transaction times out.
      // https://tools.ietf.org/html/rfc3261#section-15

      switch (dialog.sessionState) {
        case _core.SessionState.Initial:
          throw new Error("Invalid dialog state ".concat(dialog.sessionState));

        case _core.SessionState.Early:
          // Implementation choice - not sending BYE for early dialogs.
          throw new Error("Invalid dialog state ".concat(dialog.sessionState));

        case _core.SessionState.AckWait:
          {
            // This state only occurs if we are the callee.
            this.stateTransition(_sessionState.SessionState.Terminating); // We're terminating

            return new Promise(function (resolve) {
              dialog.delegate = {
                // When ACK shows up, say BYE.
                onAck: function onAck() {
                  var request = dialog.bye(delegate, options);

                  _this3.stateTransition(_sessionState.SessionState.Terminated);

                  resolve(request);
                  return Promise.resolve();
                },
                // Or the server transaction times out before the ACK arrives.
                onAckTimeout: function onAckTimeout() {
                  var request = dialog.bye(delegate, options);

                  _this3.stateTransition(_sessionState.SessionState.Terminated);

                  resolve(request);
                }
              };
            });
          }

        case _core.SessionState.Confirmed:
          {
            var request = dialog.bye(delegate, options);
            this.stateTransition(_sessionState.SessionState.Terminated);
            return Promise.resolve(request);
          }

        case _core.SessionState.Terminated:
          throw new Error("Invalid dialog state ".concat(dialog.sessionState));

        default:
          throw new Error("Unrecognized state.");
      }
    }
    /**
     * Send INFO.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */

  }, {
    key: "_info",
    value: function _info(delegate, options) {
      // Using core session dialog
      if (!this.dialog) {
        return Promise.reject(new Error("Session dialog undefined."));
      }

      return Promise.resolve(this.dialog.info(delegate, options));
    }
    /**
     * Send MESSAGE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */

  }, {
    key: "_message",
    value: function _message(delegate, options) {
      // Using core session dialog
      if (!this.dialog) {
        return Promise.reject(new Error("Session dialog undefined."));
      }

      return Promise.resolve(this.dialog.message(delegate, options));
    }
    /**
     * Send REFER.
     * @param onNotify - Notification callback.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */

  }, {
    key: "_refer",
    value: function _refer(onNotify, delegate, options) {
      // Using core session dialog
      if (!this.dialog) {
        return Promise.reject(new Error("Session dialog undefined."));
      } // If set, deliver any in-dialog NOTIFY requests here...


      this.onNotify = onNotify;
      return Promise.resolve(this.dialog.refer(delegate, options));
    }
    /**
     * Send ACK and then BYE. There are unrecoverable errors which can occur
     * while handling dialog forming and in-dialog INVITE responses and when
     * they occur we ACK the response and send a BYE.
     * Note that the BYE is sent in the dialog associated with the response
     * which is not necessarily `this.dialog`. And, accordingly, the
     * session state is not transitioned to terminated and session is not closed.
     * @param inviteResponse - The response causing the error.
     * @param statusCode - Status code for he reason phrase.
     * @param reasonPhrase - Reason phrase for the BYE.
     * @internal
     */

  }, {
    key: "ackAndBye",
    value: function ackAndBye(response, statusCode, reasonPhrase) {
      response.ack();
      var extraHeaders = [];

      if (statusCode) {
        extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
      } // Using the dialog session associate with the response (which might not be this.dialog)


      response.session.bye(undefined, {
        extraHeaders: extraHeaders
      });
    }
    /**
     * Handle in dialog ACK request.
     * @internal
     */

  }, {
    key: "onAckRequest",
    value: function onAckRequest(request) {
      var _this4 = this;

      this.logger.log("Session.onAckRequest");

      if (this.state !== _sessionState.SessionState.Established && this.state !== _sessionState.SessionState.Terminating) {
        this.logger.error("ACK received while in state ".concat(this.state, ", dropping request"));
        return Promise.resolve();
      }

      var dialog = this.dialog;

      if (!dialog) {
        throw new Error("Dialog undefined.");
      } // if received answer in ACK.


      var answerOptions = {
        sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,
        sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers
      };

      if (this.delegate && this.delegate.onAck) {
        var ack = new _ack.Ack(request);
        this.delegate.onAck(ack);
      } // reset pending ACK flag


      this.pendingReinviteAck = false;

      switch (dialog.signalingState) {
        case _core.SignalingState.Initial:
          {
            // State should never be reached as first reliable response must have answer/offer.
            // So we must have never has sent an offer.
            this.logger.error("Invalid signaling state ".concat(dialog.signalingState, "."));
            var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
            dialog.bye(undefined, {
              extraHeaders: extraHeaders
            });
            this.stateTransition(_sessionState.SessionState.Terminated);
            return Promise.resolve();
          }

        case _core.SignalingState.Stable:
          {
            // State we should be in.
            // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.
            var body = (0, _core.getBody)(request.message); // If the ACK doesn't have an answer, nothing to be done.

            if (!body) {
              return Promise.resolve();
            }

            if (body.contentDisposition === "render") {
              this._renderbody = body.content;
              this._rendertype = body.contentType;
              return Promise.resolve();
            }

            if (body.contentDisposition !== "session") {
              return Promise.resolve();
            }

            return this.setAnswer(body, answerOptions).catch(function (error) {
              _this4.logger.error(error.message);

              var extraHeaders = ["Reason: " + _this4.getReasonHeaderValue(488, "Bad Media Description")];
              dialog.bye(undefined, {
                extraHeaders: extraHeaders
              });

              _this4.stateTransition(_sessionState.SessionState.Terminated);
            });
          }

        case _core.SignalingState.HaveLocalOffer:
          {
            // State should never be reached as local offer would be answered by this ACK.
            // So we must have received an ACK without an answer.
            this.logger.error("Invalid signaling state ".concat(dialog.signalingState, "."));
            var _extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
            dialog.bye(undefined, {
              extraHeaders: _extraHeaders
            });
            this.stateTransition(_sessionState.SessionState.Terminated);
            return Promise.resolve();
          }

        case _core.SignalingState.HaveRemoteOffer:
          {
            // State should never be reached as remote offer would be answered in first reliable response.
            // So we must have never has sent an answer.
            this.logger.error("Invalid signaling state ".concat(dialog.signalingState, "."));
            var _extraHeaders2 = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
            dialog.bye(undefined, {
              extraHeaders: _extraHeaders2
            });
            this.stateTransition(_sessionState.SessionState.Terminated);
            return Promise.resolve();
          }

        case _core.SignalingState.Closed:
          throw new Error("Invalid signaling state ".concat(dialog.signalingState, "."));

        default:
          throw new Error("Invalid signaling state ".concat(dialog.signalingState, "."));
      }
    }
    /**
     * Handle in dialog BYE request.
     * @internal
     */

  }, {
    key: "onByeRequest",
    value: function onByeRequest(request) {
      this.logger.log("Session.onByeRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("BYE received while in state ".concat(this.state, ", dropping request"));
        return;
      }

      if (this.delegate && this.delegate.onBye) {
        var bye = new _bye2.Bye(request);
        this.delegate.onBye(bye);
      } else {
        request.accept();
      }

      this.stateTransition(_sessionState.SessionState.Terminated);
    }
    /**
     * Handle in dialog INFO request.
     * @internal
     */

  }, {
    key: "onInfoRequest",
    value: function onInfoRequest(request) {
      this.logger.log("Session.onInfoRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("INFO received while in state ".concat(this.state, ", dropping request"));
        return;
      }

      if (this.delegate && this.delegate.onInfo) {
        var info = new _info2.Info(request);
        this.delegate.onInfo(info);
      } else {
        // FIXME: TODO: We should reject request...
        //
        // If a UA receives an INFO request associated with an Info Package that
        // the UA has not indicated willingness to receive, the UA MUST send a
        // 469 (Bad Info Package) response (see Section 11.6), which contains a
        // Recv-Info header field with Info Packages for which the UA is willing
        // to receive INFO requests.
        // https://tools.ietf.org/html/rfc6086#section-4.2.2
        request.accept();
      }
    }
    /**
     * Handle in dialog INVITE request.
     * @internal
     */

  }, {
    key: "onInviteRequest",
    value: function onInviteRequest(request) {
      var _this5 = this;

      this.logger.log("Session.onInviteRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("INVITE received while in state ".concat(this.state, ", dropping request"));
        return;
      } // set pending ACK flag


      this.pendingReinviteAck = true; // TODO: would be nice to have core track and set the Contact header,
      // but currently the session which is setting it is holding onto it.

      var extraHeaders = ["Contact: " + this._contact]; // Handle P-Asserted-Identity

      if (request.message.hasHeader("P-Asserted-Identity")) {
        var header = request.message.getHeader("P-Asserted-Identity");

        if (!header) {
          throw new Error("Header undefined.");
        }

        this._assertedIdentity = _core.Grammar.nameAddrHeaderParse(header);
      }

      var options = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite
      };
      this.generateResponseOfferAnswerInDialog(options).then(function (body) {
        var outgoingResponse = request.accept({
          statusCode: 200,
          extraHeaders: extraHeaders,
          body: body
        });

        if (_this5.delegate && _this5.delegate.onInvite) {
          _this5.delegate.onInvite(request.message, outgoingResponse.message, 200);
        }
      }).catch(function (error) {
        _this5.logger.error(error.message);

        _this5.logger.error("Failed to handle to re-INVITE request");

        if (!_this5.dialog) {
          throw new Error("Dialog undefined.");
        }

        _this5.logger.error(_this5.dialog.signalingState); // If we don't have a local/remote offer...


        if (_this5.dialog.signalingState === _core.SignalingState.Stable) {
          var outgoingResponse = request.reject({
            statusCode: 488
          }); // Not Acceptable Here

          if (_this5.delegate && _this5.delegate.onInvite) {
            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);
          }

          return;
        } // Otherwise rollback


        _this5.rollbackOffer().then(function () {
          var outgoingResponse = request.reject({
            statusCode: 488
          }); // Not Acceptable Here

          if (_this5.delegate && _this5.delegate.onInvite) {
            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);
          }
        }).catch(function (errorRollback) {
          // No way to recover, so terminate session and mark as failed.
          _this5.logger.error(errorRollback.message);

          _this5.logger.error("Failed to rollback offer on re-INVITE request");

          var outgoingResponse = request.reject({
            statusCode: 488
          }); // Not Acceptable Here
          // A BYE should only be sent if session is not already terminated.
          // For example, a BYE may be sent/received while re-INVITE is outstanding.
          // Note that the ACK was already sent by the transaction, so just need to send BYE.

          if (_this5.state !== _sessionState.SessionState.Terminated) {
            if (!_this5.dialog) {
              throw new Error("Dialog undefined.");
            }

            var extraHeadersBye = [];
            extraHeadersBye.push("Reason: " + _this5.getReasonHeaderValue(500, "Internal Server Error"));

            _this5.dialog.bye(undefined, {
              extraHeaders: extraHeaders
            });

            _this5.stateTransition(_sessionState.SessionState.Terminated);
          }

          if (_this5.delegate && _this5.delegate.onInvite) {
            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);
          }
        });
      });
    }
    /**
     * Handle in dialog MESSAGE request.
     * @internal
     */

  }, {
    key: "onMessageRequest",
    value: function onMessageRequest(request) {
      this.logger.log("Session.onMessageRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("MESSAGE received while in state ".concat(this.state, ", dropping request"));
        return;
      }

      if (this.delegate && this.delegate.onMessage) {
        var message = new _message2.Message(request);
        this.delegate.onMessage(message);
      } else {
        request.accept();
      }
    }
    /**
     * Handle in dialog NOTIFY request.
     * @internal
     */

  }, {
    key: "onNotifyRequest",
    value: function onNotifyRequest(request) {
      this.logger.log("Session.onNotifyRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("NOTIFY received while in state ".concat(this.state, ", dropping request"));
        return;
      } // If this a NOTIFY associated with the progress of a REFER,
      // look to delegate handling to the associated callback.


      if (this.onNotify) {
        var notification = new _notification2.Notification(request);
        this.onNotify(notification);
        return;
      } // Otherwise accept the NOTIFY.


      if (this.delegate && this.delegate.onNotify) {
        var _notification = new _notification2.Notification(request);

        this.delegate.onNotify(_notification);
      } else {
        request.accept();
      }
    }
    /**
     * Handle in dialog PRACK request.
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "onPrackRequest",
    value: function onPrackRequest(request) {
      this.logger.log("Session.onPrackRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("PRACK received while in state ".concat(this.state, ", dropping request"));
        return;
      }

      throw new Error("Unimplemented.");
    }
    /**
     * Handle in dialog REFER request.
     * @internal
     */

  }, {
    key: "onReferRequest",
    value: function onReferRequest(request) {
      var _this6 = this;

      this.logger.log("Session.onReferRequest");

      if (this.state !== _sessionState.SessionState.Established) {
        this.logger.error("REFER received while in state ".concat(this.state, ", dropping request"));
        return;
      } // REFER is a SIP request and is constructed as defined in [1].  A REFER
      // request MUST contain exactly one Refer-To header field value.
      // https://tools.ietf.org/html/rfc3515#section-2.4.1


      if (!request.message.hasHeader("refer-to")) {
        this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
        request.reject();
        return;
      }

      var referral = new _referral.Referral(request, this);

      if (this.delegate && this.delegate.onRefer) {
        this.delegate.onRefer(referral);
      } else {
        this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
        referral.accept().then(function () {
          return referral.makeInviter(_this6._referralInviterOptions).invite();
        }).catch(function (error) {
          // FIXME: logging and eating error...
          _this6.logger.error(error.message);
        });
      }
    }
    /**
     * Generate an offer or answer for a response to an INVITE request.
     * If a remote offer was provided in the request, set the remote
     * description and get a local answer. If a remote offer was not
     * provided, generates a local offer.
     * @internal
     */

  }, {
    key: "generateResponseOfferAnswer",
    value: function generateResponseOfferAnswer(request, options) {
      if (this.dialog) {
        return this.generateResponseOfferAnswerInDialog(options);
      }

      var body = (0, _core.getBody)(request.message);

      if (!body || body.contentDisposition !== "session") {
        return this.getOffer(options);
      } else {
        return this.setOfferAndGetAnswer(body, options);
      }
    }
    /**
     * Generate an offer or answer for a response to an INVITE request
     * when a dialog (early or otherwise) has already been established.
     * This method may NOT be called if a dialog has yet to be established.
     * @internal
     */

  }, {
    key: "generateResponseOfferAnswerInDialog",
    value: function generateResponseOfferAnswerInDialog(options) {
      if (!this.dialog) {
        throw new Error("Dialog undefined.");
      }

      switch (this.dialog.signalingState) {
        case _core.SignalingState.Initial:
          return this.getOffer(options);

        case _core.SignalingState.HaveLocalOffer:
          // o  Once the UAS has sent or received an answer to the initial
          // offer, it MUST NOT generate subsequent offers in any responses
          // to the initial INVITE.  This means that a UAS based on this
          // specification alone can never generate subsequent offers until
          // completion of the initial transaction.
          // https://tools.ietf.org/html/rfc3261#section-13.2.1
          return Promise.resolve(undefined);

        case _core.SignalingState.HaveRemoteOffer:
          if (!this.dialog.offer) {
            throw new Error("Session offer undefined in signaling state ".concat(this.dialog.signalingState, "."));
          }

          return this.setOfferAndGetAnswer(this.dialog.offer, options);

        case _core.SignalingState.Stable:
          // o  Once the UAS has sent or received an answer to the initial
          // offer, it MUST NOT generate subsequent offers in any responses
          // to the initial INVITE.  This means that a UAS based on this
          // specification alone can never generate subsequent offers until
          // completion of the initial transaction.
          // https://tools.ietf.org/html/rfc3261#section-13.2.1
          if (this.state !== _sessionState.SessionState.Established) {
            return Promise.resolve(undefined);
          } // In dialog INVITE without offer, get an offer for the response.


          return this.getOffer(options);

        case _core.SignalingState.Closed:
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));

        default:
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));
      }
    }
    /**
     * Get local offer.
     * @internal
     */

  }, {
    key: "getOffer",
    value: function getOffer(options) {
      var _this7 = this;

      var sdh = this.setupSessionDescriptionHandler();
      var sdhOptions = options.sessionDescriptionHandlerOptions;
      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.

      try {
        return sdh.getDescription(sdhOptions, sdhModifiers).then(function (bodyAndContentType) {
          return (0, _core.fromBodyLegacy)(bodyAndContentType);
        }).catch(function (error) {
          // don't trust SDH to reject with Error
          _this7.logger.error("Session.getOffer: SDH getDescription rejected...");

          var e = error instanceof Error ? error : new Error("Session.getOffer unknown error.");

          _this7.logger.error(e.message);

          throw e;
        });
      } catch (error) {
        // don't trust SDH to throw an Error
        this.logger.error("Session.getOffer: SDH getDescription threw...");
        var e = error instanceof Error ? error : new Error(error);
        this.logger.error(e.message);
        return Promise.reject(e);
      }
    }
    /**
     * Rollback local/remote offer.
     * @internal
     */

  }, {
    key: "rollbackOffer",
    value: function rollbackOffer() {
      var _this8 = this;

      var sdh = this.setupSessionDescriptionHandler();

      if (sdh.rollbackDescription === undefined) {
        return Promise.resolve();
      } // This is intentionally written very defensively. Don't trust SDH to behave.


      try {
        return sdh.rollbackDescription().catch(function (error) {
          // don't trust SDH to reject with Error
          _this8.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");

          var e = error instanceof Error ? error : new Error("Session.rollbackOffer unknown error.");

          _this8.logger.error(e.message);

          throw e;
        });
      } catch (error) {
        // don't trust SDH to throw an Error
        this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
        var e = error instanceof Error ? error : new Error(error);
        this.logger.error(e.message);
        return Promise.reject(e);
      }
    }
    /**
     * Set remote answer.
     * @internal
     */

  }, {
    key: "setAnswer",
    value: function setAnswer(answer, options) {
      var _this9 = this;

      var sdh = this.setupSessionDescriptionHandler();
      var sdhOptions = options.sessionDescriptionHandlerOptions;
      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.

      try {
        if (!sdh.hasDescription(answer.contentType)) {
          return Promise.reject(new _exceptions.ContentTypeUnsupportedError());
        }
      } catch (error) {
        this.logger.error("Session.setAnswer: SDH hasDescription threw...");
        var e = error instanceof Error ? error : new Error(error);
        this.logger.error(e.message);
        return Promise.reject(e);
      }

      try {
        return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch(function (error) {
          // don't trust SDH to reject with Error
          _this9.logger.error("Session.setAnswer: SDH setDescription rejected...");

          var e = error instanceof Error ? error : new Error("Session.setAnswer unknown error.");

          _this9.logger.error(e.message);

          throw e;
        });
      } catch (error) {
        // don't trust SDH to throw an Error
        this.logger.error("Session.setAnswer: SDH setDescription threw...");

        var _e = error instanceof Error ? error : new Error(error);

        this.logger.error(_e.message);
        return Promise.reject(_e);
      }
    }
    /**
     * Set remote offer and get local answer.
     * @internal
     */

  }, {
    key: "setOfferAndGetAnswer",
    value: function setOfferAndGetAnswer(offer, options) {
      var _this10 = this;

      var sdh = this.setupSessionDescriptionHandler();
      var sdhOptions = options.sessionDescriptionHandlerOptions;
      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.

      try {
        if (!sdh.hasDescription(offer.contentType)) {
          return Promise.reject(new _exceptions.ContentTypeUnsupportedError());
        }
      } catch (error) {
        this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
        var e = error instanceof Error ? error : new Error(error);
        this.logger.error(e.message);
        return Promise.reject(e);
      }

      try {
        return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(function () {
          return sdh.getDescription(sdhOptions, sdhModifiers);
        }).then(function (bodyAndContentType) {
          return (0, _core.fromBodyLegacy)(bodyAndContentType);
        }).catch(function (error) {
          // don't trust SDH to reject with Error
          _this10.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");

          var e = error instanceof Error ? error : new Error("Session.setOfferAndGetAnswer unknown error.");

          _this10.logger.error(e.message);

          throw e;
        });
      } catch (error) {
        // don't trust SDH to throw an Error
        this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");

        var _e2 = error instanceof Error ? error : new Error(error);

        this.logger.error(_e2.message);
        return Promise.reject(_e2);
      }
    }
    /**
     * SDH for confirmed dialog.
     * @internal
     */

  }, {
    key: "setSessionDescriptionHandler",
    value: function setSessionDescriptionHandler(sdh) {
      if (this._sessionDescriptionHandler) {
        throw new Error("Session description handler defined.");
      }

      this._sessionDescriptionHandler = sdh;
    }
    /**
     * SDH for confirmed dialog.
     * @internal
     */

  }, {
    key: "setupSessionDescriptionHandler",
    value: function setupSessionDescriptionHandler() {
      var _a;

      if (this._sessionDescriptionHandler) {
        return this._sessionDescriptionHandler;
      }

      this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);

      if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
        this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);
      }

      return this._sessionDescriptionHandler;
    }
    /**
     * Transition session state.
     * @internal
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this11 = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this11._state, " to ").concat(newState));
      }; // Validate transition


      switch (this._state) {
        case _sessionState.SessionState.Initial:
          if (newState !== _sessionState.SessionState.Establishing && newState !== _sessionState.SessionState.Established && newState !== _sessionState.SessionState.Terminating && newState !== _sessionState.SessionState.Terminated) {
            invalidTransition();
          }

          break;

        case _sessionState.SessionState.Establishing:
          if (newState !== _sessionState.SessionState.Established && newState !== _sessionState.SessionState.Terminating && newState !== _sessionState.SessionState.Terminated) {
            invalidTransition();
          }

          break;

        case _sessionState.SessionState.Established:
          if (newState !== _sessionState.SessionState.Terminating && newState !== _sessionState.SessionState.Terminated) {
            invalidTransition();
          }

          break;

        case _sessionState.SessionState.Terminating:
          if (newState !== _sessionState.SessionState.Terminated) {
            invalidTransition();
          }

          break;

        case _sessionState.SessionState.Terminated:
          invalidTransition();
          break;

        default:
          throw new Error("Unrecognized state.");
      } // Transition


      this._state = newState;
      this.logger.log("Session ".concat(this.id, " transitioned to state ").concat(this._state));

      this._stateEventEmitter.emit(this._state); // Dispose


      if (newState === _sessionState.SessionState.Terminated) {
        this.dispose();
      }
    }
  }, {
    key: "copyRequestOptions",
    value: function copyRequestOptions() {
      var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;
      var body = requestOptions.body ? {
        contentDisposition: requestOptions.body.contentDisposition || "render",
        contentType: requestOptions.body.contentType || "text/plain",
        content: requestOptions.body.content || ""
      } : undefined;
      return {
        extraHeaders: extraHeaders,
        body: body
      };
    }
  }, {
    key: "getReasonHeaderValue",
    value: function getReasonHeaderValue(code, reason) {
      var cause = code;
      var text = (0, _utils.getReasonPhrase)(code);

      if (!text && reason) {
        text = reason;
      }

      return "SIP;cause=" + cause + ';text="' + text + '"';
    }
  }, {
    key: "referExtraHeaders",
    value: function referExtraHeaders(referTo) {
      var extraHeaders = [];
      extraHeaders.push("Referred-By: <" + this.userAgent.configuration.uri + ">");
      extraHeaders.push("Contact: " + this._contact);
      extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());
      extraHeaders.push("Refer-To: " + referTo);
      return extraHeaders;
    }
  }, {
    key: "referToString",
    value: function referToString(target) {
      var referTo;

      if (target instanceof _core.URI) {
        // REFER without Replaces (Blind Transfer)
        referTo = target.toString();
      } else {
        // REFER with Replaces (Attended Transfer)
        if (!target.dialog) {
          throw new Error("Dialog undefined.");
        }

        var displayName = target.remoteIdentity.friendlyName;
        var remoteTarget = target.dialog.remoteTarget.toString();
        var callId = target.dialog.callId;
        var remoteTag = target.dialog.remoteTag;
        var localTag = target.dialog.localTag;
        var replaces = encodeURIComponent("".concat(callId, ";to-tag=").concat(remoteTag, ";from-tag=").concat(localTag));
        referTo = "\"".concat(displayName, "\" <").concat(remoteTarget, "?Replaces=").concat(replaces, ">");
      }

      return referTo;
    }
  }]);

  return Session;
}();

exports.Session = Session;
},{"../core":"node_modules/sip.js/lib/core/index.js","../core/messages/utils":"node_modules/sip.js/lib/core/messages/utils.js","../core/user-agent-core/allowed-methods":"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js","./ack":"node_modules/sip.js/lib/api/ack.js","./bye":"node_modules/sip.js/lib/api/bye.js","./emitter":"node_modules/sip.js/lib/api/emitter.js","./exceptions":"node_modules/sip.js/lib/api/exceptions/index.js","./info":"node_modules/sip.js/lib/api/info.js","./message":"node_modules/sip.js/lib/api/message.js","./notification":"node_modules/sip.js/lib/api/notification.js","./referral":"node_modules/sip.js/lib/api/referral.js","./session-state":"node_modules/sip.js/lib/api/session-state.js"}],"node_modules/sip.js/lib/api/user-agent-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgentRegisteredOptionTags = exports.SIPExtension = void 0;

/**
 * SIP extension support level.
 * @public
 */
var SIPExtension;
exports.SIPExtension = SIPExtension;

(function (SIPExtension) {
  SIPExtension["Required"] = "Required";
  SIPExtension["Supported"] = "Supported";
  SIPExtension["Unsupported"] = "Unsupported";
})(SIPExtension || (exports.SIPExtension = SIPExtension = {}));
/**
 * SIP Option Tags
 * @remarks
 * http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
 * @public
 */


var UserAgentRegisteredOptionTags = {
  "100rel": true,
  "199": true,
  answermode: true,
  "early-session": true,
  eventlist: true,
  explicitsub: true,
  "from-change": true,
  "geolocation-http": true,
  "geolocation-sip": true,
  gin: true,
  gruu: true,
  histinfo: true,
  ice: true,
  join: true,
  "multiple-refer": true,
  norefersub: true,
  nosub: true,
  outbound: true,
  path: true,
  policy: true,
  precondition: true,
  pref: true,
  privacy: true,
  "recipient-list-invite": true,
  "recipient-list-message": true,
  "recipient-list-subscribe": true,
  replaces: true,
  "resource-priority": true,
  "sdp-anat": true,
  "sec-agree": true,
  tdialog: true,
  timer: true,
  uui: true // RFC 7433

};
exports.UserAgentRegisteredOptionTags = UserAgentRegisteredOptionTags;
},{}],"node_modules/sip.js/lib/api/invitation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Invitation = void 0;

var _core = require("../core");

var _utils = require("../core/messages/utils");

var _exceptions = require("./exceptions");

var _session = require("./session");

var _sessionState = require("./session-state");

var _userAgentOptions = require("./user-agent-options");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An invitation is an offer to establish a {@link Session} (incoming INVITE).
 * @public
 */
var Invitation = /*#__PURE__*/function (_Session) {
  _inherits(Invitation, _Session);

  var _super = _createSuper(Invitation);

  /** @internal */
  function Invitation(userAgent, incomingInviteRequest) {
    var _this;

    _classCallCheck(this, Invitation);

    _this = _super.call(this, userAgent);
    _this.incomingInviteRequest = incomingInviteRequest;
    /** True if dispose() has been called. */

    _this.disposed = false;
    /** INVITE will be rejected if not accepted within a certain period time. */

    _this.expiresTimer = undefined;
    /** True if this Session has been Terminated due to a CANCEL request. */

    _this.isCanceled = false;
    /** Are reliable provisional responses required or supported. */

    _this.rel100 = "none";
    /** The current RSeq header value. */

    _this.rseq = Math.floor(Math.random() * 10000);
    /** INVITE will be rejected if final response not sent in a certain period time. */

    _this.userNoAnswerTimer = undefined;
    /** True if waiting for a PRACK before sending a 200 Ok. */

    _this.waitingForPrack = false;
    _this.logger = userAgent.getLogger("sip.Invitation");
    var incomingRequestMessage = _this.incomingInviteRequest.message; // Set 100rel if necessary

    var requireHeader = incomingRequestMessage.getHeader("require");

    if (requireHeader && requireHeader.toLowerCase().includes("100rel")) {
      _this.rel100 = "required";
    }

    var supportedHeader = incomingRequestMessage.getHeader("supported");

    if (supportedHeader && supportedHeader.toLowerCase().includes("100rel")) {
      _this.rel100 = "supported";
    } // FIXME: HACK: This is a hack to port an existing behavior.
    // Set the toTag on the incoming request message to the toTag which
    // will be used in the response to the incoming request!!!
    // The behavior being ported appears to be a hack itself,
    // so this is a hack to port a hack. At least one test spec
    // relies on it (which is yet another hack).
    // eslint-disable-next-line @typescript-eslint/no-explicit-any


    incomingRequestMessage.toTag = incomingInviteRequest.toTag;

    if (typeof incomingRequestMessage.toTag !== "string") {
      throw new TypeError("toTag should have been a string.");
    } // The following mapping values are RECOMMENDED:
    // ...
    // 19 no answer from the user              480 Temporarily unavailable
    // https://tools.ietf.org/html/rfc3398#section-7.2.4.1


    _this.userNoAnswerTimer = setTimeout(function () {
      incomingInviteRequest.reject({
        statusCode: 480
      });

      _this.stateTransition(_sessionState.SessionState.Terminated);
    }, _this.userAgent.configuration.noAnswerTimeout ? _this.userAgent.configuration.noAnswerTimeout * 1000 : 60000); // 1. If the request is an INVITE that contains an Expires header
    // field, the UAS core sets a timer for the number of seconds
    // indicated in the header field value.  When the timer fires, the
    // invitation is considered to be expired.  If the invitation
    // expires before the UAS has generated a final response, a 487
    // (Request Terminated) response SHOULD be generated.
    // https://tools.ietf.org/html/rfc3261#section-13.3.1

    if (incomingRequestMessage.hasHeader("expires")) {
      var expires = Number(incomingRequestMessage.getHeader("expires") || 0) * 1000;
      _this.expiresTimer = setTimeout(function () {
        if (_this.state === _sessionState.SessionState.Initial) {
          incomingInviteRequest.reject({
            statusCode: 487
          });

          _this.stateTransition(_sessionState.SessionState.Terminated);
        }
      }, expires);
    } // Session parent properties


    var assertedIdentity = _this.request.getHeader("P-Asserted-Identity");

    if (assertedIdentity) {
      _this._assertedIdentity = _core.Grammar.nameAddrHeaderParse(assertedIdentity);
    }

    _this._contact = _this.userAgent.contact.toString();
    var contentDisposition = incomingRequestMessage.parseHeader("Content-Disposition");

    if (contentDisposition && contentDisposition.type === "render") {
      _this._renderbody = incomingRequestMessage.body;
      _this._rendertype = incomingRequestMessage.getHeader("Content-Type");
    } // Identifier


    _this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag; // Add to the user agent's session collection.

    _this.userAgent._sessions[_this._id] = _assertThisInitialized(_this);
    return _this;
  }
  /**
   * Destructor.
   */


  _createClass(Invitation, [{
    key: "dispose",
    value: function dispose() {
      var _this2 = this;

      // Only run through this once. It can and does get called multiple times
      // depending on the what the sessions state is when first called.
      // For example, if called when "establishing" it will be called again
      // at least once when the session transitions to "terminated".
      // Regardless, running through this more than once is pointless.
      if (this.disposed) {
        return Promise.resolve();
      }

      this.disposed = true; // Clear timers

      if (this.expiresTimer) {
        clearTimeout(this.expiresTimer);
        this.expiresTimer = undefined;
      }

      if (this.userNoAnswerTimer) {
        clearTimeout(this.userNoAnswerTimer);
        this.userNoAnswerTimer = undefined;
      } // If accept() is still waiting for a PRACK, make sure it rejects


      this.prackNeverArrived(); // If the final response for the initial INVITE not yet been sent, reject it

      switch (this.state) {
        case _sessionState.SessionState.Initial:
          return this.reject().then(function () {
            return _get(_getPrototypeOf(Invitation.prototype), "dispose", _this2).call(_this2);
          });

        case _sessionState.SessionState.Establishing:
          return this.reject().then(function () {
            return _get(_getPrototypeOf(Invitation.prototype), "dispose", _this2).call(_this2);
          });

        case _sessionState.SessionState.Established:
          return _get(_getPrototypeOf(Invitation.prototype), "dispose", this).call(this);

        case _sessionState.SessionState.Terminating:
          return _get(_getPrototypeOf(Invitation.prototype), "dispose", this).call(this);

        case _sessionState.SessionState.Terminated:
          return _get(_getPrototypeOf(Invitation.prototype), "dispose", this).call(this);

        default:
          throw new Error("Unknown state.");
      }
    }
    /**
     * If true, a first provisional response after the 100 Trying
     * will be sent automatically. This is false it the UAC required
     * reliable provisional responses (100rel in Require header) or
     * the user agent configuration has specified to not send an
     * initial response, otherwise it is true. The provisional is sent by
     * calling `progress()` without any options.
     */

  }, {
    key: "autoSendAnInitialProvisionalResponse",
    get: function get() {
      return this.rel100 !== "required" && this.userAgent.configuration.sendInitialProvisionalResponse;
    }
    /**
     * Initial incoming INVITE request message body.
     */

  }, {
    key: "body",
    get: function get() {
      return this.incomingInviteRequest.message.body;
    }
    /**
     * The identity of the local user.
     */

  }, {
    key: "localIdentity",
    get: function get() {
      return this.request.to;
    }
    /**
     * The identity of the remote user.
     */

  }, {
    key: "remoteIdentity",
    get: function get() {
      return this.request.from;
    }
    /**
     * Initial incoming INVITE request message.
     */

  }, {
    key: "request",
    get: function get() {
      return this.incomingInviteRequest.message;
    }
    /**
     * Accept the invitation.
     *
     * @remarks
     * Accept the incoming INVITE request to start a Session.
     * Replies to the INVITE request with a 200 Ok response.
     * Resolves once the response sent, otherwise rejects.
     *
     * This method may reject for a variety of reasons including
     * the receipt of a CANCEL request before `accept` is able
     * to construct a response.
     * @param options - Options bucket.
     */

  }, {
    key: "accept",
    value: function accept() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Invitation.accept"); // validate state

      if (this.state !== _sessionState.SessionState.Initial) {
        var error = new Error("Invalid session state ".concat(this.state));
        this.logger.error(error.message);
        return Promise.reject(error);
      } // Modifiers and options for initial INVITE transaction


      if (options.sessionDescriptionHandlerModifiers) {
        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
      }

      if (options.sessionDescriptionHandlerOptions) {
        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
      } // transition state


      this.stateTransition(_sessionState.SessionState.Establishing);
      return this.sendAccept(options) // eslint-disable-next-line @typescript-eslint/no-unused-vars
      .then(function (_ref) {
        var message = _ref.message,
            session = _ref.session;
        session.delegate = {
          onAck: function onAck(ackRequest) {
            return _this3.onAckRequest(ackRequest);
          },
          onAckTimeout: function onAckTimeout() {
            return _this3.onAckTimeout();
          },
          onBye: function onBye(byeRequest) {
            return _this3.onByeRequest(byeRequest);
          },
          onInfo: function onInfo(infoRequest) {
            return _this3.onInfoRequest(infoRequest);
          },
          onInvite: function onInvite(inviteRequest) {
            return _this3.onInviteRequest(inviteRequest);
          },
          onMessage: function onMessage(messageRequest) {
            return _this3.onMessageRequest(messageRequest);
          },
          onNotify: function onNotify(notifyRequest) {
            return _this3.onNotifyRequest(notifyRequest);
          },
          onPrack: function onPrack(prackRequest) {
            return _this3.onPrackRequest(prackRequest);
          },
          onRefer: function onRefer(referRequest) {
            return _this3.onReferRequest(referRequest);
          }
        };
        _this3._dialog = session;

        _this3.stateTransition(_sessionState.SessionState.Established); // TODO: Reconsider this "automagic" send of a BYE to replacee behavior.
        // This behavior has been ported forward from legacy versions.


        if (_this3._replacee) {
          _this3._replacee._bye();
        }
      }).catch(function (error) {
        return _this3.handleResponseError(error);
      });
    }
    /**
     * Indicate progress processing the invitation.
     *
     * @remarks
     * Report progress to the the caller.
     * Replies to the INVITE request with a 1xx provisional response.
     * Resolves once the response sent, otherwise rejects.
     * @param options - Options bucket.
     */

  }, {
    key: "progress",
    value: function progress() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Invitation.progress"); // validate state

      if (this.state !== _sessionState.SessionState.Initial) {
        var error = new Error("Invalid session state ".concat(this.state));
        this.logger.error(error.message);
        return Promise.reject(error);
      } // Ported


      var statusCode = options.statusCode || 180;

      if (statusCode < 100 || statusCode > 199) {
        throw new TypeError("Invalid statusCode: " + statusCode);
      } // Modifiers and options for initial INVITE transaction


      if (options.sessionDescriptionHandlerModifiers) {
        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
      }

      if (options.sessionDescriptionHandlerOptions) {
        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
      } // After the first reliable provisional response for a request has been
      // acknowledged, the UAS MAY send additional reliable provisional
      // responses.  The UAS MUST NOT send a second reliable provisional
      // response until the first is acknowledged.  After the first, it is
      // RECOMMENDED that the UAS not send an additional reliable provisional
      // response until the previous is acknowledged.  The first reliable
      // provisional response receives special treatment because it conveys
      // the initial sequence number.  If additional reliable provisional
      // responses were sent before the first was acknowledged, the UAS could
      // not be certain these were received in order.
      // https://tools.ietf.org/html/rfc3262#section-3


      if (this.waitingForPrack) {
        this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
        return Promise.resolve();
      } // Trying provisional response


      if (options.statusCode === 100) {
        return this.sendProgressTrying().then(function () {
          return;
        }).catch(function (error) {
          return _this4.handleResponseError(error);
        });
      } // Standard provisional response


      if (!(this.rel100 === "required") && !(this.rel100 === "supported" && options.rel100) && !(this.rel100 === "supported" && this.userAgent.configuration.sipExtension100rel === _userAgentOptions.SIPExtension.Required)) {
        return this.sendProgress(options).then(function () {
          return;
        }).catch(function (error) {
          return _this4.handleResponseError(error);
        });
      } // Reliable provisional response


      return this.sendProgressReliableWaitForPrack(options).then(function () {
        return;
      }).catch(function (error) {
        return _this4.handleResponseError(error);
      });
    }
    /**
     * Reject the invitation.
     *
     * @remarks
     * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.
     * Resolves once the response sent, otherwise rejects.
     *
     * The expectation is that this method is used to reject an INVITE request.
     * That is indeed the case - a call to `progress` followed by `reject` is
     * a typical way to "decline" an incoming INVITE request. However it may
     * also be called after calling `accept` (but only before it completes)
     * which will reject the call and cause `accept` to reject.
     * @param options - Options bucket.
     */

  }, {
    key: "reject",
    value: function reject() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Invitation.reject"); // validate state

      if (this.state !== _sessionState.SessionState.Initial && this.state !== _sessionState.SessionState.Establishing) {
        var error = new Error("Invalid session state ".concat(this.state));
        this.logger.error(error.message);
        return Promise.reject(error);
      }

      var statusCode = options.statusCode || 480;
      var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : (0, _utils.getReasonPhrase)(statusCode);
      var extraHeaders = options.extraHeaders || [];

      if (statusCode < 300 || statusCode > 699) {
        throw new TypeError("Invalid statusCode: " + statusCode);
      }

      var body = options.body ? (0, _core.fromBodyLegacy)(options.body) : undefined; // FIXME: Need to redirect to someplace

      statusCode < 400 ? this.incomingInviteRequest.redirect([], {
        statusCode: statusCode,
        reasonPhrase: reasonPhrase,
        extraHeaders: extraHeaders,
        body: body
      }) : this.incomingInviteRequest.reject({
        statusCode: statusCode,
        reasonPhrase: reasonPhrase,
        extraHeaders: extraHeaders,
        body: body
      });
      this.stateTransition(_sessionState.SessionState.Terminated);
      return Promise.resolve();
    }
    /**
     * Handle CANCEL request.
     *
     * @param message - CANCEL message.
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "_onCancel",
    value: function _onCancel(message) {
      this.logger.log("Invitation._onCancel"); // validate state

      if (this.state !== _sessionState.SessionState.Initial && this.state !== _sessionState.SessionState.Establishing) {
        this.logger.error("CANCEL received while in state ".concat(this.state, ", dropping request"));
        return;
      } // flag canceled


      this.isCanceled = true; // reject INVITE with 487 status code

      this.incomingInviteRequest.reject({
        statusCode: 487
      });
      this.stateTransition(_sessionState.SessionState.Terminated);
    }
    /**
     * Helper function to handle offer/answer in a PRACK.
     */

  }, {
    key: "handlePrackOfferAnswer",
    value: function handlePrackOfferAnswer(request) {
      if (!this.dialog) {
        throw new Error("Dialog undefined.");
      } // If the PRACK doesn't have an offer/answer, nothing to be done.


      var body = (0, _core.getBody)(request.message);

      if (!body || body.contentDisposition !== "session") {
        return Promise.resolve(undefined);
      }

      var options = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
      }; // If the UAC receives a reliable provisional response with an offer
      // (this would occur if the UAC sent an INVITE without an offer, in
      // which case the first reliable provisional response will contain the
      // offer), it MUST generate an answer in the PRACK.  If the UAC receives
      // a reliable provisional response with an answer, it MAY generate an
      // additional offer in the PRACK.  If the UAS receives a PRACK with an
      // offer, it MUST place the answer in the 2xx to the PRACK.
      // https://tools.ietf.org/html/rfc3262#section-5

      switch (this.dialog.signalingState) {
        case _core.SignalingState.Initial:
          // State should never be reached as first reliable provisional response must have answer/offer.
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));

        case _core.SignalingState.Stable:
          // Receved answer.
          return this.setAnswer(body, options).then(function () {
            return undefined;
          });

        case _core.SignalingState.HaveLocalOffer:
          // State should never be reached as local offer would be answered by this PRACK
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));

        case _core.SignalingState.HaveRemoteOffer:
          // Received offer, generate answer.
          return this.setOfferAndGetAnswer(body, options);

        case _core.SignalingState.Closed:
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));

        default:
          throw new Error("Invalid signaling state ".concat(this.dialog.signalingState, "."));
      }
    }
    /**
     * A handler for errors which occur while attempting to send 1xx and 2xx responses.
     * In all cases, an attempt is made to reject the request if it is still outstanding.
     * And while there are a variety of things which can go wrong and we log something here
     * for all errors, there are a handful of common exceptions we pay some extra attention to.
     * @param error - The error which occurred.
     */

  }, {
    key: "handleResponseError",
    value: function handleResponseError(error) {
      var statusCode = 480; // "Temporarily Unavailable"
      // Log Error message

      if (error instanceof Error) {
        this.logger.error(error.message);
      } else {
        // We don't actually know what a session description handler implementation might throw our way,
        // and more generally as a last resort catch all, just assume we are getting an "unknown" and log it.
        this.logger.error(error);
      } // Log Exception message


      if (error instanceof _exceptions.ContentTypeUnsupportedError) {
        this.logger.error("A session description handler occurred while sending response (content type unsupported");
        statusCode = 415; // "Unsupported Media Type"
      } else if (error instanceof _exceptions.SessionDescriptionHandlerError) {
        this.logger.error("A session description handler occurred while sending response");
      } else if (error instanceof _exceptions.SessionTerminatedError) {
        this.logger.error("Session ended before response could be formulated and sent (while waiting for PRACK)");
      } else if (error instanceof _core.TransactionStateError) {
        this.logger.error("Session changed state before response could be formulated and sent");
      } // Reject if still in "initial" or "establishing" state.


      if (this.state === _sessionState.SessionState.Initial || this.state === _sessionState.SessionState.Establishing) {
        try {
          this.incomingInviteRequest.reject({
            statusCode: statusCode
          });
          this.stateTransition(_sessionState.SessionState.Terminated);
        } catch (e) {
          this.logger.error("An error occurred attempting to reject the request while handling another error");
          throw e; // This is not a good place to be...
        }
      } // FIXME: TODO:
      // Here we are squelching the throwing of errors due to an race condition.
      // We have an internal race between calling `accept()` and handling an incoming
      // CANCEL request. As there is no good way currently to delegate the handling of
      // these race errors to the caller of `accept()`, we are squelching the throwing
      // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know
      // is a "normal" exceptional condition. While this is a completely reasonable approach,
      // the decision should be left up to the library user. Furthermore, as we are eating
      // ALL errors in this case, we are potentially (likely) hiding "real" errors which occur.
      //
      // Only rethrow error if the session has not been canceled.


      if (this.isCanceled) {
        this.logger.warn("An error occurred while attempting to formulate and send a response to an incoming INVITE." + " However a CANCEL was received and processed while doing so which can (and often does) result" + " in errors occurring as the session terminates in the meantime. Said error is being ignored.");
        return;
      }

      throw error;
    }
    /**
     * Callback for when ACK for a 2xx response is never received.
     * @param session - Session the ACK never arrived for.
     */

  }, {
    key: "onAckTimeout",
    value: function onAckTimeout() {
      this.logger.log("Invitation.onAckTimeout");

      if (!this.dialog) {
        throw new Error("Dialog undefined.");
      }

      this.logger.log("No ACK received for an extended period of time, terminating session");
      this.dialog.bye();
      this.stateTransition(_sessionState.SessionState.Terminated);
    }
    /**
     * A version of `accept` which resolves a session when the 200 Ok response is sent.
     * @param options - Options bucket.
     */

  }, {
    key: "sendAccept",
    value: function sendAccept() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var responseOptions = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
      };
      var extraHeaders = options.extraHeaders || []; // The UAS MAY send a final response to the initial request before
      // having received PRACKs for all unacknowledged reliable provisional
      // responses, unless the final response is 2xx and any of the
      // unacknowledged reliable provisional responses contained a session
      // description.  In that case, it MUST NOT send a final response until
      // those provisional responses are acknowledged.  If the UAS does send a
      // final response when reliable responses are still unacknowledged, it
      // SHOULD NOT continue to retransmit the unacknowledged reliable
      // provisional responses, but it MUST be prepared to process PRACK
      // requests for those outstanding responses.  A UAS MUST NOT send new
      // reliable provisional responses (as opposed to retransmissions of
      // unacknowledged ones) after sending a final response to a request.
      // https://tools.ietf.org/html/rfc3262#section-3

      if (this.waitingForPrack) {
        return this.waitForArrivalOfPrack().then(function () {
          return clearTimeout(_this5.userNoAnswerTimer);
        }) // Ported
        .then(function () {
          return _this5.generateResponseOfferAnswer(_this5.incomingInviteRequest, responseOptions);
        }).then(function (body) {
          return _this5.incomingInviteRequest.accept({
            statusCode: 200,
            body: body,
            extraHeaders: extraHeaders
          });
        });
      }

      clearTimeout(this.userNoAnswerTimer); // Ported

      return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(function (body) {
        return _this5.incomingInviteRequest.accept({
          statusCode: 200,
          body: body,
          extraHeaders: extraHeaders
        });
      });
    }
    /**
     * A version of `progress` which resolves when the provisional response is sent.
     * @param options - Options bucket.
     */

  }, {
    key: "sendProgress",
    value: function sendProgress() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var statusCode = options.statusCode || 180;
      var reasonPhrase = options.reasonPhrase;
      var extraHeaders = (options.extraHeaders || []).slice();
      var body = options.body ? (0, _core.fromBodyLegacy)(options.body) : undefined; // The 183 (Session Progress) response is used to convey information
      // about the progress of the call that is not otherwise classified.  The
      // Reason-Phrase, header fields, or message body MAY be used to convey
      // more details about the call progress.
      // https://tools.ietf.org/html/rfc3261#section-21.1.5
      // It is the de facto industry standard to utilize 183 with SDP to provide "early media".
      // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.

      if (statusCode === 183 && !body) {
        return this.sendProgressWithSDP(options);
      }

      try {
        var progressResponse = this.incomingInviteRequest.progress({
          statusCode: statusCode,
          reasonPhrase: reasonPhrase,
          extraHeaders: extraHeaders,
          body: body
        });
        this._dialog = progressResponse.session;
        return Promise.resolve(progressResponse);
      } catch (error) {
        return Promise.reject(error);
      }
    }
    /**
     * A version of `progress` which resolves when the provisional response with sdp is sent.
     * @param options - Options bucket.
     */

  }, {
    key: "sendProgressWithSDP",
    value: function sendProgressWithSDP() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var responseOptions = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
      };
      var statusCode = options.statusCode || 183;
      var reasonPhrase = options.reasonPhrase;
      var extraHeaders = (options.extraHeaders || []).slice(); // Get an offer/answer and send a reply.

      return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(function (body) {
        return _this6.incomingInviteRequest.progress({
          statusCode: statusCode,
          reasonPhrase: reasonPhrase,
          extraHeaders: extraHeaders,
          body: body
        });
      }).then(function (progressResponse) {
        _this6._dialog = progressResponse.session;
        return progressResponse;
      });
    }
    /**
     * A version of `progress` which resolves when the reliable provisional response is sent.
     * @param options - Options bucket.
     */

  }, {
    key: "sendProgressReliable",
    value: function sendProgressReliable() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      options.extraHeaders = (options.extraHeaders || []).slice();
      options.extraHeaders.push("Require: 100rel");
      options.extraHeaders.push("RSeq: " + Math.floor(Math.random() * 10000));
      return this.sendProgressWithSDP(options);
    }
    /**
     * A version of `progress` which resolves when the reliable provisional response is acknowledged.
     * @param options - Options bucket.
     */

  }, {
    key: "sendProgressReliableWaitForPrack",
    value: function sendProgressReliableWaitForPrack() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var responseOptions = {
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers
      };
      var statusCode = options.statusCode || 183;
      var reasonPhrase = options.reasonPhrase;
      var extraHeaders = (options.extraHeaders || []).slice();
      extraHeaders.push("Require: 100rel");
      extraHeaders.push("RSeq: " + this.rseq++);
      var body;
      return new Promise(function (resolve, reject) {
        _this7.waitingForPrack = true;

        _this7.generateResponseOfferAnswer(_this7.incomingInviteRequest, responseOptions).then(function (offerAnswer) {
          body = offerAnswer;
          return _this7.incomingInviteRequest.progress({
            statusCode: statusCode,
            reasonPhrase: reasonPhrase,
            extraHeaders: extraHeaders,
            body: body
          });
        }).then(function (progressResponse) {
          _this7._dialog = progressResponse.session;
          var prackRequest;
          var prackResponse;
          progressResponse.session.delegate = {
            onPrack: function onPrack(request) {
              prackRequest = request; // eslint-disable-next-line @typescript-eslint/no-use-before-define

              clearTimeout(prackWaitTimeoutTimer); // eslint-disable-next-line @typescript-eslint/no-use-before-define

              clearTimeout(rel1xxRetransmissionTimer);

              if (!_this7.waitingForPrack) {
                return;
              }

              _this7.waitingForPrack = false;

              _this7.handlePrackOfferAnswer(prackRequest).then(function (prackResponseBody) {
                try {
                  prackResponse = prackRequest.accept({
                    statusCode: 200,
                    body: prackResponseBody
                  });

                  _this7.prackArrived();

                  resolve({
                    prackRequest: prackRequest,
                    prackResponse: prackResponse,
                    progressResponse: progressResponse
                  });
                } catch (error) {
                  reject(error);
                }
              }).catch(function (error) {
                return reject(error);
              });
            }
          }; // https://tools.ietf.org/html/rfc3262#section-3

          var prackWaitTimeout = function prackWaitTimeout() {
            if (!_this7.waitingForPrack) {
              return;
            }

            _this7.waitingForPrack = false;

            _this7.logger.warn("No PRACK received, rejecting INVITE."); // eslint-disable-next-line @typescript-eslint/no-use-before-define


            clearTimeout(rel1xxRetransmissionTimer);

            _this7.reject({
              statusCode: 504
            }).then(function () {
              return reject(new _exceptions.SessionTerminatedError());
            }).catch(function (error) {
              return reject(error);
            });
          };

          var prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, _core.Timers.T1 * 64); // https://tools.ietf.org/html/rfc3262#section-3

          var rel1xxRetransmission = function rel1xxRetransmission() {
            try {
              _this7.incomingInviteRequest.progress({
                statusCode: statusCode,
                reasonPhrase: reasonPhrase,
                extraHeaders: extraHeaders,
                body: body
              });
            } catch (error) {
              _this7.waitingForPrack = false;
              reject(error);
              return;
            } // eslint-disable-next-line @typescript-eslint/no-use-before-define


            rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);
          };

          var timeout = _core.Timers.T1;
          var rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);
        }).catch(function (error) {
          _this7.waitingForPrack = false;
          reject(error);
        });
      });
    }
    /**
     * A version of `progress` which resolves when a 100 Trying provisional response is sent.
     */

  }, {
    key: "sendProgressTrying",
    value: function sendProgressTrying() {
      try {
        var progressResponse = this.incomingInviteRequest.trying();
        return Promise.resolve(progressResponse);
      } catch (error) {
        return Promise.reject(error);
      }
    }
    /**
     * When attempting to accept the INVITE, an invitation waits
     * for any outstanding PRACK to arrive before sending the 200 Ok.
     * It will be waiting on this Promise to resolve which lets it know
     * the PRACK has arrived and it may proceed to send the 200 Ok.
     */

  }, {
    key: "waitForArrivalOfPrack",
    value: function waitForArrivalOfPrack() {
      var _this8 = this;

      if (this.waitingForPrackPromise) {
        throw new Error("Already waiting for PRACK");
      }

      this.waitingForPrackPromise = new Promise(function (resolve, reject) {
        _this8.waitingForPrackResolve = resolve;
        _this8.waitingForPrackReject = reject;
      });
      return this.waitingForPrackPromise;
    }
    /**
     * Here we are resolving the promise which in turn will cause
     * the accept to proceed (it may still fail for other reasons, but...).
     */

  }, {
    key: "prackArrived",
    value: function prackArrived() {
      if (this.waitingForPrackResolve) {
        this.waitingForPrackResolve();
      }

      this.waitingForPrackPromise = undefined;
      this.waitingForPrackResolve = undefined;
      this.waitingForPrackReject = undefined;
    }
    /**
     * Here we are rejecting the promise which in turn will cause
     * the accept to fail and the session to transition to "terminated".
     */

  }, {
    key: "prackNeverArrived",
    value: function prackNeverArrived() {
      if (this.waitingForPrackReject) {
        this.waitingForPrackReject(new _exceptions.SessionTerminatedError());
      }

      this.waitingForPrackPromise = undefined;
      this.waitingForPrackResolve = undefined;
      this.waitingForPrackReject = undefined;
    }
  }]);

  return Invitation;
}(_session.Session);

exports.Invitation = Invitation;
},{"../core":"node_modules/sip.js/lib/core/index.js","../core/messages/utils":"node_modules/sip.js/lib/core/messages/utils.js","./exceptions":"node_modules/sip.js/lib/api/exceptions/index.js","./session":"node_modules/sip.js/lib/api/session.js","./session-state":"node_modules/sip.js/lib/api/session-state.js","./user-agent-options":"node_modules/sip.js/lib/api/user-agent-options.js"}],"node_modules/sip.js/lib/api/inviter-cancel-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/inviter-invite-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/inviter-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/inviter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Inviter = void 0;

var _core = require("../core");

var _utils = require("../core/messages/utils");

var _session = require("./session");

var _sessionState = require("./session-state");

var _userAgentOptions = require("./user-agent-options");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * An inviter offers to establish a {@link Session} (outgoing INVITE).
 * @public
 */
var Inviter = /*#__PURE__*/function (_Session) {
  _inherits(Inviter, _Session);

  var _super = _createSuper(Inviter);

  /**
   * Constructs a new instance of the `Inviter` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param options - Options bucket. See {@link InviterOptions} for details.
   */
  function Inviter(userAgent, targetURI) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Inviter);

    _this = _super.call(this, userAgent, options);
    /** True if dispose() has been called. */

    _this.disposed = false;
    /** True if early media use is enabled. */

    _this.earlyMedia = false;
    /** The early media session description handlers. */

    _this.earlyMediaSessionDescriptionHandlers = new Map();
    /** True if cancel() was called. */

    _this.isCanceled = false;
    /** True if initial INVITE without SDP. */

    _this.inviteWithoutSdp = false;
    _this.logger = userAgent.getLogger("sip.Inviter"); // Early media

    _this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : _this.earlyMedia; // From tag

    _this.fromTag = (0, _utils.newTag)(); // Invite without SDP

    _this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : _this.inviteWithoutSdp; // Inviter options (could do better copying these options)

    var inviterOptions = Object.assign({}, options);
    inviterOptions.params = Object.assign({}, options.params); // Anonymous call

    var anonymous = options.anonymous || false; // Contact

    var contact = userAgent.contact.toString({
      anonymous: anonymous,
      // Do not add ;ob in initial forming dialog requests if the
      // registration over the current connection got a GRUU URI.
      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu
    }); // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception
    // which is not something we want our constructor to do. URIs should be passed in as params.
    // URIs

    if (anonymous && userAgent.configuration.uri) {
      inviterOptions.params.fromDisplayName = "Anonymous";
      inviterOptions.params.fromUri = "sip:anonymous@anonymous.invalid";
    }

    var fromURI = userAgent.userAgentCore.configuration.aor;

    if (inviterOptions.params.fromUri) {
      fromURI = typeof inviterOptions.params.fromUri === "string" ? _core.Grammar.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;
    }

    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + inviterOptions.params.fromUri);
    }

    var toURI = targetURI;

    if (inviterOptions.params.toUri) {
      toURI = typeof inviterOptions.params.toUri === "string" ? _core.Grammar.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;
    }

    if (!toURI) {
      throw new TypeError("Invalid to URI: " + inviterOptions.params.toUri);
    } // Params


    var messageOptions = Object.assign({}, inviterOptions.params);
    messageOptions.fromTag = _this.fromTag; // Extra headers

    var extraHeaders = (inviterOptions.extraHeaders || []).slice();

    if (anonymous && userAgent.configuration.uri) {
      extraHeaders.push("P-Preferred-Identity: " + userAgent.configuration.uri.toString());
      extraHeaders.push("Privacy: id");
    }

    extraHeaders.push("Contact: " + contact);
    extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString());

    if (userAgent.configuration.sipExtension100rel === _userAgentOptions.SIPExtension.Required) {
      extraHeaders.push("Require: 100rel");
    }

    if (userAgent.configuration.sipExtensionReplaces === _userAgentOptions.SIPExtension.Required) {
      extraHeaders.push("Require: replaces");
    }

    inviterOptions.extraHeaders = extraHeaders; // Body

    var body = undefined; // Make initial outgoing request message

    _this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(_core.C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body); // Session parent properties

    _this._contact = contact;
    _this._referralInviterOptions = inviterOptions;
    _this._renderbody = options.renderbody;
    _this._rendertype = options.rendertype; // Modifiers and options for initial INVITE transaction

    if (options.sessionDescriptionHandlerModifiers) {
      _this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
    }

    if (options.sessionDescriptionHandlerOptions) {
      _this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
    } // Modifiers and options for re-INVITE transactions


    if (options.sessionDescriptionHandlerModifiersReInvite) {
      _this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;
    }

    if (options.sessionDescriptionHandlerOptionsReInvite) {
      _this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;
    } // Identifier


    _this._id = _this.outgoingRequestMessage.callId + _this.fromTag; // Add to the user agent's session collection.

    _this.userAgent._sessions[_this._id] = _assertThisInitialized(_this);
    return _this;
  }
  /**
   * Destructor.
   */


  _createClass(Inviter, [{
    key: "dispose",
    value: function dispose() {
      var _this2 = this;

      // Only run through this once. It can and does get called multiple times
      // depending on the what the sessions state is when first called.
      // For example, if called when "establishing" it will be called again
      // at least once when the session transitions to "terminated".
      // Regardless, running through this more than once is pointless.
      if (this.disposed) {
        return Promise.resolve();
      }

      this.disposed = true; // Dispose of early dialog media

      this.disposeEarlyMedia(); // If the final response for the initial INVITE not yet been received, cancel it

      switch (this.state) {
        case _sessionState.SessionState.Initial:
          return this.cancel().then(function () {
            return _get(_getPrototypeOf(Inviter.prototype), "dispose", _this2).call(_this2);
          });

        case _sessionState.SessionState.Establishing:
          return this.cancel().then(function () {
            return _get(_getPrototypeOf(Inviter.prototype), "dispose", _this2).call(_this2);
          });

        case _sessionState.SessionState.Established:
          return _get(_getPrototypeOf(Inviter.prototype), "dispose", this).call(this);

        case _sessionState.SessionState.Terminating:
          return _get(_getPrototypeOf(Inviter.prototype), "dispose", this).call(this);

        case _sessionState.SessionState.Terminated:
          return _get(_getPrototypeOf(Inviter.prototype), "dispose", this).call(this);

        default:
          throw new Error("Unknown state.");
      }
    }
    /**
     * Initial outgoing INVITE request message body.
     */

  }, {
    key: "body",
    get: function get() {
      return this.outgoingRequestMessage.body;
    }
    /**
     * The identity of the local user.
     */

  }, {
    key: "localIdentity",
    get: function get() {
      return this.outgoingRequestMessage.from;
    }
    /**
     * The identity of the remote user.
     */

  }, {
    key: "remoteIdentity",
    get: function get() {
      return this.outgoingRequestMessage.to;
    }
    /**
     * Initial outgoing INVITE request message.
     */

  }, {
    key: "request",
    get: function get() {
      return this.outgoingRequestMessage;
    }
    /**
     * Cancels the INVITE request.
     *
     * @remarks
     * Sends a CANCEL request.
     * Resolves once the response sent, otherwise rejects.
     *
     * After sending a CANCEL request the expectation is that a 487 final response
     * will be received for the INVITE. However a 200 final response to the INVITE
     * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before
     * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect
     * is that this method will terminate the session regardless of the race.
     * @param options - Options bucket.
     */

  }, {
    key: "cancel",
    value: function cancel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Inviter.cancel"); // validate state

      if (this.state !== _sessionState.SessionState.Initial && this.state !== _sessionState.SessionState.Establishing) {
        var error = new Error("Invalid session state ".concat(this.state));
        this.logger.error(error.message);
        return Promise.reject(error);
      } // flag canceled


      this.isCanceled = true; // transition state

      this.stateTransition(_sessionState.SessionState.Terminating); // helper function

      function getCancelReason(code, reason) {
        if (code && code < 200 || code > 699) {
          throw new TypeError("Invalid statusCode: " + code);
        } else if (code) {
          var cause = code;
          var text = (0, _utils.getReasonPhrase)(code) || reason;
          return "SIP;cause=" + cause + ';text="' + text + '"';
        }
      }

      if (this.outgoingInviteRequest) {
        // the CANCEL may not be respected by peer(s), so don't transition to terminated
        var cancelReason;

        if (options.statusCode && options.reasonPhrase) {
          cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);
        }

        this.outgoingInviteRequest.cancel(cancelReason, options);
      } else {
        this.logger.warn("Canceled session before INVITE was sent");
        this.stateTransition(_sessionState.SessionState.Terminated);
      }

      return Promise.resolve();
    }
    /**
     * Sends the INVITE request.
     *
     * @remarks
     * TLDR...
     *  1) Only one offer/answer exchange permitted during initial INVITE.
     *  2) No "early media" if the initial offer is in an INVITE (default behavior).
     *  3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
     *
     * 1) Only one offer/answer exchange permitted during initial INVITE.
     *
     * Our implementation replaces the following bullet point...
     *
     * o  After having sent or received an answer to the first offer, the
     *    UAC MAY generate subsequent offers in requests based on rules
     *    specified for that method, but only if it has received answers
     *    to any previous offers, and has not sent any offers to which it
     *    hasn't gotten an answer.
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     *
     * ...with...
     *
     * o  After having sent or received an answer to the first offer, the
     *    UAC MUST NOT generate subsequent offers in requests based on rules
     *    specified for that method.
     *
     * ...which in combination with this bullet point...
     *
     * o  Once the UAS has sent or received an answer to the initial
     *    offer, it MUST NOT generate subsequent offers in any responses
     *    to the initial INVITE.  This means that a UAS based on this
     *    specification alone can never generate subsequent offers until
     *    completion of the initial transaction.
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     *
     * ...ensures that EXACTLY ONE offer/answer exchange will occur
     * during an initial out of dialog INVITE request made by our UAC.
     *
     *
     * 2) No "early media" if the initial offer is in an INVITE (default behavior).
     *
     * While our implementation adheres to the following bullet point...
     *
     * o  If the initial offer is in an INVITE, the answer MUST be in a
     *    reliable non-failure message from UAS back to UAC which is
     *    correlated to that INVITE.  For this specification, that is
     *    only the final 2xx response to that INVITE.  That same exact
     *    answer MAY also be placed in any provisional responses sent
     *    prior to the answer.  The UAC MUST treat the first session
     *    description it receives as the answer, and MUST ignore any
     *    session descriptions in subsequent responses to the initial
     *    INVITE.
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     *
     * We have made the following implementation decision with regard to early media...
     *
     * o  If the initial offer is in the INVITE, the answer from the
     *    UAS back to the UAC will establish a media session only
     *    only after the final 2xx response to that INVITE is received.
     *
     * The reason for this decision is rooted in a restriction currently
     * inherent in WebRTC. Specifically, while a SIP INVITE request with an
     * initial offer may fork resulting in more than one provisional answer,
     * there is currently no easy/good way to to "fork" an offer generated
     * by a peer connection. In particular, a WebRTC offer currently may only
     * be matched with one answer and we have no good way to know which
     * "provisional answer" is going to be the "final answer". So we have
     * decided to punt and not create any "early media" sessions in this case.
     *
     * The upshot is that if you want "early media", you must not put the
     * initial offer in the INVITE. Instead, force the UAS to provide the
     * initial offer by sending an INVITE without an offer. In the WebRTC
     * case this allows us to create a unique peer connection with a unique
     * answer for every provisional offer with "early media" on all of them.
     *
     *
     * 3) If "early media" and the initial offer is in an INVITE, no INVITE forking.
     *
     * The default behavior may be altered and "early media" utilized if the
     * initial offer is in the an INVITE by setting the `earlyMedia` options.
     * However in that case the INVITE request MUST NOT fork. This allows for
     * "early media" in environments where the forking behavior of the SIP
     * servers being utilized is configured to disallow forking.
     */

  }, {
    key: "invite",
    value: function invite() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.logger.log("Inviter.invite"); // validate state

      if (this.state !== _sessionState.SessionState.Initial) {
        // re-invite
        return _get(_getPrototypeOf(Inviter.prototype), "invite", this).call(this, options);
      } // Modifiers and options for initial INVITE transaction


      if (options.sessionDescriptionHandlerModifiers) {
        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;
      }

      if (options.sessionDescriptionHandlerOptions) {
        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;
      } // just send an INVITE with no sdp...


      if (options.withoutSdp || this.inviteWithoutSdp) {
        if (this._renderbody && this._rendertype) {
          this.outgoingRequestMessage.body = {
            contentType: this._rendertype,
            body: this._renderbody
          };
        } // transition state


        this.stateTransition(_sessionState.SessionState.Establishing);
        return Promise.resolve(this.sendInvite(options));
      } // get an offer and send it in an INVITE


      var offerOptions = {
        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
      };
      return this.getOffer(offerOptions).then(function (body) {
        _this3.outgoingRequestMessage.body = {
          body: body.content,
          contentType: body.contentType
        }; // transition state

        _this3.stateTransition(_sessionState.SessionState.Establishing);

        return _this3.sendInvite(options);
      }).catch(function (error) {
        _this3.logger.log(error.message);

        _this3.stateTransition(_sessionState.SessionState.Terminated);

        throw error;
      });
    }
    /**
     * 13.2.1 Creating the Initial INVITE
     *
     * Since the initial INVITE represents a request outside of a dialog,
     * its construction follows the procedures of Section 8.1.1.  Additional
     * processing is required for the specific case of INVITE.
     *
     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
     * It indicates what methods can be invoked within a dialog, on the UA
     * sending the INVITE, for the duration of the dialog.  For example, a
     * UA capable of receiving INFO requests within a dialog [34] SHOULD
     * include an Allow header field listing the INFO method.
     *
     * A Supported header field (Section 20.37) SHOULD be present in the
     * INVITE.  It enumerates all the extensions understood by the UAC.
     *
     * An Accept (Section 20.1) header field MAY be present in the INVITE.
     * It indicates which Content-Types are acceptable to the UA, in both
     * the response received by it, and in any subsequent requests sent to
     * it within dialogs established by the INVITE.  The Accept header field
     * is especially useful for indicating support of various session
     * description formats.
     *
     * The UAC MAY add an Expires header field (Section 20.19) to limit the
     * validity of the invitation.  If the time indicated in the Expires
     * header field is reached and no final answer for the INVITE has been
     * received, the UAC core SHOULD generate a CANCEL request for the
     * INVITE, as per Section 9.
     *
     * A UAC MAY also find it useful to add, among others, Subject (Section
     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
     * header fields.  They all contain information related to the INVITE.
     *
     * The UAC MAY choose to add a message body to the INVITE.  Section
     * 8.1.1.10 deals with how to construct the header fields -- Content-
     * Type among others -- needed to describe the message body.
     *
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     */

  }, {
    key: "sendInvite",
    value: function sendInvite() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      //    There are special rules for message bodies that contain a session
      //    description - their corresponding Content-Disposition is "session".
      //    SIP uses an offer/answer model where one UA sends a session
      //    description, called the offer, which contains a proposed description
      //    of the session.  The offer indicates the desired communications means
      //    (audio, video, games), parameters of those means (such as codec
      //    types) and addresses for receiving media from the answerer.  The
      //    other UA responds with another session description, called the
      //    answer, which indicates which communications means are accepted, the
      //    parameters that apply to those means, and addresses for receiving
      //    media from the offerer. An offer/answer exchange is within the
      //    context of a dialog, so that if a SIP INVITE results in multiple
      //    dialogs, each is a separate offer/answer exchange.  The offer/answer
      //    model defines restrictions on when offers and answers can be made
      //    (for example, you cannot make a new offer while one is in progress).
      //    This results in restrictions on where the offers and answers can
      //    appear in SIP messages.  In this specification, offers and answers
      //    can only appear in INVITE requests and responses, and ACK.  The usage
      //    of offers and answers is further restricted.  For the initial INVITE
      //    transaction, the rules are:
      //
      //       o  The initial offer MUST be in either an INVITE or, if not there,
      //          in the first reliable non-failure message from the UAS back to
      //          the UAC.  In this specification, that is the final 2xx
      //          response.
      //
      //       o  If the initial offer is in an INVITE, the answer MUST be in a
      //          reliable non-failure message from UAS back to UAC which is
      //          correlated to that INVITE.  For this specification, that is
      //          only the final 2xx response to that INVITE.  That same exact
      //          answer MAY also be placed in any provisional responses sent
      //          prior to the answer.  The UAC MUST treat the first session
      //          description it receives as the answer, and MUST ignore any
      //          session descriptions in subsequent responses to the initial
      //          INVITE.
      //
      //       o  If the initial offer is in the first reliable non-failure
      //          message from the UAS back to UAC, the answer MUST be in the
      //          acknowledgement for that message (in this specification, ACK
      //          for a 2xx response).
      //
      //       o  After having sent or received an answer to the first offer, the
      //          UAC MAY generate subsequent offers in requests based on rules
      //          specified for that method, but only if it has received answers
      //          to any previous offers, and has not sent any offers to which it
      //          hasn't gotten an answer.
      //
      //       o  Once the UAS has sent or received an answer to the initial
      //          offer, it MUST NOT generate subsequent offers in any responses
      //          to the initial INVITE.  This means that a UAS based on this
      //          specification alone can never generate subsequent offers until
      //          completion of the initial transaction.
      //
      // https://tools.ietf.org/html/rfc3261#section-13.2.1
      // 5 The Offer/Answer Model and PRACK
      //
      //    RFC 3261 describes guidelines for the sets of messages in which
      //    offers and answers [3] can appear.  Based on those guidelines, this
      //    extension provides additional opportunities for offer/answer
      //    exchanges.
      //    If the INVITE contained an offer, the UAS MAY generate an answer in a
      //    reliable provisional response (assuming these are supported by the
      //    UAC).  That results in the establishment of the session before
      //    completion of the call.  Similarly, if a reliable provisional
      //    response is the first reliable message sent back to the UAC, and the
      //    INVITE did not contain an offer, one MUST appear in that reliable
      //    provisional response.
      //    If the UAC receives a reliable provisional response with an offer
      //    (this would occur if the UAC sent an INVITE without an offer, in
      //    which case the first reliable provisional response will contain the
      //    offer), it MUST generate an answer in the PRACK.  If the UAC receives
      //    a reliable provisional response with an answer, it MAY generate an
      //    additional offer in the PRACK.  If the UAS receives a PRACK with an
      //    offer, it MUST place the answer in the 2xx to the PRACK.
      //    Once an answer has been sent or received, the UA SHOULD establish the
      //    session based on the parameters of the offer and answer, even if the
      //    original INVITE itself has not been responded to.
      //    If the UAS had placed a session description in any reliable
      //    provisional response that is unacknowledged when the INVITE is
      //    accepted, the UAS MUST delay sending the 2xx until the provisional
      //    response is acknowledged.  Otherwise, the reliability of the 1xx
      //    cannot be guaranteed, and reliability is needed for proper operation
      //    of the offer/answer exchange.
      //    All user agents that support this extension MUST support all
      //    offer/answer exchanges that are possible based on the rules in
      //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK
      //    as requests, and 2xx and reliable 1xx as non-failure reliable
      //    responses.
      //
      // https://tools.ietf.org/html/rfc3262#section-5
      ////
      // The Offer/Answer Model Implementation
      //
      // The offer/answer model is straight forward, but one MUST READ the specifications...
      //
      // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)
      // https://tools.ietf.org/html/rfc3261#section-13.2.1
      //
      // 5 The Offer/Answer Model and PRACK
      // https://tools.ietf.org/html/rfc3262#section-5
      //
      // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model
      // https://tools.ietf.org/html/rfc6337
      ////
      ////
      // TODO: The Offer/Answer Model Implementation
      //
      // Currently if `earlyMedia` is enabled and the INVITE request forks,
      // the session is terminated if the early dialog does not match the
      // confirmed dialog. This restriction make sense in a WebRTC environment,
      // but there are other environments where this restriction does not hold.
      //
      // So while we currently cannot make the offer in INVITE+forking+webrtc
      // case work, we propose doing the following...
      //
      // OPTION 1
      // - add a `earlyMediaForking` option and
      // - require SDH.setDescription() to be callable multiple times.
      //
      // OPTION 2
      // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...
      // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...
      // 3) ask SDH Factory if it supports "earlyRemoteAnswer"
      //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)
      //   b) if false, defer getting a SDH until 2xx response is received
      //
      // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)
      // early media if initial offer is in the INVITE). We will, however, provide an "inviteWillNotFork"
      // option which if set to "true" will have our supplied WebRTC SDH behave in the 3a manner.
      // That will result in
      //  - early media working with initial offer in the INVITE, and...
      //  - if the INVITE forks, the session terminating with an ERROR that reads like
      //    "You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too."
      //  - furthermore, we accept that users will report that error to us as "bug" regardless
      //
      // So, SDH Factory is going to end up with a new interface along the lines of...
      //
      // interface SessionDescriptionHandlerFactory {
      //   makeLocalOffer(): Promise<ContentTypeAndBody>;
      //   makeSessionDescriptionHandler(
      //     initialOffer: ContentTypeAndBody, offerType: "local" | "remote"
      //   ): Promise<SessionDescriptionHandler>;
      //   supportsEarlyRemoteAnswer: boolean;
      //   supportsContentType(contentType: string): boolean;
      //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>
      //   setDescription(description: ContentTypeAndBody): Promise<void>
      // }
      ////
      // Send the INVITE request.
      this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {
        onAccept: function onAccept(inviteResponse) {
          // Our transaction layer is "non-standard" in that it will only
          // pass us a 2xx response once per branch, so there is no need to
          // worry about dealing with 2xx retransmissions. However, we can
          // and do still get 2xx responses for multiple branches (when an
          // INVITE is forked) which may create multiple confirmed dialogs.
          // Herein we are acking and sending a bye to any confirmed dialogs
          // which arrive beyond the first one. This is the desired behavior
          // for most applications (but certainly not all).
          // If we already received a confirmed dialog, ack & bye this additional confirmed session.
          if (_this4.dialog) {
            _this4.logger.log("Additional confirmed dialog, sending ACK and BYE");

            _this4.ackAndBye(inviteResponse); // We do NOT transition state in this case (this is an "extra" dialog)


            return;
          } // If the user requested cancellation, ack & bye this session.


          if (_this4.isCanceled) {
            _this4.logger.log("Canceled session accepted, sending ACK and BYE");

            _this4.ackAndBye(inviteResponse);

            _this4.stateTransition(_sessionState.SessionState.Terminated);

            return;
          }

          _this4.notifyReferer(inviteResponse);

          _this4.onAccept(inviteResponse).then(function () {
            _this4.disposeEarlyMedia();
          }).catch(function () {
            _this4.disposeEarlyMedia();
          }).then(function () {
            if (options.requestDelegate && options.requestDelegate.onAccept) {
              options.requestDelegate.onAccept(inviteResponse);
            }
          });
        },
        onProgress: function onProgress(inviteResponse) {
          // If the user requested cancellation, ignore response.
          if (_this4.isCanceled) {
            return;
          }

          _this4.notifyReferer(inviteResponse);

          _this4.onProgress(inviteResponse).catch(function () {
            _this4.disposeEarlyMedia();
          }).then(function () {
            if (options.requestDelegate && options.requestDelegate.onProgress) {
              options.requestDelegate.onProgress(inviteResponse);
            }
          });
        },
        onRedirect: function onRedirect(inviteResponse) {
          _this4.notifyReferer(inviteResponse);

          _this4.onRedirect(inviteResponse);

          if (options.requestDelegate && options.requestDelegate.onRedirect) {
            options.requestDelegate.onRedirect(inviteResponse);
          }
        },
        onReject: function onReject(inviteResponse) {
          _this4.notifyReferer(inviteResponse);

          _this4.onReject(inviteResponse);

          if (options.requestDelegate && options.requestDelegate.onReject) {
            options.requestDelegate.onReject(inviteResponse);
          }
        },
        onTrying: function onTrying(inviteResponse) {
          _this4.notifyReferer(inviteResponse);

          _this4.onTrying(inviteResponse);

          if (options.requestDelegate && options.requestDelegate.onTrying) {
            options.requestDelegate.onTrying(inviteResponse);
          }
        }
      });
      return this.outgoingInviteRequest;
    }
  }, {
    key: "disposeEarlyMedia",
    value: function disposeEarlyMedia() {
      this.earlyMediaSessionDescriptionHandlers.forEach(function (sessionDescriptionHandler) {
        sessionDescriptionHandler.close();
      });
      this.earlyMediaSessionDescriptionHandlers.clear();
    }
  }, {
    key: "notifyReferer",
    value: function notifyReferer(response) {
      var _this5 = this;

      if (!this._referred) {
        return;
      }

      if (!(this._referred instanceof _session.Session)) {
        throw new Error("Referred session not instance of session");
      }

      if (!this._referred.dialog) {
        return;
      }

      if (!response.message.statusCode) {
        throw new Error("Status code undefined.");
      }

      if (!response.message.reasonPhrase) {
        throw new Error("Reason phrase undefined.");
      }

      var statusCode = response.message.statusCode;
      var reasonPhrase = response.message.reasonPhrase;
      var body = "SIP/2.0 ".concat(statusCode, " ").concat(reasonPhrase).trim();

      var outgoingNotifyRequest = this._referred.dialog.notify(undefined, {
        extraHeaders: ["Event: refer", "Subscription-State: terminated"],
        body: {
          contentDisposition: "render",
          contentType: "message/sipfrag",
          content: body
        }
      }); // The implicit subscription created by a REFER is the same as a
      // subscription created with a SUBSCRIBE request.  The agent issuing the
      // REFER can terminate this subscription prematurely by unsubscribing
      // using the mechanisms described in [2].  Terminating a subscription,
      // either by explicitly unsubscribing or rejecting NOTIFY, is not an
      // indication that the referenced request should be withdrawn or
      // abandoned.
      // https://tools.ietf.org/html/rfc3515#section-2.4.4
      // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.
      // If the notify is rejected, stop sending NOTIFY requests.


      outgoingNotifyRequest.delegate = {
        onReject: function onReject() {
          _this5._referred = undefined;
        }
      };
    }
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse - 2xx response.
     */

  }, {
    key: "onAccept",
    value: function onAccept(inviteResponse) {
      var _this6 = this;

      this.logger.log("Inviter.onAccept"); // validate state

      if (this.state !== _sessionState.SessionState.Establishing) {
        this.logger.error("Accept received while in state ".concat(this.state, ", dropping response"));
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      var response = inviteResponse.message;
      var session = inviteResponse.session; // Ported behavior.

      if (response.hasHeader("P-Asserted-Identity")) {
        this._assertedIdentity = _core.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
      } // We have a confirmed dialog.


      session.delegate = {
        onAck: function onAck(ackRequest) {
          return _this6.onAckRequest(ackRequest);
        },
        onBye: function onBye(byeRequest) {
          return _this6.onByeRequest(byeRequest);
        },
        onInfo: function onInfo(infoRequest) {
          return _this6.onInfoRequest(infoRequest);
        },
        onInvite: function onInvite(inviteRequest) {
          return _this6.onInviteRequest(inviteRequest);
        },
        onMessage: function onMessage(messageRequest) {
          return _this6.onMessageRequest(messageRequest);
        },
        onNotify: function onNotify(notifyRequest) {
          return _this6.onNotifyRequest(notifyRequest);
        },
        onPrack: function onPrack(prackRequest) {
          return _this6.onPrackRequest(prackRequest);
        },
        onRefer: function onRefer(referRequest) {
          return _this6.onReferRequest(referRequest);
        }
      };
      this._dialog = session;

      switch (session.signalingState) {
        case _core.SignalingState.Initial:
          // INVITE without offer, so MUST have offer at this point, so invalid state.
          this.logger.error("Received 2xx response to INVITE without a session description");
          this.ackAndBye(inviteResponse, 400, "Missing session description");
          this.stateTransition(_sessionState.SessionState.Terminated);
          return Promise.reject(new Error("Bad Media Description"));

        case _core.SignalingState.HaveLocalOffer:
          // INVITE with offer, so MUST have answer at this point, so invalid state.
          this.logger.error("Received 2xx response to INVITE without a session description");
          this.ackAndBye(inviteResponse, 400, "Missing session description");
          this.stateTransition(_sessionState.SessionState.Terminated);
          return Promise.reject(new Error("Bad Media Description"));

        case _core.SignalingState.HaveRemoteOffer:
          {
            // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.
            if (!this._dialog.offer) {
              throw new Error("Session offer undefined in signaling state ".concat(this._dialog.signalingState, "."));
            }

            var options = {
              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
            };
            return this.setOfferAndGetAnswer(this._dialog.offer, options).then(function (body) {
              inviteResponse.ack({
                body: body
              });

              _this6.stateTransition(_sessionState.SessionState.Established);
            }).catch(function (error) {
              _this6.ackAndBye(inviteResponse, 488, "Invalid session description");

              _this6.stateTransition(_sessionState.SessionState.Terminated);

              throw error;
            });
          }

        case _core.SignalingState.Stable:
          {
            // If INVITE without offer and we have already completed the initial exchange.
            if (this.earlyMediaSessionDescriptionHandlers.size > 0) {
              var sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);

              if (!sdh) {
                throw new Error("Session description handler undefined.");
              }

              this.setSessionDescriptionHandler(sdh);
              this.earlyMediaSessionDescriptionHandlers.delete(session.id);
              inviteResponse.ack();
              this.stateTransition(_sessionState.SessionState.Established);
              return Promise.resolve();
            } // If INVITE with offer and we used an "early" answer in a provisional response for media


            if (this.earlyMediaDialog) {
              // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.
              // This limitation stems from how WebRTC currently implements its offer/answer model.
              // There are details elsewhere, but in short a WebRTC offer cannot be forked.
              if (this.earlyMediaDialog !== session) {
                if (this.earlyMedia) {
                  var message = "You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests " + "do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly " + "the end point which accepted the INVITE (confirmed dialog) does not match the end point with " + "which early media has been setup (early dialog) and thus this session is unable to proceed. " + "In accordance with the SIP specifications, the SIP servers your end point is connected to " + "determine if an INVITE forks and the forking behavior of those servers cannot be controlled " + "by this library. If you wish to use early media with this library you must configure those " + "servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow " + "this library to function with any INVITE requests which do fork.";
                  this.logger.error(message);
                }

                var error = new Error("Early media dialog does not equal confirmed dialog, terminating session");
                this.logger.error(error.message);
                this.ackAndBye(inviteResponse, 488, "Not Acceptable Here");
                this.stateTransition(_sessionState.SessionState.Terminated);
                return Promise.reject(error);
              } // Otherwise we are good to go.


              inviteResponse.ack();
              this.stateTransition(_sessionState.SessionState.Established);
              return Promise.resolve();
            } // If INVITE with offer and we have been waiting till now to apply the answer.


            var answer = session.answer;

            if (!answer) {
              throw new Error("Answer is undefined.");
            }

            var _options = {
              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
            };
            return this.setAnswer(answer, _options).then(function () {
              // This session has completed an initial offer/answer exchange...
              var ackOptions;

              if (_this6._renderbody && _this6._rendertype) {
                ackOptions = {
                  body: {
                    contentDisposition: "render",
                    contentType: _this6._rendertype,
                    content: _this6._renderbody
                  }
                };
              }

              inviteResponse.ack(ackOptions);

              _this6.stateTransition(_sessionState.SessionState.Established);
            }).catch(function (error) {
              _this6.logger.error(error.message);

              _this6.ackAndBye(inviteResponse, 488, "Not Acceptable Here");

              _this6.stateTransition(_sessionState.SessionState.Terminated);

              throw error;
            });
          }

        case _core.SignalingState.Closed:
          // Dialog has terminated.
          return Promise.reject(new Error("Terminated."));

        default:
          throw new Error("Unknown session signaling state.");
      }
    }
    /**
     * Handle provisional response to initial INVITE.
     * @param inviteResponse - 1xx response.
     */

  }, {
    key: "onProgress",
    value: function onProgress(inviteResponse) {
      var _this7 = this;

      var _a;

      this.logger.log("Inviter.onProgress"); // validate state

      if (this.state !== _sessionState.SessionState.Establishing) {
        this.logger.error("Progress received while in state ".concat(this.state, ", dropping response"));
        return Promise.reject(new Error("Invalid session state ".concat(this.state)));
      }

      if (!this.outgoingInviteRequest) {
        throw new Error("Outgoing INVITE request undefined.");
      }

      var response = inviteResponse.message;
      var session = inviteResponse.session; // Ported - Set assertedIdentity.

      if (response.hasHeader("P-Asserted-Identity")) {
        this._assertedIdentity = _core.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
      } // If a provisional response is received for an initial request, and
      // that response contains a Require header field containing the option
      // tag 100rel, the response is to be sent reliably.  If the response is
      // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
      // ignored, and the procedures below MUST NOT be used.
      // https://tools.ietf.org/html/rfc3262#section-4


      var requireHeader = response.getHeader("require");
      var rseqHeader = response.getHeader("rseq");
      var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
      var responseReliable = !!rseq;
      var extraHeaders = [];

      if (responseReliable) {
        extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
      }

      switch (session.signalingState) {
        case _core.SignalingState.Initial:
          // INVITE without offer and session still has no offer (and no answer).
          if (responseReliable) {
            // Similarly, if a reliable provisional
            // response is the first reliable message sent back to the UAC, and the
            // INVITE did not contain an offer, one MUST appear in that reliable
            // provisional response.
            // https://tools.ietf.org/html/rfc3262#section-5
            this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer."); // FIXME: Known popular UA's currently end up here...

            inviteResponse.prack({
              extraHeaders: extraHeaders
            });
          }

          return Promise.resolve();

        case _core.SignalingState.HaveLocalOffer:
          // INVITE with offer and session only has that initial local offer.
          if (responseReliable) {
            inviteResponse.prack({
              extraHeaders: extraHeaders
            });
          }

          return Promise.resolve();

        case _core.SignalingState.HaveRemoteOffer:
          if (!responseReliable) {
            // The initial offer MUST be in either an INVITE or, if not there,
            // in the first reliable non-failure message from the UAS back to
            // the UAC.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // According to Section 13.2.1 of [RFC3261], 'The first reliable
            // non-failure message' must have an offer if there is no offer in the
            // INVITE request.  This means that the User Agent (UA) that receives
            // the INVITE request without an offer must include an offer in the
            // first reliable response with 100rel extension.  If no reliable
            // provisional response has been sent, the User Agent Server (UAS) must
            // include an offer when sending 2xx response.
            // https://tools.ietf.org/html/rfc6337#section-2.2
            this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
            return Promise.resolve();
          }

          {
            // If the initial offer is in the first reliable non-failure
            // message from the UAS back to UAC, the answer MUST be in the
            // acknowledgement for that message
            var sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});

            if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {
              this.delegate.onSessionDescriptionHandler(sdh, true);
            }

            this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);
            return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(function () {
              return sdh.getDescription(_this7.sessionDescriptionHandlerOptions, _this7.sessionDescriptionHandlerModifiers);
            }).then(function (description) {
              var body = {
                contentDisposition: "session",
                contentType: description.contentType,
                content: description.body
              };
              inviteResponse.prack({
                extraHeaders: extraHeaders,
                body: body
              });
            }).catch(function (error) {
              _this7.stateTransition(_sessionState.SessionState.Terminated);

              throw error;
            });
          }

        case _core.SignalingState.Stable:
          // This session has completed an initial offer/answer exchange, so...
          // - INVITE with SDP and this provisional response MAY be reliable
          // - INVITE without SDP and this provisional response MAY be reliable
          if (responseReliable) {
            inviteResponse.prack({
              extraHeaders: extraHeaders
            });
          }

          if (this.earlyMedia && !this.earlyMediaDialog) {
            this.earlyMediaDialog = session;
            var answer = session.answer;

            if (!answer) {
              throw new Error("Answer is undefined.");
            }

            var options = {
              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,
              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions
            };
            return this.setAnswer(answer, options).catch(function (error) {
              _this7.stateTransition(_sessionState.SessionState.Terminated);

              throw error;
            });
          }

          return Promise.resolve();

        case _core.SignalingState.Closed:
          // Dialog has terminated.
          return Promise.reject(new Error("Terminated."));

        default:
          throw new Error("Unknown session signaling state.");
      }
    }
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse - 3xx response.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "onRedirect",
    value: function onRedirect(inviteResponse) {
      this.logger.log("Inviter.onRedirect"); // validate state

      if (this.state !== _sessionState.SessionState.Establishing && this.state !== _sessionState.SessionState.Terminating) {
        this.logger.error("Redirect received while in state ".concat(this.state, ", dropping response"));
        return;
      } // transition state


      this.stateTransition(_sessionState.SessionState.Terminated);
    }
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse - 4xx, 5xx, or 6xx response.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "onReject",
    value: function onReject(inviteResponse) {
      this.logger.log("Inviter.onReject"); // validate state

      if (this.state !== _sessionState.SessionState.Establishing && this.state !== _sessionState.SessionState.Terminating) {
        this.logger.error("Reject received while in state ".concat(this.state, ", dropping response"));
        return;
      } // transition state


      this.stateTransition(_sessionState.SessionState.Terminated);
    }
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse - 100 response.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "onTrying",
    value: function onTrying(inviteResponse) {
      this.logger.log("Inviter.onTrying"); // validate state

      if (this.state !== _sessionState.SessionState.Establishing) {
        this.logger.error("Trying received while in state ".concat(this.state, ", dropping response"));
        return;
      }
    }
  }]);

  return Inviter;
}(_session.Session);

exports.Inviter = Inviter;
},{"../core":"node_modules/sip.js/lib/core/index.js","../core/messages/utils":"node_modules/sip.js/lib/core/messages/utils.js","./session":"node_modules/sip.js/lib/api/session.js","./session-state":"node_modules/sip.js/lib/api/session-state.js","./user-agent-options":"node_modules/sip.js/lib/api/user-agent-options.js"}],"node_modules/sip.js/lib/api/messager-message-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/messager-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/messager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Messager = void 0;

var _core = require("../core");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A messager sends a {@link Message} (outgoing MESSAGE).
 * @public
 */
var Messager = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the `Messager` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param content - Content for the body of the message.
   * @param contentType - Content type of the body of the message.
   * @param options - Options bucket. See {@link MessagerOptions} for details.
   */
  function Messager(userAgent, targetURI, content) {
    var contentType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "text/plain";
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, Messager);

    // Logger
    this.logger = userAgent.getLogger("sip.Messager"); // Default options params

    options.params = options.params || {}; // URIs

    var fromURI = userAgent.userAgentCore.configuration.aor;

    if (options.params.fromUri) {
      fromURI = typeof options.params.fromUri === "string" ? _core.Grammar.URIParse(options.params.fromUri) : options.params.fromUri;
    }

    if (!fromURI) {
      throw new TypeError("Invalid from URI: " + options.params.fromUri);
    }

    var toURI = targetURI;

    if (options.params.toUri) {
      toURI = typeof options.params.toUri === "string" ? _core.Grammar.URIParse(options.params.toUri) : options.params.toUri;
    }

    if (!toURI) {
      throw new TypeError("Invalid to URI: " + options.params.toUri);
    } // Message params


    var params = options.params ? Object.assign({}, options.params) : {}; // Extra headers

    var extraHeaders = (options.extraHeaders || []).slice(); // Body

    var contentDisposition = "render";
    var body = {
      contentDisposition: contentDisposition,
      contentType: contentType,
      content: content
    }; // Build the request

    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(_core.C.MESSAGE, targetURI, fromURI, toURI, params, extraHeaders, body); // User agent

    this.userAgent = userAgent;
  }
  /**
   * Send the message.
   */


  _createClass(Messager, [{
    key: "message",
    value: function message() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.userAgent.userAgentCore.request(this.request, options.requestDelegate);
      return Promise.resolve();
    }
  }]);

  return Messager;
}();

exports.Messager = Messager;
},{"../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/api/publisher-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/publisher-publish-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/publisher-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PublisherState = void 0;

/**
 * {@link Publisher} state.
 * @remarks
 * The {@link Publisher} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                  __________________________________________
 *                 |  __________________________              |
 * Publisher       | |                          v             v
 * Constructed -> Initial -> Published -> Unpublished -> Terminated
 *                              |   ^____________|             ^
 *                              |______________________________|
 * ```
 * @public
 */
var PublisherState;
exports.PublisherState = PublisherState;

(function (PublisherState) {
  PublisherState["Initial"] = "Initial";
  PublisherState["Published"] = "Published";
  PublisherState["Unpublished"] = "Unpublished";
  PublisherState["Terminated"] = "Terminated";
})(PublisherState || (exports.PublisherState = PublisherState = {}));
},{}],"node_modules/sip.js/lib/api/publisher-unpublish-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/publisher.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Publisher = void 0;

var _core = require("../core");

var _emitter = require("./emitter");

var _publisherState = require("./publisher-state");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A publisher publishes a publication (outgoing PUBLISH).
 * @public
 */
var Publisher = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the `Publisher` class.
   *
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - Request URI identifying the target of the message.
   * @param eventType - The event type identifying the published document.
   * @param options - Options bucket. See {@link PublisherOptions} for details.
   */
  function Publisher(userAgent, targetURI, eventType) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Publisher);

    this.disposed = false;
    /** The publication state. */

    this._state = _publisherState.PublisherState.Initial; // state emitter

    this._stateEventEmitter = new _emitter.EmitterImpl();
    this.userAgent = userAgent;
    options.extraHeaders = (options.extraHeaders || []).slice();
    options.contentType = options.contentType || "text/plain";

    if (typeof options.expires !== "number" || options.expires % 1 !== 0) {
      options.expires = 3600;
    } else {
      options.expires = Number(options.expires);
    }

    if (typeof options.unpublishOnClose !== "boolean") {
      options.unpublishOnClose = true;
    }

    this.target = targetURI;
    this.event = eventType;
    this.options = options;
    this.pubRequestExpires = options.expires;
    this.logger = userAgent.getLogger("sip.Publisher");
    var params = options.params || {};
    var fromURI = params.fromUri ? params.fromUri : userAgent.userAgentCore.configuration.aor;
    var toURI = params.toUri ? params.toUri : targetURI;
    var body;

    if (options.body && options.contentType) {
      var contentDisposition = "render";
      var contentType = options.contentType;
      var content = options.body;
      body = {
        contentDisposition: contentDisposition,
        contentType: contentType,
        content: content
      };
    }

    var extraHeaders = (options.extraHeaders || []).slice(); // Build the request

    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(_core.C.PUBLISH, targetURI, fromURI, toURI, params, extraHeaders, body); // Identifier

    this.id = this.target.toString() + ":" + this.event; // Add to the user agent's publisher collection.

    this.userAgent._publishers[this.id] = this;
  }
  /**
   * Destructor.
   */


  _createClass(Publisher, [{
    key: "dispose",
    value: function dispose() {
      if (this.disposed) {
        return Promise.resolve();
      }

      this.disposed = true;
      this.logger.log("Publisher ".concat(this.id, " in state ").concat(this.state, " is being disposed")); // Remove from the user agent's publisher collection

      delete this.userAgent._publishers[this.id]; // Send unpublish, if requested

      if (this.options.unpublishOnClose && this.state === _publisherState.PublisherState.Published) {
        return this.unpublish();
      }

      if (this.publishRefreshTimer) {
        clearTimeout(this.publishRefreshTimer);
        this.publishRefreshTimer = undefined;
      }

      this.pubRequestBody = undefined;
      this.pubRequestExpires = 0;
      this.pubRequestEtag = undefined;
      return Promise.resolve();
    }
    /** The publication state. */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /** Emits when the publisher state changes. */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /**
     * Publish.
     * @param content - Body to publish
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "publish",
    value: function publish(content) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Clean up before the run
      if (this.publishRefreshTimer) {
        clearTimeout(this.publishRefreshTimer);
        this.publishRefreshTimer = undefined;
      } // is Initial or Modify request


      this.options.body = content;
      this.pubRequestBody = this.options.body;

      if (this.pubRequestExpires === 0) {
        // This is Initial request after unpublish
        if (this.options.expires === undefined) {
          throw new Error("Expires undefined.");
        }

        this.pubRequestExpires = this.options.expires;
        this.pubRequestEtag = undefined;
      }

      this.sendPublishRequest();
      return Promise.resolve();
    }
    /**
     * Unpublish.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "unpublish",
    value: function unpublish() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Clean up before the run
      if (this.publishRefreshTimer) {
        clearTimeout(this.publishRefreshTimer);
        this.publishRefreshTimer = undefined;
      }

      this.pubRequestBody = undefined;
      this.pubRequestExpires = 0;

      if (this.pubRequestEtag !== undefined) {
        this.sendPublishRequest();
      }

      return Promise.resolve();
    }
    /** @internal */

  }, {
    key: "receiveResponse",
    value: function receiveResponse(response) {
      var _this = this;

      var statusCode = response.statusCode || 0;

      switch (true) {
        case /^1[0-9]{2}$/.test(statusCode.toString()):
          break;

        case /^2[0-9]{2}$/.test(statusCode.toString()):
          // Set SIP-Etag
          if (response.hasHeader("SIP-ETag")) {
            this.pubRequestEtag = response.getHeader("SIP-ETag");
          } else {
            this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
          } // Update Expire


          if (response.hasHeader("Expires")) {
            var expires = Number(response.getHeader("Expires"));

            if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
              this.pubRequestExpires = expires;
            } else {
              this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
            }
          } else {
            this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
          }

          if (this.pubRequestExpires !== 0) {
            // Schedule refresh
            this.publishRefreshTimer = setTimeout(function () {
              return _this.refreshRequest();
            }, this.pubRequestExpires * 900);

            if (this._state !== _publisherState.PublisherState.Published) {
              this.stateTransition(_publisherState.PublisherState.Published);
            }
          } else {
            this.stateTransition(_publisherState.PublisherState.Unpublished);
          }

          break;

        case /^412$/.test(statusCode.toString()):
          // 412 code means no matching ETag - possibly the PUBLISH expired
          // Resubmit as new request, if the current request is not a "remove"
          if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {
            this.logger.warn("412 response to PUBLISH, recovering");
            this.pubRequestEtag = undefined;

            if (this.options.body === undefined) {
              throw new Error("Body undefined.");
            }

            this.publish(this.options.body);
          } else {
            this.logger.warn("412 response to PUBLISH, recovery failed");
            this.pubRequestExpires = 0;
            this.stateTransition(_publisherState.PublisherState.Unpublished);
            this.stateTransition(_publisherState.PublisherState.Terminated);
          }

          break;

        case /^423$/.test(statusCode.toString()):
          // 423 code means we need to adjust the Expires interval up
          if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
            var minExpires = Number(response.getHeader("Min-Expires"));

            if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
              this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
              this.pubRequestExpires = minExpires;

              if (this.options.body === undefined) {
                throw new Error("Body undefined.");
              }

              this.publish(this.options.body);
            } else {
              this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
              this.pubRequestExpires = 0;
              this.stateTransition(_publisherState.PublisherState.Unpublished);
              this.stateTransition(_publisherState.PublisherState.Terminated);
            }
          } else {
            this.logger.warn("423 response to PUBLISH, recovery failed");
            this.pubRequestExpires = 0;
            this.stateTransition(_publisherState.PublisherState.Unpublished);
            this.stateTransition(_publisherState.PublisherState.Terminated);
          }

          break;

        default:
          this.pubRequestExpires = 0;
          this.stateTransition(_publisherState.PublisherState.Unpublished);
          this.stateTransition(_publisherState.PublisherState.Terminated);
          break;
      } // Do the cleanup


      if (this.pubRequestExpires === 0) {
        if (this.publishRefreshTimer) {
          clearTimeout(this.publishRefreshTimer);
          this.publishRefreshTimer = undefined;
        }

        this.pubRequestBody = undefined;
        this.pubRequestEtag = undefined;
      }
    }
    /** @internal */

  }, {
    key: "send",
    value: function send() {
      var _this2 = this;

      return this.userAgent.userAgentCore.publish(this.request, {
        onAccept: function onAccept(response) {
          return _this2.receiveResponse(response.message);
        },
        onProgress: function onProgress(response) {
          return _this2.receiveResponse(response.message);
        },
        onRedirect: function onRedirect(response) {
          return _this2.receiveResponse(response.message);
        },
        onReject: function onReject(response) {
          return _this2.receiveResponse(response.message);
        },
        onTrying: function onTrying(response) {
          return _this2.receiveResponse(response.message);
        }
      });
    }
  }, {
    key: "refreshRequest",
    value: function refreshRequest() {
      // Clean up before the run
      if (this.publishRefreshTimer) {
        clearTimeout(this.publishRefreshTimer);
        this.publishRefreshTimer = undefined;
      } // This is Refresh request


      this.pubRequestBody = undefined;

      if (this.pubRequestEtag === undefined) {
        throw new Error("Etag undefined");
      }

      if (this.pubRequestExpires === 0) {
        throw new Error("Expires zero");
      }

      this.sendPublishRequest();
    }
  }, {
    key: "sendPublishRequest",
    value: function sendPublishRequest() {
      var reqOptions = Object.assign({}, this.options);
      reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
      reqOptions.extraHeaders.push("Event: " + this.event);
      reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);

      if (this.pubRequestEtag !== undefined) {
        reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
      }

      var ruri = this.target;
      var params = this.options.params || {};
      var bodyAndContentType;

      if (this.pubRequestBody !== undefined) {
        if (this.options.contentType === undefined) {
          throw new Error("Content type undefined.");
        }

        bodyAndContentType = {
          body: this.pubRequestBody,
          contentType: this.options.contentType
        };
      }

      var body;

      if (bodyAndContentType) {
        body = (0, _core.fromBodyLegacy)(bodyAndContentType);
      }

      this.request = this.userAgent.userAgentCore.makeOutgoingRequestMessage(_core.C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.userAgent.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);
      return this.send();
    }
    /**
     * Transition publication state.
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this3 = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this3._state, " to ").concat(newState));
      }; // Validate transition


      switch (this._state) {
        case _publisherState.PublisherState.Initial:
          if (newState !== _publisherState.PublisherState.Published && newState !== _publisherState.PublisherState.Unpublished && newState !== _publisherState.PublisherState.Terminated) {
            invalidTransition();
          }

          break;

        case _publisherState.PublisherState.Published:
          if (newState !== _publisherState.PublisherState.Unpublished && newState !== _publisherState.PublisherState.Terminated) {
            invalidTransition();
          }

          break;

        case _publisherState.PublisherState.Unpublished:
          if (newState !== _publisherState.PublisherState.Published && newState !== _publisherState.PublisherState.Terminated) {
            invalidTransition();
          }

          break;

        case _publisherState.PublisherState.Terminated:
          invalidTransition();
          break;

        default:
          throw new Error("Unrecognized state.");
      } // Transition


      this._state = newState;
      this.logger.log("Publication transitioned to state ".concat(this._state));

      this._stateEventEmitter.emit(this._state); // Dispose


      if (newState === _publisherState.PublisherState.Terminated) {
        this.dispose();
      }
    }
  }]);

  return Publisher;
}();

exports.Publisher = Publisher;
},{"../core":"node_modules/sip.js/lib/core/index.js","./emitter":"node_modules/sip.js/lib/api/emitter.js","./publisher-state":"node_modules/sip.js/lib/api/publisher-state.js"}],"node_modules/sip.js/lib/api/registerer-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/registerer-register-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/registerer-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegistererState = void 0;

/**
 * {@link Registerer} state.
 * @remarks
 * The {@link Registerer} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                   __________________________________________
 *                  |  __________________________              |
 * Registerer       | |                          v             v
 * Constructed -> Initial -> Registered -> Unregistered -> Terminated
 *                              |   ^____________|             ^
 *                              |______________________________|
 * ```
 * @public
 */
var RegistererState;
exports.RegistererState = RegistererState;

(function (RegistererState) {
  RegistererState["Initial"] = "Initial";
  RegistererState["Registered"] = "Registered";
  RegistererState["Unregistered"] = "Unregistered";
  RegistererState["Terminated"] = "Terminated";
})(RegistererState || (exports.RegistererState = RegistererState = {}));
},{}],"node_modules/sip.js/lib/api/registerer-unregister-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/registerer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Registerer = void 0;

var _core = require("../core");

var _emitter = require("./emitter");

var _exceptions = require("./exceptions");

var _registererState = require("./registerer-state");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A registerer registers a contact for an address of record (outgoing REGISTER).
 * @public
 */
var Registerer = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the `Registerer` class.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param options - Options bucket. See {@link RegistererOptions} for details.
   */
  function Registerer(userAgent) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Registerer);

    this.disposed = false;
    /** The contacts returned from the most recent accepted REGISTER request. */

    this._contacts = [];
    /** The number of seconds to wait before retrying to register. */

    this._retryAfter = undefined;
    /** The registration state. */

    this._state = _registererState.RegistererState.Initial;
    /** True is waiting for final response to outstanding REGISTER request. */

    this._waiting = false; // state emitter

    this._stateEventEmitter = new _emitter.EmitterImpl(); // waiting emitter

    this._waitingEventEmitter = new _emitter.EmitterImpl(); // Set user agent

    this.userAgent = userAgent; // Default registrar is domain portion of user agent uri

    var defaultUserAgentRegistrar = userAgent.configuration.uri.clone();
    defaultUserAgentRegistrar.user = undefined; // Initialize configuration

    this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), {
      registrar: defaultUserAgentRegistrar
    }), Registerer.stripUndefinedProperties(options)); // Make sure we are not using references to array options

    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();
    this.options.extraHeaders = (this.options.extraHeaders || []).slice(); // Make sure we are not using references to registrar uri

    if (!this.options.registrar) {
      throw new Error("Registrar undefined.");
    }

    this.options.registrar = this.options.registrar.clone(); // Set instanceId and regId conditional defaults and validate

    if (this.options.regId && !this.options.instanceId) {
      this.options.instanceId = Registerer.newUUID();
    } else if (!this.options.regId && this.options.instanceId) {
      this.options.regId = 1;
    }

    if (this.options.instanceId && _core.Grammar.parse(this.options.instanceId, "uuid") === -1) {
      throw new Error("Invalid instanceId.");
    }

    if (this.options.regId && this.options.regId < 0) {
      throw new Error("Invalid regId.");
    }

    var registrar = this.options.registrar;
    var fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;
    var toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;
    var params = this.options.params || {};
    var extraHeaders = (options.extraHeaders || []).slice(); // Build the request

    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(_core.C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined); // Registration expires

    this.expires = this.options.expires || Registerer.defaultExpires;

    if (this.expires < 0) {
      throw new Error("Invalid expires.");
    } // Interval at which re-REGISTER requests are sent


    this.refreshFrequency = this.options.refreshFrequency || Registerer.defaultRefreshFrequency;

    if (this.refreshFrequency < 50 || this.refreshFrequency > 99) {
      throw new Error("Invalid refresh frequency. The value represents a percentage of the expiration time and should be between 50 and 99.");
    } // initialize logger


    this.logger = userAgent.getLogger("sip.Registerer");

    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach(function (key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var value = _this.options[key];

        switch (key) {
          case "registrar":
            _this.logger.log(" " + key + ": " + value);

            break;

          default:
            _this.logger.log(" " + key + ": " + JSON.stringify(value));

        }
      });
    } // Identifier


    this.id = this.request.callId + this.request.from.parameters.tag; // Add to the user agent's session collection.

    this.userAgent._registerers[this.id] = this;
  }
  /** Default registerer options. */


  _createClass(Registerer, [{
    key: "contacts",
    get:
    /** The registered contacts. */
    function get() {
      return this._contacts.slice();
    }
    /**
     * The number of seconds to wait before retrying to register.
     * @defaultValue `undefined`
     * @remarks
     * When the server rejects a registration request, if it provides a suggested
     * duration to wait before retrying, that value is available here when and if
     * the state transitions to `Unsubscribed`. It is also available during the
     * callback to `onReject` after a call to `register`. (Note that if the state
     * if already `Unsubscribed`, a rejected request created by `register` will
     * not cause the state to transition to `Unsubscribed`. One way to avoid this
     * case is to dispose of `Registerer` when unregistered and create a new
     * `Registerer` for any attempts to retry registering.)
     * @example
     * ```ts
     * // Checking for retry after on state change
     * registerer.stateChange.addListener((newState) => {
     *   switch (newState) {
     *     case RegistererState.Unregistered:
     *       const retryAfter = registerer.retryAfter;
     *       break;
     *   }
     * });
     *
     * // Checking for retry after on request rejection
     * registerer.register({
     *   requestDelegate: {
     *     onReject: () => {
     *       const retryAfter = registerer.retryAfter;
     *     }
     *   }
     * });
     * ```
     */

  }, {
    key: "retryAfter",
    get: function get() {
      return this._retryAfter;
    }
    /** The registration state. */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /** Emits when the registerer state changes. */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /** Destructor. */

  }, {
    key: "dispose",
    value: function dispose() {
      var _this2 = this;

      if (this.disposed) {
        return Promise.resolve();
      }

      this.disposed = true;
      this.logger.log("Registerer ".concat(this.id, " in state ").concat(this.state, " is being disposed")); // Remove from the user agent's registerer collection

      delete this.userAgent._registerers[this.id]; // If registered, unregisters and resolves after final response received.

      return new Promise(function (resolve) {
        var doClose = function doClose() {
          // If we are registered, unregister and resolve after our state changes
          if (!_this2.waiting && _this2._state === _registererState.RegistererState.Registered) {
            _this2.stateChange.addListener(function () {
              _this2.terminated();

              resolve();
            }, {
              once: true
            });

            _this2.unregister();

            return;
          } // Otherwise just resolve


          _this2.terminated();

          resolve();
        }; // If we are waiting for an outstanding request, wait for it to finish and then try closing.
        // Otherwise just try closing.


        if (_this2.waiting) {
          _this2.waitingChange.addListener(function () {
            doClose();
          }, {
            once: true
          });
        } else {
          doClose();
        }
      });
    }
    /**
     * Sends the REGISTER request.
     * @remarks
     * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.
     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
     */

  }, {
    key: "register",
    value: function register() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.state === _registererState.RegistererState.Terminated) {
        this.stateError();
        throw new Error("Registerer terminated. Unable to register.");
      }

      if (this.disposed) {
        this.stateError();
        throw new Error("Registerer disposed. Unable to register.");
      } // UAs MUST NOT send a new registration (that is, containing new Contact
      // header field values, as opposed to a retransmission) until they have
      // received a final response from the registrar for the previous one or
      // the previous REGISTER request has timed out.
      // https://tools.ietf.org/html/rfc3261#section-10.2


      if (this.waiting) {
        this.waitingWarning();
        var error = new _exceptions.RequestPendingError("REGISTER request already in progress, waiting for final response");
        return Promise.reject(error);
      } // Options


      if (options.requestOptions) {
        this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);
      } // Extra headers


      var extraHeaders = (this.options.extraHeaders || []).slice();
      extraHeaders.push("Contact: " + this.generateContactHeader(this.expires)); // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency

      extraHeaders.push("Allow: " + ["ACK", "CANCEL", "INVITE", "MESSAGE", "BYE", "OPTIONS", "INFO", "NOTIFY", "REFER"].toString()); // Call-ID: All registrations from a UAC SHOULD use the same Call-ID
      // header field value for registrations sent to a particular
      // registrar.
      //
      // CSeq: The CSeq value guarantees proper ordering of REGISTER
      // requests.  A UA MUST increment the CSeq value by one for each
      // REGISTER request with the same Call-ID.
      // https://tools.ietf.org/html/rfc3261#section-10.2

      this.request.cseq++;
      this.request.setHeader("cseq", this.request.cseq + " REGISTER");
      this.request.extraHeaders = extraHeaders;
      this.waitingToggle(true);
      var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
        onAccept: function onAccept(response) {
          var expires; // FIXME: This does NOT appear to be to spec and should be removed.
          // I haven't found anywhere that an Expires header may be used in a response.

          if (response.message.hasHeader("expires")) {
            expires = Number(response.message.getHeader("expires"));
          } // 8. The registrar returns a 200 (OK) response.  The response MUST
          // contain Contact header field values enumerating all current
          // bindings.  Each Contact value MUST feature an "expires"
          // parameter indicating its expiration interval chosen by the
          // registrar.  The response SHOULD include a Date header field.
          // https://tools.ietf.org/html/rfc3261#section-10.3


          _this3._contacts = response.message.getHeaders("contact");
          var contacts = _this3._contacts.length;

          if (!contacts) {
            _this3.logger.error("No Contact header in response to REGISTER, dropping response.");

            _this3.unregistered();

            return;
          } // The 200 (OK) response from the registrar contains a list of Contact
          // fields enumerating all current bindings.  The UA compares each
          // contact address to see if it created the contact address, using
          // comparison rules in Section 19.1.4.  If so, it updates the expiration
          // time interval according to the expires parameter or, if absent, the
          // Expires field value.  The UA then issues a REGISTER request for each
          // of its bindings before the expiration interval has elapsed.
          // https://tools.ietf.org/html/rfc3261#section-10.2.4


          var contact;

          while (contacts--) {
            contact = response.message.parseHeader("contact", contacts);

            if (!contact) {
              throw new Error("Contact undefined");
            }

            if (_this3.userAgent.contact.pubGruu && (0, _core.equivalentURI)(contact.uri, _this3.userAgent.contact.pubGruu)) {
              expires = Number(contact.getParam("expires"));
              break;
            } // If we are using a randomly generated user name (which is the default behavior)


            if (_this3.userAgent.configuration.contactName === "") {
              // compare the user portion of the URI under the assumption that it will be unique
              if (contact.uri.user === _this3.userAgent.contact.uri.user) {
                expires = Number(contact.getParam("expires"));
                break;
              }
            } else {
              // otherwise use comparision rules in Section 19.1.4
              if ((0, _core.equivalentURI)(contact.uri, _this3.userAgent.contact.uri)) {
                expires = Number(contact.getParam("expires"));
                break;
              }
            }

            contact = undefined;
          } // There must be a matching contact.


          if (contact === undefined) {
            _this3.logger.error("No Contact header pointing to us, dropping response");

            _this3.unregistered();

            _this3.waitingToggle(false);

            return;
          } // The contact must have an expires.


          if (expires === undefined) {
            _this3.logger.error("Contact pointing to us is missing expires parameter, dropping response");

            _this3.unregistered();

            _this3.waitingToggle(false);

            return;
          } // Save gruu values


          if (contact.hasParam("temp-gruu")) {
            var gruu = contact.getParam("temp-gruu");

            if (gruu) {
              _this3.userAgent.contact.tempGruu = _core.Grammar.URIParse(gruu.replace(/"/g, ""));
            }
          }

          if (contact.hasParam("pub-gruu")) {
            var _gruu = contact.getParam("pub-gruu");

            if (_gruu) {
              _this3.userAgent.contact.pubGruu = _core.Grammar.URIParse(_gruu.replace(/"/g, ""));
            }
          }

          _this3.registered(expires);

          if (options.requestDelegate && options.requestDelegate.onAccept) {
            options.requestDelegate.onAccept(response);
          }

          _this3.waitingToggle(false);
        },
        onProgress: function onProgress(response) {
          if (options.requestDelegate && options.requestDelegate.onProgress) {
            options.requestDelegate.onProgress(response);
          }
        },
        onRedirect: function onRedirect(response) {
          _this3.logger.error("Redirect received. Not supported.");

          _this3.unregistered();

          if (options.requestDelegate && options.requestDelegate.onRedirect) {
            options.requestDelegate.onRedirect(response);
          }

          _this3.waitingToggle(false);
        },
        onReject: function onReject(response) {
          if (response.message.statusCode === 423) {
            // If a UA receives a 423 (Interval Too Brief) response, it MAY retry
            // the registration after making the expiration interval of all contact
            // addresses in the REGISTER request equal to or greater than the
            // expiration interval within the Min-Expires header field of the 423
            // (Interval Too Brief) response.
            // https://tools.ietf.org/html/rfc3261#section-10.2.8
            //
            // The registrar MAY choose an expiration less than the requested
            // expiration interval.  If and only if the requested expiration
            // interval is greater than zero AND smaller than one hour AND
            // less than a registrar-configured minimum, the registrar MAY
            // reject the registration with a response of 423 (Interval Too
            // Brief).  This response MUST contain a Min-Expires header field
            // that states the minimum expiration interval the registrar is
            // willing to honor.  It then skips the remaining steps.
            // https://tools.ietf.org/html/rfc3261#section-10.3
            if (!response.message.hasHeader("min-expires")) {
              // This response MUST contain a Min-Expires header field
              _this3.logger.error("423 response received for REGISTER without Min-Expires, dropping response");

              _this3.unregistered();

              _this3.waitingToggle(false);

              return;
            } // Increase our registration interval to the suggested minimum


            _this3.expires = Number(response.message.getHeader("min-expires")); // Attempt the registration again immediately

            _this3.waitingToggle(false);

            _this3.register();

            return;
          }

          _this3.logger.warn("Failed to register, status code ".concat(response.message.statusCode)); // The Retry-After header field can be used with a 500 (Server Internal
          // Error) or 503 (Service Unavailable) response to indicate how long the
          // service is expected to be unavailable to the requesting client...
          // https://tools.ietf.org/html/rfc3261#section-20.33


          var retryAfterDuration = NaN;

          if (response.message.statusCode === 500 || response.message.statusCode === 503) {
            var header = response.message.getHeader("retry-after");

            if (header) {
              retryAfterDuration = Number.parseInt(header, undefined);
            }
          } // Set for the state change (if any) and the delegate callback (if any)


          _this3._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;

          _this3.unregistered();

          if (options.requestDelegate && options.requestDelegate.onReject) {
            options.requestDelegate.onReject(response);
          }

          _this3._retryAfter = undefined;

          _this3.waitingToggle(false);
        },
        onTrying: function onTrying(response) {
          if (options.requestDelegate && options.requestDelegate.onTrying) {
            options.requestDelegate.onTrying(response);
          }
        }
      });
      return Promise.resolve(outgoingRegisterRequest);
    }
    /**
     * Sends the REGISTER request with expires equal to zero.
     * @remarks
     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.
     */

  }, {
    key: "unregister",
    value: function unregister() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.state === _registererState.RegistererState.Terminated) {
        this.stateError();
        throw new Error("Registerer terminated. Unable to register.");
      }

      if (this.disposed) {
        if (this.state !== _registererState.RegistererState.Registered) {
          // allows unregister while disposing and registered
          this.stateError();
          throw new Error("Registerer disposed. Unable to register.");
        }
      } // UAs MUST NOT send a new registration (that is, containing new Contact
      // header field values, as opposed to a retransmission) until they have
      // received a final response from the registrar for the previous one or
      // the previous REGISTER request has timed out.
      // https://tools.ietf.org/html/rfc3261#section-10.2


      if (this.waiting) {
        this.waitingWarning();
        var error = new _exceptions.RequestPendingError("REGISTER request already in progress, waiting for final response");
        return Promise.reject(error);
      }

      if (this._state !== _registererState.RegistererState.Registered && !options.all) {
        this.logger.warn("Not currently registered, but sending an unregister anyway.");
      } // Extra headers


      var extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();
      this.request.extraHeaders = extraHeaders; // Registrations are soft state and expire unless refreshed, but can
      // also be explicitly removed.  A client can attempt to influence the
      // expiration interval selected by the registrar as described in Section
      // 10.2.1.  A UA requests the immediate removal of a binding by
      // specifying an expiration interval of "0" for that contact address in
      // a REGISTER request.  UAs SHOULD support this mechanism so that
      // bindings can be removed before their expiration interval has passed.
      //
      // The REGISTER-specific Contact header field value of "*" applies to
      // all registrations, but it MUST NOT be used unless the Expires header
      // field is present with a value of "0".
      // https://tools.ietf.org/html/rfc3261#section-10.2.2

      if (options.all) {
        extraHeaders.push("Contact: *");
        extraHeaders.push("Expires: 0");
      } else {
        extraHeaders.push("Contact: " + this.generateContactHeader(0));
      } // Call-ID: All registrations from a UAC SHOULD use the same Call-ID
      // header field value for registrations sent to a particular
      // registrar.
      //
      // CSeq: The CSeq value guarantees proper ordering of REGISTER
      // requests.  A UA MUST increment the CSeq value by one for each
      // REGISTER request with the same Call-ID.
      // https://tools.ietf.org/html/rfc3261#section-10.2


      this.request.cseq++;
      this.request.setHeader("cseq", this.request.cseq + " REGISTER"); // Pre-emptive clear the registration timer to avoid a race condition where
      // this timer fires while waiting for a final response to the unsubscribe.

      if (this.registrationTimer !== undefined) {
        clearTimeout(this.registrationTimer);
        this.registrationTimer = undefined;
      }

      this.waitingToggle(true);
      var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {
        onAccept: function onAccept(response) {
          _this4._contacts = response.message.getHeaders("contact"); // Update contacts

          _this4.unregistered();

          if (options.requestDelegate && options.requestDelegate.onAccept) {
            options.requestDelegate.onAccept(response);
          }

          _this4.waitingToggle(false);
        },
        onProgress: function onProgress(response) {
          if (options.requestDelegate && options.requestDelegate.onProgress) {
            options.requestDelegate.onProgress(response);
          }
        },
        onRedirect: function onRedirect(response) {
          _this4.logger.error("Unregister redirected. Not currently supported.");

          _this4.unregistered();

          if (options.requestDelegate && options.requestDelegate.onRedirect) {
            options.requestDelegate.onRedirect(response);
          }

          _this4.waitingToggle(false);
        },
        onReject: function onReject(response) {
          _this4.logger.error("Unregister rejected with status code ".concat(response.message.statusCode));

          _this4.unregistered();

          if (options.requestDelegate && options.requestDelegate.onReject) {
            options.requestDelegate.onReject(response);
          }

          _this4.waitingToggle(false);
        },
        onTrying: function onTrying(response) {
          if (options.requestDelegate && options.requestDelegate.onTrying) {
            options.requestDelegate.onTrying(response);
          }
        }
      });
      return Promise.resolve(outgoingRegisterRequest);
    }
    /**
     * Clear registration timers.
     */

  }, {
    key: "clearTimers",
    value: function clearTimers() {
      if (this.registrationTimer !== undefined) {
        clearTimeout(this.registrationTimer);
        this.registrationTimer = undefined;
      }

      if (this.registrationExpiredTimer !== undefined) {
        clearTimeout(this.registrationExpiredTimer);
        this.registrationExpiredTimer = undefined;
      }
    }
    /**
     * Generate Contact Header
     */

  }, {
    key: "generateContactHeader",
    value: function generateContactHeader(expires) {
      var contact = this.userAgent.contact.toString();

      if (this.options.regId && this.options.instanceId) {
        contact += ";reg-id=" + this.options.regId;
        contact += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
      }

      if (this.options.extraContactHeaderParams) {
        this.options.extraContactHeaderParams.forEach(function (header) {
          contact += ";" + header;
        });
      }

      contact += ";expires=" + expires;
      return contact;
    }
    /**
     * Helper function, called when registered.
     */

  }, {
    key: "registered",
    value: function registered(expires) {
      var _this5 = this;

      this.clearTimers(); // Re-Register before the expiration interval has elapsed.
      // For that, calculate the delay as a percentage of the expiration time

      this.registrationTimer = setTimeout(function () {
        _this5.registrationTimer = undefined;

        _this5.register();
      }, this.refreshFrequency / 100 * expires * 1000); // We are unregistered if the registration expires.

      this.registrationExpiredTimer = setTimeout(function () {
        _this5.logger.warn("Registration expired");

        _this5.unregistered();
      }, expires * 1000);

      if (this._state !== _registererState.RegistererState.Registered) {
        this.stateTransition(_registererState.RegistererState.Registered);
      }
    }
    /**
     * Helper function, called when unregistered.
     */

  }, {
    key: "unregistered",
    value: function unregistered() {
      this.clearTimers();

      if (this._state !== _registererState.RegistererState.Unregistered) {
        this.stateTransition(_registererState.RegistererState.Unregistered);
      }
    }
    /**
     * Helper function, called when terminated.
     */

  }, {
    key: "terminated",
    value: function terminated() {
      this.clearTimers();

      if (this._state !== _registererState.RegistererState.Terminated) {
        this.stateTransition(_registererState.RegistererState.Terminated);
      }
    }
    /**
     * Transition registration state.
     */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this6 = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this6._state, " to ").concat(newState));
      }; // Validate transition


      switch (this._state) {
        case _registererState.RegistererState.Initial:
          if (newState !== _registererState.RegistererState.Registered && newState !== _registererState.RegistererState.Unregistered && newState !== _registererState.RegistererState.Terminated) {
            invalidTransition();
          }

          break;

        case _registererState.RegistererState.Registered:
          if (newState !== _registererState.RegistererState.Unregistered && newState !== _registererState.RegistererState.Terminated) {
            invalidTransition();
          }

          break;

        case _registererState.RegistererState.Unregistered:
          if (newState !== _registererState.RegistererState.Registered && newState !== _registererState.RegistererState.Terminated) {
            invalidTransition();
          }

          break;

        case _registererState.RegistererState.Terminated:
          invalidTransition();
          break;

        default:
          throw new Error("Unrecognized state.");
      } // Transition


      this._state = newState;
      this.logger.log("Registration transitioned to state ".concat(this._state));

      this._stateEventEmitter.emit(this._state); // Dispose


      if (newState === _registererState.RegistererState.Terminated) {
        this.dispose();
      }
    }
    /** True if the registerer is currently waiting for final response to a REGISTER request. */

  }, {
    key: "waiting",
    get: function get() {
      return this._waiting;
    }
    /** Emits when the registerer waiting state changes. */

  }, {
    key: "waitingChange",
    get: function get() {
      return this._waitingEventEmitter;
    }
    /**
     * Toggle waiting.
     */

  }, {
    key: "waitingToggle",
    value: function waitingToggle(waiting) {
      if (this._waiting === waiting) {
        throw new Error("Invalid waiting transition from ".concat(this._waiting, " to ").concat(waiting));
      }

      this._waiting = waiting;
      this.logger.log("Waiting toggled to ".concat(this._waiting));

      this._waitingEventEmitter.emit(this._waiting);
    }
    /** Hopefully helpful as the standard behavior has been found to be unexpected. */

  }, {
    key: "waitingWarning",
    value: function waitingWarning() {
      var message = "An attempt was made to send a REGISTER request while a prior one was still in progress.";
      message += " RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response";
      message += " from the registrar for the previous one or the previous REGISTER request has timed out.";
      message += " Note that if the transport disconnects, you still must wait for the prior request to time out before";
      message += " sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.";
      this.logger.warn(message);
    }
    /** Hopefully helpful as the standard behavior has been found to be unexpected. */

  }, {
    key: "stateError",
    value: function stateError() {
      var reason = this.state === _registererState.RegistererState.Terminated ? "is in 'Terminated' state" : "has been disposed";
      var message = "An attempt was made to send a REGISTER request when the Registerer ".concat(reason, ".");
      message += " The Registerer transitions to 'Terminated' when Registerer.dispose() is called.";
      message += " Perhaps you called UserAgent.stop() which dipsoses of all Registerers?";
      this.logger.error(message);
    }
  }], [{
    key: "defaultOptions",
    value: function defaultOptions() {
      return {
        expires: Registerer.defaultExpires,
        extraContactHeaderParams: [],
        extraHeaders: [],
        logConfiguration: true,
        instanceId: "",
        params: {},
        regId: 0,
        registrar: new _core.URI("sip", "anonymous", "anonymous.invalid"),
        refreshFrequency: Registerer.defaultRefreshFrequency
      };
    } // http://stackoverflow.com/users/109538/broofa

  }, {
    key: "newUUID",
    value: function newUUID() {
      var UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = Math.floor(Math.random() * 16);
        var v = c === "x" ? r : r % 4 + 8;
        return v.toString(16);
      });
      return UUID;
    }
    /**
     * Strip properties with undefined values from options.
     * This is a work around while waiting for missing vs undefined to be addressed (or not)...
     * https://github.com/Microsoft/TypeScript/issues/13195
     * @param options - Options to reduce
     */

  }, {
    key: "stripUndefinedProperties",
    value: function stripUndefinedProperties(options) {
      return Object.keys(options).reduce(function (object, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (options[key] !== undefined) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          object[key] = options[key];
        }

        return object;
      }, {});
    }
  }]);

  return Registerer;
}();

exports.Registerer = Registerer;
Registerer.defaultExpires = 600;
Registerer.defaultRefreshFrequency = 99;
},{"../core":"node_modules/sip.js/lib/core/index.js","./emitter":"node_modules/sip.js/lib/api/emitter.js","./exceptions":"node_modules/sip.js/lib/api/exceptions/index.js","./registerer-state":"node_modules/sip.js/lib/api/registerer-state.js"}],"node_modules/sip.js/lib/api/session-bye-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-description-handler-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-description-handler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-info-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-invite-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-message-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/session-refer-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscriber-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscriber-subscribe-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscription-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubscriptionState = void 0;

/**
 * {@link Subscription} state.
 * @remarks
 * The {@link Subscription} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                    _______________________________________
 * Subscription      |                                       v
 * Constructed -> Initial -> NotifyWait -> Subscribed -> Terminated
 *                              |____________________________^
 * ```
 * @public
 */
var SubscriptionState;
exports.SubscriptionState = SubscriptionState;

(function (SubscriptionState) {
  SubscriptionState["Initial"] = "Initial";
  SubscriptionState["NotifyWait"] = "NotifyWait";
  SubscriptionState["Subscribed"] = "Subscribed";
  SubscriptionState["Terminated"] = "Terminated";
})(SubscriptionState || (exports.SubscriptionState = SubscriptionState = {}));
},{}],"node_modules/sip.js/lib/api/subscription.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subscription = void 0;

var _emitter = require("./emitter");

var _subscriptionState = require("./subscription-state");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A subscription provides {@link Notification} of events.
 *
 * @remarks
 * See {@link Subscriber} for details on establishing a subscription.
 *
 * @public
 */
var Subscription = /*#__PURE__*/function () {
  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @internal
   */
  function Subscription(userAgent) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Subscription);

    this._disposed = false;
    this._state = _subscriptionState.SubscriptionState.Initial;
    this._logger = userAgent.getLogger("sip.Subscription");
    this._stateEventEmitter = new _emitter.EmitterImpl();
    this._userAgent = userAgent;
    this.delegate = options.delegate;
  }
  /**
   * Destructor.
   */


  _createClass(Subscription, [{
    key: "dispose",
    value: function dispose() {
      if (this._disposed) {
        return Promise.resolve();
      }

      this._disposed = true;

      this._stateEventEmitter.removeAllListeners();

      return Promise.resolve();
    }
    /**
     * The subscribed subscription dialog.
     */

  }, {
    key: "dialog",
    get: function get() {
      return this._dialog;
    }
    /**
     * True if disposed.
     * @internal
     */

  }, {
    key: "disposed",
    get: function get() {
      return this._disposed;
    }
    /**
     * Subscription state. See {@link SubscriptionState} for details.
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * Emits when the subscription `state` property changes.
     */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /** @internal */

  }, {
    key: "stateTransition",
    value: function stateTransition(newState) {
      var _this = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this._state, " to ").concat(newState));
      }; // Validate transition


      switch (this._state) {
        case _subscriptionState.SubscriptionState.Initial:
          if (newState !== _subscriptionState.SubscriptionState.NotifyWait && newState !== _subscriptionState.SubscriptionState.Terminated) {
            invalidTransition();
          }

          break;

        case _subscriptionState.SubscriptionState.NotifyWait:
          if (newState !== _subscriptionState.SubscriptionState.Subscribed && newState !== _subscriptionState.SubscriptionState.Terminated) {
            invalidTransition();
          }

          break;

        case _subscriptionState.SubscriptionState.Subscribed:
          if (newState !== _subscriptionState.SubscriptionState.Terminated) {
            invalidTransition();
          }

          break;

        case _subscriptionState.SubscriptionState.Terminated:
          invalidTransition();
          break;

        default:
          throw new Error("Unrecognized state.");
      } // Guard against duplicate transition


      if (this._state === newState) {
        return;
      } // Transition


      this._state = newState;

      this._logger.log("Subscription ".concat(this._dialog ? this._dialog.id : undefined, " transitioned to ").concat(this._state));

      this._stateEventEmitter.emit(this._state); // Dispose


      if (newState === _subscriptionState.SubscriptionState.Terminated) {
        this.dispose();
      }
    }
  }]);

  return Subscription;
}();

exports.Subscription = Subscription;
},{"./emitter":"node_modules/sip.js/lib/api/emitter.js","./subscription-state":"node_modules/sip.js/lib/api/subscription-state.js"}],"node_modules/sip.js/lib/api/subscriber.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subscriber = void 0;

var _core = require("../core");

var _allowedMethods = require("../core/user-agent-core/allowed-methods");

var _notification = require("./notification");

var _subscription = require("./subscription");

var _subscriptionState = require("./subscription-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).
 *
 * @remarks
 * This is (more or less) an implementation of a "subscriber" as
 * defined in RFC 6665 "SIP-Specific Event Notifications".
 * https://tools.ietf.org/html/rfc6665
 *
 * @example
 * ```ts
 * // Create a new subscriber.
 * const targetURI = new URI("sip", "alice", "example.com");
 * const eventType = "example-name"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml
 * const subscriber = new Subscriber(userAgent, targetURI, eventType);
 *
 * // Add delegate to handle event notifications.
 * subscriber.delegate = {
 *   onNotify: (notification: Notification) => {
 *     // handle notification here
 *   }
 * };
 *
 * // Monitor subscription state changes.
 * subscriber.stateChange.addListener((newState: SubscriptionState) => {
 *   if (newState === SubscriptionState.Terminated) {
 *     // handle state change here
 *   }
 * });
 *
 * // Attempt to establish the subscription
 * subscriber.subscribe();
 *
 * // Sometime later when done with subscription
 * subscriber.unsubscribe();
 * ```
 *
 * @public
 */
var Subscriber = /*#__PURE__*/function (_Subscription) {
  _inherits(Subscriber, _Subscription);

  var _super = _createSuper(Subscriber);

  /**
   * Constructor.
   * @param userAgent - User agent. See {@link UserAgent} for details.
   * @param targetURI - The request URI identifying the subscribed event.
   * @param eventType - The event type identifying the subscribed event.
   * @param options - Options bucket. See {@link SubscriberOptions} for details.
   */
  function Subscriber(userAgent, targetURI, eventType) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Subscriber);

    _this = _super.call(this, userAgent, options);
    _this.body = undefined;
    _this.logger = userAgent.getLogger("sip.Subscriber");

    if (options.body) {
      _this.body = {
        body: options.body,
        contentType: options.contentType ? options.contentType : "application/sdp"
      };
    }

    _this.targetURI = targetURI; // Subscription event

    _this.event = eventType; // Subscription expires

    if (options.expires === undefined) {
      _this.expires = 3600;
    } else if (typeof options.expires !== "number") {
      // pre-typescript type guard
      _this.logger.warn("Option \"expires\" must be a number. Using default of 3600.");

      _this.expires = 3600;
    } else {
      _this.expires = options.expires;
    } // Subscription extra headers


    _this.extraHeaders = (options.extraHeaders || []).slice(); // Subscription context.

    _this.subscriberRequest = _this.initSubscriberRequest();
    _this.outgoingRequestMessage = _this.subscriberRequest.message; // Add to UserAgent's collection

    _this.id = _this.outgoingRequestMessage.callId + _this.outgoingRequestMessage.from.parameters.tag + _this.event;
    _this._userAgent._subscriptions[_this.id] = _assertThisInitialized(_this);
    return _this;
  }
  /**
   * Destructor.
   * @internal
   */


  _createClass(Subscriber, [{
    key: "dispose",
    value: function dispose() {
      var _this2 = this;

      if (this.disposed) {
        return Promise.resolve();
      }

      this.logger.log("Subscription ".concat(this.id, " in state ").concat(this.state, " is being disposed")); // Remove from the user agent's subscription collection

      delete this._userAgent._subscriptions[this.id]; // Clear timers

      if (this.retryAfterTimer) {
        clearTimeout(this.retryAfterTimer);
        this.retryAfterTimer = undefined;
      } // Dispose subscriber request


      this.subscriberRequest.dispose(); // Make sure to dispose of our parent, then unsubscribe the
      // subscription dialog (if need be) and resolve when it has terminated.

      return _get(_getPrototypeOf(Subscriber.prototype), "dispose", this).call(this).then(function () {
        // If we have never subscribed there is nothing to wait on.
        // If we are already transitioned to terminated there is no need to unsubscribe again.
        if (_this2.state !== _subscriptionState.SubscriptionState.Subscribed) {
          return;
        }

        if (!_this2._dialog) {
          throw new Error("Dialog undefined.");
        }

        if (_this2._dialog.subscriptionState === _core.SubscriptionState.Pending || _this2._dialog.subscriptionState === _core.SubscriptionState.Active) {
          var dialog = _this2._dialog; // eslint-disable-next-line @typescript-eslint/no-unused-vars

          return new Promise(function (resolve, reject) {
            dialog.delegate = {
              onTerminated: function onTerminated() {
                return resolve();
              }
            };
            dialog.unsubscribe();
          });
        }
      });
    }
    /**
     * Subscribe to event notifications.
     *
     * @remarks
     * Send an initial SUBSCRIBE request if no subscription as been established.
     * Sends a re-SUBSCRIBE request if the subscription is "active".
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "subscribe",
    value: function subscribe() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      switch (this.subscriberRequest.state) {
        case _core.SubscriptionState.Initial:
          // we can end up here when retrying so only state transition if in SubscriptionState.Initial state
          if (this.state === _subscriptionState.SubscriptionState.Initial) {
            this.stateTransition(_subscriptionState.SubscriptionState.NotifyWait);
          }

          this.subscriberRequest.subscribe().then(function (result) {
            if (result.success) {
              if (result.success.subscription) {
                _this3._dialog = result.success.subscription;
                _this3._dialog.delegate = {
                  onNotify: function onNotify(request) {
                    return _this3.onNotify(request);
                  },
                  onRefresh: function onRefresh(request) {
                    return _this3.onRefresh(request);
                  },
                  onTerminated: function onTerminated() {
                    // If a call to unsubscribe will state transition to SubscriptionState.Terminated,
                    // but we can end up here after that if the NOTIFY never arrives and timer N fires.
                    if (_this3.state !== _subscriptionState.SubscriptionState.Terminated) {
                      _this3.stateTransition(_subscriptionState.SubscriptionState.Terminated);
                    }
                  }
                };
              }

              _this3.onNotify(result.success.request);
            } else if (result.failure) {
              _this3.unsubscribe();
            }
          });
          break;

        case _core.SubscriptionState.NotifyWait:
          break;

        case _core.SubscriptionState.Pending:
          break;

        case _core.SubscriptionState.Active:
          if (this._dialog) {
            var request = this._dialog.refresh();

            request.delegate = {
              onAccept: function onAccept(response) {
                return _this3.onAccepted(response);
              },
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              onRedirect: function onRedirect(response) {
                return _this3.unsubscribe();
              },
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              onReject: function onReject(response) {
                return _this3.unsubscribe();
              }
            };
          }

          break;

        case _core.SubscriptionState.Terminated:
          break;

        default:
          break;
      }

      return Promise.resolve();
    }
    /**
     * {@inheritDoc Subscription.unsubscribe}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.disposed) {
        return Promise.resolve();
      }

      switch (this.subscriberRequest.state) {
        case _core.SubscriptionState.Initial:
          break;

        case _core.SubscriptionState.NotifyWait:
          break;

        case _core.SubscriptionState.Pending:
          if (this._dialog) {
            this._dialog.unsubscribe(); // responses intentionally ignored

          }

          break;

        case _core.SubscriptionState.Active:
          if (this._dialog) {
            this._dialog.unsubscribe(); // responses intentionally ignored

          }

          break;

        case _core.SubscriptionState.Terminated:
          break;

        default:
          throw new Error("Unknown state.");
      }

      this.stateTransition(_subscriptionState.SubscriptionState.Terminated);
      return Promise.resolve();
    }
    /**
     * Sends a re-SUBSCRIBE request if the subscription is "active".
     * @deprecated Use `subscribe` instead.
     * @internal
     */

  }, {
    key: "_refresh",
    value: function _refresh() {
      if (this.subscriberRequest.state === _core.SubscriptionState.Active) {
        return this.subscribe();
      }

      return Promise.resolve();
    }
    /** @internal */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "onAccepted",
    value: function onAccepted(response) {// NOTE: If you think you should do something with this response,
      // please make sure you understand what it is you are doing and why.
      // Per the RFC, the first NOTIFY is all that actually matters.
    }
    /** @internal */

  }, {
    key: "onNotify",
    value: function onNotify(request) {
      var _this4 = this;

      // If we've set state to done, no further processing should take place
      // and we are only interested in cleaning up after the appropriate NOTIFY.
      if (this.disposed) {
        request.accept();
        return;
      } // State transition if needed.


      if (this.state !== _subscriptionState.SubscriptionState.Subscribed) {
        this.stateTransition(_subscriptionState.SubscriptionState.Subscribed);
      } // Delegate notification.


      if (this.delegate && this.delegate.onNotify) {
        var notification = new _notification.Notification(request);
        this.delegate.onNotify(notification);
      } else {
        request.accept();
      } //  If the "Subscription-State" value is SubscriptionState.Terminated, the subscriber
      //  MUST consider the subscription terminated.  The "expires" parameter
      //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an
      //  "expires" parameter on a "Subscription-State" header field with a
      //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such
      //  parameter, if present.  If a reason code is present, the client
      //  should behave as described below.  If no reason code or an unknown
      //  reason code is present, the client MAY attempt to re-subscribe at any
      //  time (unless a "retry-after" parameter is present, in which case the
      //  client SHOULD NOT attempt re-subscription until after the number of
      //  seconds specified by the "retry-after" parameter).  The reason codes
      //  defined by this document are:
      // https://tools.ietf.org/html/rfc6665#section-4.1.3


      var subscriptionState = request.message.parseHeader("Subscription-State");

      if (subscriptionState && subscriptionState.state) {
        switch (subscriptionState.state) {
          case "terminated":
            if (subscriptionState.reason) {
              this.logger.log("Terminated subscription with reason ".concat(subscriptionState.reason));

              switch (subscriptionState.reason) {
                case "deactivated":
                case "timeout":
                  this.initSubscriberRequest();
                  this.subscribe();
                  return;

                case "probation":
                case "giveup":
                  this.initSubscriberRequest();

                  if (subscriptionState.params && subscriptionState.params["retry-after"]) {
                    this.retryAfterTimer = setTimeout(function () {
                      _this4.subscribe();
                    }, subscriptionState.params["retry-after"]);
                  } else {
                    this.subscribe();
                  }

                  return;

                case "rejected":
                case "noresource":
                case "invariant":
                  break;
              }
            }

            this.unsubscribe();
            break;

          default:
            break;
        }
      }
    }
    /** @internal */

  }, {
    key: "onRefresh",
    value: function onRefresh(request) {
      var _this5 = this;

      request.delegate = {
        onAccept: function onAccept(response) {
          return _this5.onAccepted(response);
        }
      };
    }
  }, {
    key: "initSubscriberRequest",
    value: function initSubscriberRequest() {
      var _this6 = this;

      var options = {
        extraHeaders: this.extraHeaders,
        body: this.body ? (0, _core.fromBodyLegacy)(this.body) : undefined
      }; // eslint-disable-next-line @typescript-eslint/no-use-before-define

      this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);
      this.subscriberRequest.delegate = {
        onAccept: function onAccept(response) {
          return _this6.onAccepted(response);
        }
      };
      return this.subscriberRequest;
    }
  }]);

  return Subscriber;
}(_subscription.Subscription);

exports.Subscriber = Subscriber;

var SubscriberRequest = /*#__PURE__*/function () {
  function SubscriberRequest(core, target, event, expires, options, delegate) {
    _classCallCheck(this, SubscriberRequest);

    this.core = core;
    this.target = target;
    this.event = event;
    this.expires = expires;
    this.subscribed = false;
    this.logger = core.loggerFactory.getLogger("sip.Subscriber");
    this.delegate = delegate;

    var allowHeader = "Allow: " + _allowedMethods.AllowedMethods.toString();

    var extraHeaders = (options && options.extraHeaders || []).slice();
    extraHeaders.push(allowHeader);
    extraHeaders.push("Event: " + this.event);
    extraHeaders.push("Expires: " + this.expires);
    extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
    var body = options && options.body;
    this.message = core.makeOutgoingRequestMessage(_core.C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);
  }
  /** Destructor. */


  _createClass(SubscriberRequest, [{
    key: "dispose",
    value: function dispose() {
      if (this.request) {
        this.request.waitNotifyStop();
        this.request.dispose();
        this.request = undefined;
      }
    }
    /** Subscription state. */

  }, {
    key: "state",
    get: function get() {
      if (this.subscription) {
        return this.subscription.subscriptionState;
      } else if (this.subscribed) {
        return _core.SubscriptionState.NotifyWait;
      } else {
        return _core.SubscriptionState.Initial;
      }
    }
    /**
     * Establish subscription.
     * @param options Options bucket.
     */

  }, {
    key: "subscribe",
    value: function subscribe() {
      var _this7 = this;

      if (this.subscribed) {
        return Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?"));
      }

      this.subscribed = true;
      return new Promise(function (resolve) {
        if (!_this7.message) {
          throw new Error("Message undefined.");
        }

        _this7.request = _this7.core.subscribe(_this7.message, {
          // This SUBSCRIBE request will be confirmed with a final response.
          // 200-class responses indicate that the subscription has been accepted
          // and that a NOTIFY request will be sent immediately.
          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
          onAccept: function onAccept(response) {
            if (_this7.delegate && _this7.delegate.onAccept) {
              _this7.delegate.onAccept(response);
            }
          },
          // Due to the potential for out-of-order messages, packet loss, and
          // forking, the subscriber MUST be prepared to receive NOTIFY requests
          // before the SUBSCRIBE transaction has completed.
          // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
          onNotify: function onNotify(requestWithSubscription) {
            _this7.subscription = requestWithSubscription.subscription;

            if (_this7.subscription) {
              _this7.subscription.autoRefresh = true;
            }

            resolve({
              success: requestWithSubscription
            });
          },
          // If this Timer N expires prior to the receipt of a NOTIFY request,
          // the subscriber considers the subscription failed, and cleans up
          // any state associated with the subscription attempt.
          // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
          onNotifyTimeout: function onNotifyTimeout() {
            resolve({
              failure: {}
            });
          },
          // This SUBSCRIBE request will be confirmed with a final response.
          // Non-200-class final responses indicate that no subscription or new
          // dialog usage has been created, and no subsequent NOTIFY request will
          // be sent.
          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
          onRedirect: function onRedirect(response) {
            resolve({
              failure: {
                response: response
              }
            });
          },
          // This SUBSCRIBE request will be confirmed with a final response.
          // Non-200-class final responses indicate that no subscription or new
          // dialog usage has been created, and no subsequent NOTIFY request will
          // be sent.
          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
          onReject: function onReject(response) {
            resolve({
              failure: {
                response: response
              }
            });
          }
        });
      });
    }
  }]);

  return SubscriberRequest;
}();
},{"../core":"node_modules/sip.js/lib/core/index.js","../core/user-agent-core/allowed-methods":"node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js","./notification":"node_modules/sip.js/lib/api/notification.js","./subscription":"node_modules/sip.js/lib/api/subscription.js","./subscription-state":"node_modules/sip.js/lib/api/subscription-state.js"}],"node_modules/sip.js/lib/api/subscription-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscription-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscription-subscribe-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/subscription-unsubscribe-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/transport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/transport-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportState = void 0;

/**
 * {@link Transport} state.
 *
 * @remarks
 * The {@link Transport} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                    ______________________________
 *                   |    ____________              |
 * Transport         v   v            |             |
 * Constructed -> Disconnected -> Connecting -> Connected -> Disconnecting
 *                     ^            ^    |_____________________^  |  |
 *                     |            |_____________________________|  |
 *                     |_____________________________________________|
 * ```
 * @public
 */
var TransportState;
exports.TransportState = TransportState;

(function (TransportState) {
  /**
   * The `connect()` method was called.
   */
  TransportState["Connecting"] = "Connecting";
  /**
   * The `connect()` method resolved.
   */

  TransportState["Connected"] = "Connected";
  /**
   * The `disconnect()` method was called.
   */

  TransportState["Disconnecting"] = "Disconnecting";
  /**
   * The `connect()` method was rejected, or
   * the `disconnect()` method completed, or
   * network connectivity was lost.
   */

  TransportState["Disconnected"] = "Disconnected";
})(TransportState || (exports.TransportState = TransportState = {}));
},{}],"node_modules/sip.js/lib/api/user-agent-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/api/user-agent-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgentState = void 0;

/**
 * {@link UserAgent} state.
 * @remarks
 * Valid state transitions:
 * ```
 * 1. "Started" --> "Stopped"
 * 2. "Stopped" --> "Started"
 * ```
 * @public
 */
var UserAgentState;
exports.UserAgentState = UserAgentState;

(function (UserAgentState) {
  UserAgentState["Started"] = "Started";
  UserAgentState["Stopped"] = "Stopped";
})(UserAgentState || (exports.UserAgentState = UserAgentState = {}));
},{}],"node_modules/sip.js/lib/platform/web/transport/transport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = void 0;

var _emitter = require("../../../api/emitter");

var _exceptions = require("../../../api/exceptions");

var _transportState = require("../../../api/transport-state");

var _core = require("../../../core");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Transport for SIP over secure WebSocket (WSS).
 * @public
 */
var Transport = /*#__PURE__*/function () {
  function Transport(logger, options) {
    _classCallCheck(this, Transport);

    this._state = _transportState.TransportState.Disconnected;
    this.transitioningState = false; // state emitter

    this._stateEventEmitter = new _emitter.EmitterImpl(); // logger

    this.logger = logger; // guard deprecated options (remove this in version 16.x)

    if (options) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var optionsDeprecated = options;
      var wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;
      var maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;

      if (wsServersDeprecated !== undefined) {
        var deprecatedMessage = "The transport option \"wsServers\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
        this.logger.warn(deprecatedMessage);
      }

      if (maxReconnectionAttemptsDeprecated !== undefined) {
        var _deprecatedMessage = "The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";

        this.logger.warn(_deprecatedMessage);
      } // hack


      if (wsServersDeprecated && !options.server) {
        if (typeof wsServersDeprecated === "string") {
          options.server = wsServersDeprecated;
        }

        if (wsServersDeprecated instanceof Array) {
          options.server = wsServersDeprecated[0];
        }
      }
    } // initialize configuration


    this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options); // validate server URL

    var url = this.configuration.server;

    var parsed = _core.Grammar.parse(url, "absoluteURI");

    if (parsed === -1) {
      this.logger.error("Invalid WebSocket Server URL \"".concat(url, "\""));
      throw new Error("Invalid WebSocket Server URL");
    }

    if (!["wss", "ws", "udp"].includes(parsed.scheme)) {
      this.logger.error("Invalid scheme in WebSocket Server URL \"".concat(url, "\""));
      throw new Error("Invalid scheme in WebSocket Server URL");
    }

    this._protocol = parsed.scheme.toUpperCase();
  }

  _createClass(Transport, [{
    key: "dispose",
    value: function dispose() {
      return this.disconnect();
    }
    /**
     * The protocol.
     *
     * @remarks
     * Formatted as defined for the Via header sent-protocol transport.
     * https://tools.ietf.org/html/rfc3261#section-20.42
     */

  }, {
    key: "protocol",
    get: function get() {
      return this._protocol;
    }
    /**
     * The URL of the WebSocket Server.
     */

  }, {
    key: "server",
    get: function get() {
      return this.configuration.server;
    }
    /**
     * Transport state.
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * Transport state change emitter.
     */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /**
     * The WebSocket.
     */

  }, {
    key: "ws",
    get: function get() {
      return this._ws;
    }
    /**
     * Connect to network.
     * Resolves once connected. Otherwise rejects with an Error.
     */

  }, {
    key: "connect",
    value: function connect() {
      return this._connect();
    }
    /**
     * Disconnect from network.
     * Resolves once disconnected. Otherwise rejects with an Error.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._disconnect();
    }
    /**
     * Returns true if the `state` equals "Connected".
     * @remarks
     * This is equivalent to `state === TransportState.Connected`.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.state === _transportState.TransportState.Connected;
    }
    /**
     * Sends a message.
     * Resolves once message is sent. Otherwise rejects with an Error.
     * @param message - Message to send.
     */

  }, {
    key: "send",
    value: function send(message) {
      // Error handling is independent of whether the message was a request or
      // response.
      //
      // If the transport user asks for a message to be sent over an
      // unreliable transport, and the result is an ICMP error, the behavior
      // depends on the type of ICMP error.  Host, network, port or protocol
      // unreachable errors, or parameter problem errors SHOULD cause the
      // transport layer to inform the transport user of a failure in sending.
      // Source quench and TTL exceeded ICMP errors SHOULD be ignored.
      //
      // If the transport user asks for a request to be sent over a reliable
      // transport, and the result is a connection failure, the transport
      // layer SHOULD inform the transport user of a failure in sending.
      // https://tools.ietf.org/html/rfc3261#section-18.4
      return this._send(message);
    }
  }, {
    key: "_connect",
    value: function _connect() {
      var _this = this;

      this.logger.log("Connecting ".concat(this.server));

      switch (this.state) {
        case _transportState.TransportState.Connecting:
          // If `state` is "Connecting", `state` MUST NOT transition before returning.
          if (this.transitioningState) {
            return Promise.reject(this.transitionLoopDetectedError(_transportState.TransportState.Connecting));
          }

          if (!this.connectPromise) {
            throw new Error("Connect promise must be defined.");
          }

          return this.connectPromise;
        // Already connecting

        case _transportState.TransportState.Connected:
          // If `state` is "Connected", `state` MUST NOT transition before returning.
          if (this.transitioningState) {
            return Promise.reject(this.transitionLoopDetectedError(_transportState.TransportState.Connecting));
          }

          if (this.connectPromise) {
            throw new Error("Connect promise must not be defined.");
          }

          return Promise.resolve();
        // Already connected

        case _transportState.TransportState.Disconnecting:
          // If `state` is "Disconnecting", `state` MUST transition to "Connecting" before returning
          if (this.connectPromise) {
            throw new Error("Connect promise must not be defined.");
          }

          try {
            this.transitionState(_transportState.TransportState.Connecting);
          } catch (e) {
            if (e instanceof _exceptions.StateTransitionError) {
              return Promise.reject(e); // Loop detected
            }

            throw e;
          }

          break;

        case _transportState.TransportState.Disconnected:
          // If `state` is "Disconnected" `state` MUST transition to "Connecting" before returning
          if (this.connectPromise) {
            throw new Error("Connect promise must not be defined.");
          }

          try {
            this.transitionState(_transportState.TransportState.Connecting);
          } catch (e) {
            if (e instanceof _exceptions.StateTransitionError) {
              return Promise.reject(e); // Loop detected
            }

            throw e;
          }

          break;

        default:
          throw new Error("Unknown state");
      }

      var ws;

      try {
        // WebSocket()
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket
        ws = new WebSocket(this.server, "sip");
        ws.binaryType = "arraybuffer"; // set data type of received binary messages

        ws.addEventListener("close", function (ev) {
          return _this.onWebSocketClose(ev, ws);
        });
        ws.addEventListener("error", function (ev) {
          return _this.onWebSocketError(ev, ws);
        });
        ws.addEventListener("open", function (ev) {
          return _this.onWebSocketOpen(ev, ws);
        });
        ws.addEventListener("message", function (ev) {
          return _this.onWebSocketMessage(ev, ws);
        });
        this._ws = ws;
      } catch (error) {
        this._ws = undefined;
        this.logger.error("WebSocket construction failed.");
        this.logger.error(error);
        return new Promise(function (resolve, reject) {
          _this.connectResolve = resolve;
          _this.connectReject = reject; // The `state` MUST transition to "Disconnecting" or "Disconnected" before rejecting

          _this.transitionState(_transportState.TransportState.Disconnected, error);
        });
      }

      this.connectPromise = new Promise(function (resolve, reject) {
        _this.connectResolve = resolve;
        _this.connectReject = reject;
        _this.connectTimeout = setTimeout(function () {
          _this.logger.warn("Connect timed out. " + "Exceeded time set in configuration.connectionTimeout: " + _this.configuration.connectionTimeout + "s.");

          ws.close(1000); // careful here to use a local reference instead of this._ws
        }, _this.configuration.connectionTimeout * 1000);
      });
      return this.connectPromise;
    }
  }, {
    key: "_disconnect",
    value: function _disconnect() {
      var _this2 = this;

      this.logger.log("Disconnecting ".concat(this.server));

      switch (this.state) {
        case _transportState.TransportState.Connecting:
          // If `state` is "Connecting", `state` MUST transition to "Disconnecting" before returning.
          if (this.disconnectPromise) {
            throw new Error("Disconnect promise must not be defined.");
          }

          try {
            this.transitionState(_transportState.TransportState.Disconnecting);
          } catch (e) {
            if (e instanceof _exceptions.StateTransitionError) {
              return Promise.reject(e); // Loop detected
            }

            throw e;
          }

          break;

        case _transportState.TransportState.Connected:
          // If `state` is "Connected", `state` MUST transition to "Disconnecting" before returning.
          if (this.disconnectPromise) {
            throw new Error("Disconnect promise must not be defined.");
          }

          try {
            this.transitionState(_transportState.TransportState.Disconnecting);
          } catch (e) {
            if (e instanceof _exceptions.StateTransitionError) {
              return Promise.reject(e); // Loop detected
            }

            throw e;
          }

          break;

        case _transportState.TransportState.Disconnecting:
          // If `state` is "Disconnecting", `state` MUST NOT transition before returning.
          if (this.transitioningState) {
            return Promise.reject(this.transitionLoopDetectedError(_transportState.TransportState.Disconnecting));
          }

          if (!this.disconnectPromise) {
            throw new Error("Disconnect promise must be defined.");
          }

          return this.disconnectPromise;
        // Already disconnecting

        case _transportState.TransportState.Disconnected:
          // If `state` is "Disconnected", `state` MUST NOT transition before returning.
          if (this.transitioningState) {
            return Promise.reject(this.transitionLoopDetectedError(_transportState.TransportState.Disconnecting));
          }

          if (this.disconnectPromise) {
            throw new Error("Disconnect promise must not be defined.");
          }

          return Promise.resolve();
        // Already disconnected

        default:
          throw new Error("Unknown state");
      }

      if (!this._ws) {
        throw new Error("WebSocket must be defined.");
      }

      var ws = this._ws;
      this.disconnectPromise = new Promise(function (resolve, reject) {
        _this2.disconnectResolve = resolve;
        _this2.disconnectReject = reject;

        try {
          // WebSocket.close()
          // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close
          ws.close(1000); // careful here to use a local reference instead of this._ws
        } catch (error) {
          // Treating this as a coding error as it apparently can only happen
          // if you pass close() invalid parameters (so it should never happen)
          _this2.logger.error("WebSocket close failed.");

          _this2.logger.error(error);

          throw error;
        }
      });
      return this.disconnectPromise;
    }
  }, {
    key: "_send",
    value: function _send(message) {
      if (this.configuration.traceSip === true) {
        this.logger.log("Sending WebSocket message:\n\n" + message + "\n");
      }

      if (this._state !== _transportState.TransportState.Connected) {
        return Promise.reject(new Error("Not connected."));
      }

      if (!this._ws) {
        throw new Error("WebSocket undefined.");
      }

      try {
        // WebSocket.send()
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
        this._ws.send(message);
      } catch (error) {
        if (error instanceof Error) {
          return Promise.reject(error);
        }

        return Promise.reject(new Error("WebSocket send failed."));
      }

      return Promise.resolve();
    }
    /**
     * WebSocket "onclose" event handler.
     * @param ev - Event.
     */

  }, {
    key: "onWebSocketClose",
    value: function onWebSocketClose(ev, ws) {
      if (ws !== this._ws) {
        return;
      }

      var message = "WebSocket closed ".concat(this.server, " (code: ").concat(ev.code, ")");
      var error = !this.disconnectPromise ? new Error(message) : undefined;

      if (error) {
        this.logger.warn("WebSocket closed unexpectedly");
      }

      this.logger.log(message); // We are about to transition to disconnected, so clear our web socket

      this._ws = undefined; // The `state` MUST transition to "Disconnected" before resolving (assuming `state` is not already "Disconnected").

      this.transitionState(_transportState.TransportState.Disconnected, error);
    }
    /**
     * WebSocket "onerror" event handler.
     * @param ev - Event.
     */

  }, {
    key: "onWebSocketError",
    value: function onWebSocketError(ev, ws) {
      if (ws !== this._ws) {
        return;
      }

      this.logger.error("WebSocket error occurred.");
    }
    /**
     * WebSocket "onmessage" event handler.
     * @param ev - Event.
     */

  }, {
    key: "onWebSocketMessage",
    value: function onWebSocketMessage(ev, ws) {
      if (ws !== this._ws) {
        return;
      }

      var data = ev.data;
      var finishedData; // CRLF Keep Alive response from server. Clear our keep alive timeout.

      if (/^(\r\n)+$/.test(data)) {
        this.clearKeepAliveTimeout();

        if (this.configuration.traceSip === true) {
          this.logger.log("Received WebSocket message with CRLF Keep Alive response");
        }

        return;
      }

      if (!data) {
        this.logger.warn("Received empty message, discarding...");
        return;
      }

      if (typeof data !== "string") {
        // WebSocket binary message.
        try {
          finishedData = new TextDecoder().decode(new Uint8Array(data)); // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.
          // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.
          // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.
          // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));
        } catch (err) {
          this.logger.error(err);
          this.logger.error("Received WebSocket binary message failed to be converted into string, message discarded");
          return;
        }

        if (this.configuration.traceSip === true) {
          this.logger.log("Received WebSocket binary message:\n\n" + finishedData + "\n");
        }
      } else {
        // WebSocket text message.
        finishedData = data;

        if (this.configuration.traceSip === true) {
          this.logger.log("Received WebSocket text message:\n\n" + finishedData + "\n");
        }
      }

      if (this.state !== _transportState.TransportState.Connected) {
        this.logger.warn("Received message while not connected, discarding...");
        return;
      }

      if (this.onMessage) {
        try {
          this.onMessage(finishedData);
        } catch (e) {
          this.logger.error(e);
          this.logger.error("Exception thrown by onMessage callback");
          throw e; // rethrow unhandled exception
        }
      }
    }
    /**
     * WebSocket "onopen" event handler.
     * @param ev - Event.
     */

  }, {
    key: "onWebSocketOpen",
    value: function onWebSocketOpen(ev, ws) {
      if (ws !== this._ws) {
        return;
      }

      if (this._state === _transportState.TransportState.Connecting) {
        this.logger.log("WebSocket opened ".concat(this.server));
        this.transitionState(_transportState.TransportState.Connected);
      }
    }
    /**
     * Helper function to generate an Error.
     * @param state - State transitioning to.
     */

  }, {
    key: "transitionLoopDetectedError",
    value: function transitionLoopDetectedError(state) {
      var message = "A state transition loop has been detected.";
      message += " An attempt to transition from ".concat(this._state, " to ").concat(state, " before the prior transition completed.");
      message += " Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?";
      this.logger.error(message);
      return new _exceptions.StateTransitionError("Loop detected.");
    }
    /**
     * Transition transport state.
     * @internal
     */

  }, {
    key: "transitionState",
    value: function transitionState(newState, error) {
      var _this3 = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this3._state, " to ").concat(newState));
      };

      if (this.transitioningState) {
        throw this.transitionLoopDetectedError(newState);
      }

      this.transitioningState = true; // Validate state transition

      switch (this._state) {
        case _transportState.TransportState.Connecting:
          if (newState !== _transportState.TransportState.Connected && newState !== _transportState.TransportState.Disconnecting && newState !== _transportState.TransportState.Disconnected) {
            invalidTransition();
          }

          break;

        case _transportState.TransportState.Connected:
          if (newState !== _transportState.TransportState.Disconnecting && newState !== _transportState.TransportState.Disconnected) {
            invalidTransition();
          }

          break;

        case _transportState.TransportState.Disconnecting:
          if (newState !== _transportState.TransportState.Connecting && newState !== _transportState.TransportState.Disconnected) {
            invalidTransition();
          }

          break;

        case _transportState.TransportState.Disconnected:
          if (newState !== _transportState.TransportState.Connecting) {
            invalidTransition();
          }

          break;

        default:
          throw new Error("Unknown state.");
      } // Update state


      var oldState = this._state;
      this._state = newState; // Local copies of connect promises (guarding against callbacks changing them indirectly)
      // const connectPromise = this.connectPromise;

      var connectResolve = this.connectResolve;
      var connectReject = this.connectReject; // Reset connect promises if no longer connecting

      if (oldState === _transportState.TransportState.Connecting) {
        this.connectPromise = undefined;
        this.connectResolve = undefined;
        this.connectReject = undefined;
      } // Local copies of disconnect promises (guarding against callbacks changing them indirectly)
      // const disconnectPromise = this.disconnectPromise;


      var disconnectResolve = this.disconnectResolve;
      var disconnectReject = this.disconnectReject; // Reset disconnect promises if no longer disconnecting

      if (oldState === _transportState.TransportState.Disconnecting) {
        this.disconnectPromise = undefined;
        this.disconnectResolve = undefined;
        this.disconnectReject = undefined;
      } // Clear any outstanding connect timeout


      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }

      this.logger.log("Transitioned from ".concat(oldState, " to ").concat(this._state));

      this._stateEventEmitter.emit(this._state); //  Transition to Connected


      if (newState === _transportState.TransportState.Connected) {
        this.startSendingKeepAlives();

        if (this.onConnect) {
          try {
            this.onConnect();
          } catch (e) {
            this.logger.error(e);
            this.logger.error("Exception thrown by onConnect callback");
            throw e; // rethrow unhandled exception
          }
        }
      } //  Transition from Connected


      if (oldState === _transportState.TransportState.Connected) {
        this.stopSendingKeepAlives();

        if (this.onDisconnect) {
          try {
            if (error) {
              this.onDisconnect(error);
            } else {
              this.onDisconnect();
            }
          } catch (e) {
            this.logger.error(e);
            this.logger.error("Exception thrown by onDisconnect callback");
            throw e; // rethrow unhandled exception
          }
        }
      } // Complete connect promise


      if (oldState === _transportState.TransportState.Connecting) {
        if (!connectResolve) {
          throw new Error("Connect resolve undefined.");
        }

        if (!connectReject) {
          throw new Error("Connect reject undefined.");
        }

        newState === _transportState.TransportState.Connected ? connectResolve() : connectReject(error || new Error("Connect aborted."));
      } // Complete disconnect promise


      if (oldState === _transportState.TransportState.Disconnecting) {
        if (!disconnectResolve) {
          throw new Error("Disconnect resolve undefined.");
        }

        if (!disconnectReject) {
          throw new Error("Disconnect reject undefined.");
        }

        newState === _transportState.TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error("Disconnect aborted."));
      }

      this.transitioningState = false;
    } // TODO: Review "KeepAlive Stuff".
    // It is not clear if it works and there are no tests for it.
    // It was blindly lifted the keep alive code unchanged from earlier transport code.
    //
    // From the RFC...
    //
    // SIP WebSocket Clients and Servers may keep their WebSocket
    // connections open by sending periodic WebSocket "Ping" frames as
    // described in [RFC6455], Section 5.5.2.
    // ...
    // The indication and use of the CRLF NAT keep-alive mechanism defined
    // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or
    // [RFC6223] are, of course, usable over the transport defined in this
    // specification.
    // https://tools.ietf.org/html/rfc7118#section-6
    //
    // and...
    //
    // The Ping frame contains an opcode of 0x9.
    // https://tools.ietf.org/html/rfc6455#section-5.5.2
    //
    // ==============================
    // KeepAlive Stuff
    // ==============================

  }, {
    key: "clearKeepAliveTimeout",
    value: function clearKeepAliveTimeout() {
      if (this.keepAliveDebounceTimeout) {
        clearTimeout(this.keepAliveDebounceTimeout);
      }

      this.keepAliveDebounceTimeout = undefined;
    }
    /**
     * Send a keep-alive (a double-CRLF sequence).
     */

  }, {
    key: "sendKeepAlive",
    value: function sendKeepAlive() {
      var _this4 = this;

      if (this.keepAliveDebounceTimeout) {
        // We already have an outstanding keep alive, do not send another.
        return Promise.resolve();
      }

      this.keepAliveDebounceTimeout = setTimeout(function () {
        _this4.clearKeepAliveTimeout();
      }, this.configuration.keepAliveDebounce * 1000);
      return this.send("\r\n\r\n");
    }
    /**
     * Start sending keep-alives.
     */

  }, {
    key: "startSendingKeepAlives",
    value: function startSendingKeepAlives() {
      var _this5 = this;

      // Compute an amount of time in seconds to wait before sending another keep-alive.
      var computeKeepAliveTimeout = function computeKeepAliveTimeout(upperBound) {
        var lowerBound = upperBound * 0.8;
        return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
      };

      if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
        this.keepAliveInterval = setInterval(function () {
          _this5.sendKeepAlive();

          _this5.startSendingKeepAlives();
        }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
      }
    }
    /**
     * Stop sending keep-alives.
     */

  }, {
    key: "stopSendingKeepAlives",
    value: function stopSendingKeepAlives() {
      if (this.keepAliveInterval) {
        clearInterval(this.keepAliveInterval);
      }

      if (this.keepAliveDebounceTimeout) {
        clearTimeout(this.keepAliveDebounceTimeout);
      }

      this.keepAliveInterval = undefined;
      this.keepAliveDebounceTimeout = undefined;
    }
  }]);

  return Transport;
}();

exports.Transport = Transport;
Transport.defaultOptions = {
  server: "",
  connectionTimeout: 5,
  keepAliveInterval: 0,
  keepAliveDebounce: 10,
  traceSip: true
};
},{"../../../api/emitter":"node_modules/sip.js/lib/api/emitter.js","../../../api/exceptions":"node_modules/sip.js/lib/api/exceptions/index.js","../../../api/transport-state":"node_modules/sip.js/lib/api/transport-state.js","../../../core":"node_modules/sip.js/lib/core/index.js"}],"node_modules/sip.js/lib/platform/web/transport/transport-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/transport/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _transport = require("./transport");

Object.keys(_transport).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transport[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transport[key];
    }
  });
});

var _transportOptions = require("./transport-options");

Object.keys(_transportOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transportOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transportOptions[key];
    }
  });
});
},{"./transport":"node_modules/sip.js/lib/platform/web/transport/transport.js","./transport-options":"node_modules/sip.js/lib/platform/web/transport/transport-options.js"}],"node_modules/sip.js/lib/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LIBRARY_VERSION = void 0;
var LIBRARY_VERSION = "0.20.0";
exports.LIBRARY_VERSION = LIBRARY_VERSION;
},{}],"node_modules/sip.js/lib/api/user-agent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserAgent = void 0;

var _core = require("../core");

var _utils = require("../core/messages/utils");

var _sessionDescriptionHandler = require("../platform/web/session-description-handler");

var _transport = require("../platform/web/transport");

var _version = require("../version");

var _emitter = require("./emitter");

var _invitation = require("./invitation");

var _inviter = require("./inviter");

var _message = require("./message");

var _notification = require("./notification");

var _userAgentOptions = require("./user-agent-options");

var _userAgentState = require("./user-agent-state");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A user agent sends and receives requests using a `Transport`.
 *
 * @remarks
 * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)
 * and acts on behalf of that user to send and receive SIP requests. The user agent can
 * register to receive incoming requests, as well as create and send outbound messages.
 * The user agent also maintains the Transport over which its signaling travels.
 *
 * @public
 */
var UserAgent = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the `UserAgent` class.
   * @param options - Options bucket. See {@link UserAgentOptions} for details.
   */
  function UserAgent() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UserAgent);

    /** @internal */
    this._publishers = {};
    /** @internal */

    this._registerers = {};
    /** @internal */

    this._sessions = {};
    /** @internal */

    this._subscriptions = {};
    this._state = _userAgentState.UserAgentState.Stopped;
    /** Unload listener. */

    this.unloadListener = function () {
      _this.stop();
    }; // state emitter


    this._stateEventEmitter = new _emitter.EmitterImpl(); // initialize delegate

    this.delegate = options.delegate; // initialize configuration

    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), {
      sipjsId: (0, _utils.createRandomToken)(5)
    }), {
      uri: new _core.URI("sip", "anonymous." + (0, _utils.createRandomToken)(6), "anonymous.invalid")
    }), {
      viaHost: (0, _utils.createRandomToken)(12) + ".invalid"
    }), UserAgent.stripUndefinedProperties(options)); // viaHost is hack

    if (this.options.hackIpInContact) {
      if (typeof this.options.hackIpInContact === "boolean" && this.options.hackIpInContact) {
        var from = 1;
        var to = 254;
        var octet = Math.floor(Math.random() * (to - from + 1) + from); // random Test-Net IP (http://tools.ietf.org/html/rfc5735)

        this.options.viaHost = "192.0.2." + octet;
      } else if (this.options.hackIpInContact) {
        this.options.viaHost = this.options.hackIpInContact;
      }
    } // initialize logger & logger factory


    this.loggerFactory = new _core.LoggerFactory();
    this.logger = this.loggerFactory.getLogger("sip.UserAgent");
    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;
    this.loggerFactory.connector = this.options.logConnector;

    switch (this.options.logLevel) {
      case "error":
        this.loggerFactory.level = _core.Levels.error;
        break;

      case "warn":
        this.loggerFactory.level = _core.Levels.warn;
        break;

      case "log":
        this.loggerFactory.level = _core.Levels.log;
        break;

      case "debug":
        this.loggerFactory.level = _core.Levels.debug;
        break;

      default:
        break;
    }

    if (this.options.logConfiguration) {
      this.logger.log("Configuration:");
      Object.keys(this.options).forEach(function (key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var value = _this.options[key];

        switch (key) {
          case "uri":
          case "sessionDescriptionHandlerFactory":
            _this.logger.log(" " + key + ": " + value);

            break;

          case "authorizationPassword":
            _this.logger.log(" " + key + ": " + "NOT SHOWN");

            break;

          case "transportConstructor":
            _this.logger.log(" " + key + ": " + value.name);

            break;

          default:
            _this.logger.log(" " + key + ": " + JSON.stringify(value));

        }
      });
    } // guard deprecated transport options (remove this in version 16.x)


    if (this.options.transportOptions) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var optionsDeprecated = this.options.transportOptions;
      var maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;
      var reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;

      if (maxReconnectionAttemptsDeprecated !== undefined) {
        var deprecatedMessage = "The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";
        this.logger.warn(deprecatedMessage);
      }

      if (reconnectionTimeoutDeprecated !== undefined) {
        var _deprecatedMessage = "The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";

        this.logger.warn(_deprecatedMessage);
      } // hack


      if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {
        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;
      }

      if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {
        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;
      }
    } // guard deprecated user agent options (remove this in version 16.x)


    if (options.reconnectionDelay !== undefined) {
      var _deprecatedMessage2 = "The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";

      this.logger.warn(_deprecatedMessage2);
    }

    if (options.reconnectionAttempts !== undefined) {
      var _deprecatedMessage3 = "The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. " + "It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.";

      this.logger.warn(_deprecatedMessage3);
    } // Initialize Transport


    this._transport = new this.options.transportConstructor(this.getLogger("sip.Transport"), this.options.transportOptions);
    this.initTransportCallbacks(); // Initialize Contact

    this._contact = this.initContact(); // Initialize UserAgentCore

    this._userAgentCore = this.initCore();

    if (this.options.autoStart) {
      this.start();
    }
  }
  /**
   * Create a URI instance from a string.
   * @param uri - The string to parse.
   *
   * @example
   * ```ts
   * const uri = UserAgent.makeURI("sip:edgar@example.com");
   * ```
   */


  _createClass(UserAgent, [{
    key: "configuration",
    get:
    /**
     * User agent configuration.
     */
    function get() {
      return this.options;
    }
    /**
     * User agent contact.
     */

  }, {
    key: "contact",
    get: function get() {
      return this._contact;
    }
    /**
     * User agent state.
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
    /**
     * User agent state change emitter.
     */

  }, {
    key: "stateChange",
    get: function get() {
      return this._stateEventEmitter;
    }
    /**
     * User agent transport.
     */

  }, {
    key: "transport",
    get: function get() {
      return this._transport;
    }
    /**
     * User agent core.
     */

  }, {
    key: "userAgentCore",
    get: function get() {
      return this._userAgentCore;
    }
    /**
     * The logger.
     */

  }, {
    key: "getLogger",
    value: function getLogger(category, label) {
      return this.loggerFactory.getLogger(category, label);
    }
    /**
     * The logger factory.
     */

  }, {
    key: "getLoggerFactory",
    value: function getLoggerFactory() {
      return this.loggerFactory;
    }
    /**
     * True if transport is connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.transport.isConnected();
    }
    /**
     * Reconnect the transport.
     */

  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this2 = this;

      if (this.state === _userAgentState.UserAgentState.Stopped) {
        return Promise.reject(new Error("User agent stopped."));
      } // Make sure we don't call synchronously


      return Promise.resolve().then(function () {
        return _this2.transport.connect();
      });
    }
    /**
     * Start the user agent.
     *
     * @remarks
     * Resolves if transport connects, otherwise rejects.
     *
     * @example
     * ```ts
     * userAgent.start()
     *   .then(() => {
     *     // userAgent.isConnected() === true
     *   })
     *   .catch((error: Error) => {
     *     // userAgent.isConnected() === false
     *   });
     * ```
     */

  }, {
    key: "start",
    value: function start() {
      if (this.state === _userAgentState.UserAgentState.Started) {
        this.logger.warn("User agent already started");
        return Promise.resolve();
      }

      this.logger.log("Starting ".concat(this.configuration.uri)); // Transition state

      this.transitionState(_userAgentState.UserAgentState.Started); // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.
      // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this
      // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.
      // Should this perhaps be deprecated?
      //
      // Add window unload event listener

      if (this.options.autoStop) {
        // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
        var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;

        if (typeof window !== "undefined" && typeof window.addEventListener === "function" && !googleChromePackagedApp) {
          window.addEventListener("unload", this.unloadListener);
        }
      }

      return this.transport.connect();
    }
    /**
     * Stop the user agent.
     *
     * @remarks
     * Resolves when the user agent has completed a graceful shutdown.
     * ```txt
     * 1) Sessions terminate.
     * 2) Registerers unregister.
     * 3) Subscribers unsubscribe.
     * 4) Publishers unpublish.
     * 5) Transport disconnects.
     * 6) User Agent Core resets.
     * ```
     * NOTE: While this is a "graceful shutdown", it can also be very slow one if you
     * are waiting for the returned Promise to resolve. The disposal of the clients and
     * dialogs is done serially - waiting on one to finish before moving on to the next.
     * This can be slow if there are lot of subscriptions to unsubscribe for example.
     *
     * THE SLOW PACE IS INTENTIONAL!
     * While one could spin them all down in parallel, this could slam the remote server.
     * It is bad practice to denial of service attack (DoS attack) servers!!!
     * Moreover, production servers will automatically blacklist clients which send too
     * many requests in too short a period of time - dropping any additional requests.
     *
     * If a different approach to disposing is needed, one can implement whatever is
     * needed and execute that prior to calling `stop()`. Alternatively one may simply
     * not wait for the Promise returned by `stop()` to complete.
     */

  }, {
    key: "stop",
    value: function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this3 = this;

        var googleChromePackagedApp, publishers, registerers, sessions, subscriptions, transport, userAgentCore, _loop, id, _loop2, _id, _loop3, _id2, _loop4, _id3;

        return _regeneratorRuntime().wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(this.state === _userAgentState.UserAgentState.Stopped)) {
                  _context5.next = 3;
                  break;
                }

                this.logger.warn("User agent already stopped");
                return _context5.abrupt("return", Promise.resolve());

              case 3:
                this.logger.log("Stopping ".concat(this.configuration.uri)); // Transition state

                this.transitionState(_userAgentState.UserAgentState.Stopped); // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?
                // Remove window unload event listener

                if (this.options.autoStop) {
                  // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
                  googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;

                  if (typeof window !== "undefined" && window.removeEventListener && !googleChromePackagedApp) {
                    window.removeEventListener("unload", this.unloadListener);
                  }
                } // Be careful here to use a local references as start() can be called
                // again before we complete and we don't want to touch new clients
                // and we don't want to step on the new instances (or vice versa).


                publishers = Object.assign({}, this._publishers);
                registerers = Object.assign({}, this._registerers);
                sessions = Object.assign({}, this._sessions);
                subscriptions = Object.assign({}, this._subscriptions);
                transport = this.transport;
                userAgentCore = this.userAgentCore; //
                // At this point we have completed the state transition and everything
                // following will effectively run async and MUST NOT cause any issues
                // if UserAgent.start() is called while the following code continues.
                //
                // TODO: Minor optimization.
                // The disposal in all cases involves, in part, sending messages which
                // is not worth doing if the transport is not connected as we know attempting
                // to send messages will be futile. But none of these disposal methods check
                // if that's is the case and it would be easy for them to do so at this point.
                // Dispose of Registerers

                this.logger.log("Dispose of registerers");
                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(id) {
                  return _regeneratorRuntime().wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!registerers[id]) {
                            _context.next = 3;
                            break;
                          }

                          _context.next = 3;
                          return registerers[id].dispose().catch(function (error) {
                            _this3.logger.error(error.message);

                            delete _this3._registerers[id];
                            throw error;
                          });

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _loop);
                });
                _context5.t0 = _regeneratorRuntime().keys(registerers);

              case 15:
                if ((_context5.t1 = _context5.t0()).done) {
                  _context5.next = 20;
                  break;
                }

                id = _context5.t1.value;
                return _context5.delegateYield(_loop(id), "t2", 18);

              case 18:
                _context5.next = 15;
                break;

              case 20:
                // Dispose of Sessions
                this.logger.log("Dispose of sessions");
                _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2(_id) {
                  return _regeneratorRuntime().wrap(function _loop2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          if (!sessions[_id]) {
                            _context2.next = 3;
                            break;
                          }

                          _context2.next = 3;
                          return sessions[_id].dispose().catch(function (error) {
                            _this3.logger.error(error.message);

                            delete _this3._sessions[_id];
                            throw error;
                          });

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _loop2);
                });
                _context5.t3 = _regeneratorRuntime().keys(sessions);

              case 23:
                if ((_context5.t4 = _context5.t3()).done) {
                  _context5.next = 28;
                  break;
                }

                _id = _context5.t4.value;
                return _context5.delegateYield(_loop2(_id), "t5", 26);

              case 26:
                _context5.next = 23;
                break;

              case 28:
                // Dispose of Subscriptions
                this.logger.log("Dispose of subscriptions");
                _loop3 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop3(_id2) {
                  return _regeneratorRuntime().wrap(function _loop3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          if (!subscriptions[_id2]) {
                            _context3.next = 3;
                            break;
                          }

                          _context3.next = 3;
                          return subscriptions[_id2].dispose().catch(function (error) {
                            _this3.logger.error(error.message);

                            delete _this3._subscriptions[_id2];
                            throw error;
                          });

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _loop3);
                });
                _context5.t6 = _regeneratorRuntime().keys(subscriptions);

              case 31:
                if ((_context5.t7 = _context5.t6()).done) {
                  _context5.next = 36;
                  break;
                }

                _id2 = _context5.t7.value;
                return _context5.delegateYield(_loop3(_id2), "t8", 34);

              case 34:
                _context5.next = 31;
                break;

              case 36:
                // Dispose of Publishers
                this.logger.log("Dispose of publishers");
                _loop4 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop4(_id3) {
                  return _regeneratorRuntime().wrap(function _loop4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          if (!publishers[_id3]) {
                            _context4.next = 3;
                            break;
                          }

                          _context4.next = 3;
                          return publishers[_id3].dispose().catch(function (error) {
                            _this3.logger.error(error.message);

                            delete _this3._publishers[_id3];
                            throw error;
                          });

                        case 3:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _loop4);
                });
                _context5.t9 = _regeneratorRuntime().keys(publishers);

              case 39:
                if ((_context5.t10 = _context5.t9()).done) {
                  _context5.next = 44;
                  break;
                }

                _id3 = _context5.t10.value;
                return _context5.delegateYield(_loop4(_id3), "t11", 42);

              case 42:
                _context5.next = 39;
                break;

              case 44:
                // Dispose of the transport (disconnecting)
                this.logger.log("Dispose of transport");
                _context5.next = 47;
                return transport.dispose().catch(function (error) {
                  _this3.logger.error(error.message);

                  throw error;
                });

              case 47:
                // Dispose of the user agent core (resetting)
                this.logger.log("Dispose of core");
                userAgentCore.dispose();

              case 49:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
    /**
     * Used to avoid circular references.
     * @internal
     */

  }, {
    key: "_makeInviter",
    value: function _makeInviter(targetURI, options) {
      return new _inviter.Inviter(this, targetURI, options);
    }
    /**
     * Attempt reconnection up to `maxReconnectionAttempts` times.
     * @param reconnectionAttempt - Current attempt number.
     */

  }, {
    key: "attemptReconnection",
    value: function attemptReconnection() {
      var _this4 = this;

      var reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var reconnectionAttempts = this.options.reconnectionAttempts;
      var reconnectionDelay = this.options.reconnectionDelay;

      if (reconnectionAttempt > reconnectionAttempts) {
        this.logger.log("Maximum reconnection attempts reached");
        return;
      }

      this.logger.log("Reconnection attempt ".concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - trying"));
      setTimeout(function () {
        _this4.reconnect().then(function () {
          _this4.logger.log("Reconnection attempt ".concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - succeeded"));
        }).catch(function (error) {
          _this4.logger.error(error.message);

          _this4.logger.log("Reconnection attempt ".concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - failed"));

          _this4.attemptReconnection(++reconnectionAttempt);
        });
      }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);
    }
    /**
     * Initialize contact.
     */

  }, {
    key: "initContact",
    value: function initContact() {
      var _this5 = this;

      var contactName = this.options.contactName !== "" ? this.options.contactName : (0, _utils.createRandomToken)(8);
      var contactParams = this.options.contactParams;
      var contact = {
        pubGruu: undefined,
        tempGruu: undefined,
        uri: new _core.URI("sip", contactName, this.options.viaHost, undefined, contactParams),
        toString: function toString() {
          var contactToStringOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var anonymous = contactToStringOptions.anonymous || false;
          var outbound = contactToStringOptions.outbound || false;
          var contactString = "<";

          if (anonymous) {
            contactString += _this5.contact.tempGruu || "sip:anonymous@anonymous.invalid;transport=".concat(contactParams.transport ? contactParams.transport : "ws");
          } else {
            contactString += _this5.contact.pubGruu || _this5.contact.uri;
          }

          if (outbound) {
            contactString += ";ob";
          }

          contactString += ">";
          return contactString;
        }
      };
      return contact;
    }
    /**
     * Initialize user agent core.
     */

  }, {
    key: "initCore",
    value: function initCore() {
      var _this6 = this;

      // supported options
      var supportedOptionTags = [];
      supportedOptionTags.push("outbound"); // TODO: is this really supported?

      if (this.options.sipExtension100rel === _userAgentOptions.SIPExtension.Supported) {
        supportedOptionTags.push("100rel");
      }

      if (this.options.sipExtensionReplaces === _userAgentOptions.SIPExtension.Supported) {
        supportedOptionTags.push("replaces");
      }

      if (this.options.sipExtensionExtraSupported) {
        var _supportedOptionTags;

        (_supportedOptionTags = supportedOptionTags).push.apply(_supportedOptionTags, _toConsumableArray(this.options.sipExtensionExtraSupported));
      }

      if (!this.options.hackAllowUnregisteredOptionTags) {
        supportedOptionTags = supportedOptionTags.filter(function (optionTag) {
          return _userAgentOptions.UserAgentRegisteredOptionTags[optionTag];
        });
      }

      supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values
      // FIXME: TODO: This was ported, but this is and was just plain broken.

      var supportedOptionTagsResponse = supportedOptionTags.slice();

      if (this.contact.pubGruu || this.contact.tempGruu) {
        supportedOptionTagsResponse.push("gruu");
      } // core configuration


      var userAgentCoreConfiguration = {
        aor: this.options.uri,
        contact: this.contact,
        displayName: this.options.displayName,
        loggerFactory: this.loggerFactory,
        hackViaTcp: this.options.hackViaTcp,
        routeSet: this.options.preloadedRouteSet,
        supportedOptionTags: supportedOptionTags,
        supportedOptionTagsResponse: supportedOptionTagsResponse,
        sipjsId: this.options.sipjsId,
        userAgentHeaderFieldValue: this.options.userAgentString,
        viaForceRport: this.options.forceRport,
        viaHost: this.options.viaHost,
        authenticationFactory: function authenticationFactory() {
          var username = _this6.options.authorizationUsername ? _this6.options.authorizationUsername : _this6.options.uri.user; // if authorization username not provided, use uri user as username

          var password = _this6.options.authorizationPassword ? _this6.options.authorizationPassword : undefined;
          var ha1 = _this6.options.authorizationHa1 ? _this6.options.authorizationHa1 : undefined;
          return new _core.DigestAuthentication(_this6.getLoggerFactory(), ha1, username, password);
        },
        transportAccessor: function transportAccessor() {
          return _this6.transport;
        }
      };
      var userAgentCoreDelegate = {
        onInvite: function onInvite(incomingInviteRequest) {
          var _a;

          var invitation = new _invitation.Invitation(_this6, incomingInviteRequest);
          incomingInviteRequest.delegate = {
            onCancel: function onCancel(cancel) {
              invitation._onCancel(cancel);
            },
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onTransportError: function onTransportError(error) {
              // A server transaction MUST NOT discard transaction state based only on
              // encountering a non-recoverable transport error when sending a
              // response.  Instead, the associated INVITE server transaction state
              // machine MUST remain in its current state.  (Timers will eventually
              // cause it to transition to the "Terminated" state).
              // https://tools.ietf.org/html/rfc6026#section-7.1
              // As noted in the comment above, we are to leaving it to the transaction
              // timers to eventually cause the transaction to sort itself out in the case
              // of a transport failure in an invite server transaction. This delegate method
              // is here simply here for completeness and to make it clear that it provides
              // nothing more than informational hook into the core. That is, if you think
              // you should be trying to deal with a transport error here, you are likely wrong.
              _this6.logger.error("A transport error has occurred while handling an incoming INVITE request.");
            }
          }; // FIXME: Ported - 100 Trying send should be configurable.
          // Only required if TU will not respond in 200ms.
          // https://tools.ietf.org/html/rfc3261#section-17.2.1

          incomingInviteRequest.trying(); // The Replaces header contains information used to match an existing
          // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE
          // with a Replaces header, the User Agent (UA) attempts to match this
          // information with a confirmed or early dialog.
          // https://tools.ietf.org/html/rfc3891#section-3

          if (_this6.options.sipExtensionReplaces !== _userAgentOptions.SIPExtension.Unsupported) {
            var message = incomingInviteRequest.message;
            var replaces = message.parseHeader("replaces");

            if (replaces) {
              var callId = replaces.call_id;

              if (typeof callId !== "string") {
                throw new Error("Type of call id is not string");
              }

              var toTag = replaces.replaces_to_tag;

              if (typeof toTag !== "string") {
                throw new Error("Type of to tag is not string");
              }

              var fromTag = replaces.replaces_from_tag;

              if (typeof fromTag !== "string") {
                throw new Error("type of from tag is not string");
              }

              var targetDialogId = callId + toTag + fromTag;

              var targetDialog = _this6.userAgentCore.dialogs.get(targetDialogId); // If no match is found, the UAS rejects the INVITE and returns a 481
              // Call/Transaction Does Not Exist response.  Likewise, if the Replaces
              // header field matches a dialog which was not created with an INVITE,
              // the UAS MUST reject the request with a 481 response.
              // https://tools.ietf.org/html/rfc3891#section-3


              if (!targetDialog) {
                invitation.reject({
                  statusCode: 481
                });
                return;
              } // If the Replaces header field matches a confirmed dialog, it checks
              // for the presence of the "early-only" flag in the Replaces header
              // field.  (This flag allows the UAC to prevent a potentially
              // undesirable race condition described in Section 7.1.) If the flag is
              // present, the UA rejects the request with a 486 Busy response.
              // https://tools.ietf.org/html/rfc3891#section-3


              if (!targetDialog.early && replaces.early_only === true) {
                invitation.reject({
                  statusCode: 486
                });
                return;
              } // Provide a handle on the session being replaced.


              var targetSession = _this6._sessions[callId + fromTag] || _this6._sessions[callId + toTag] || undefined;

              if (!targetSession) {
                throw new Error("Session does not exist.");
              }

              invitation._replacee = targetSession;
            }
          } // Delegate invitation handling.


          if ((_a = _this6.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {
            if (invitation.autoSendAnInitialProvisionalResponse) {
              invitation.progress().then(function () {
                var _a;

                if (((_a = _this6.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {
                  throw new Error("onInvite undefined.");
                }

                _this6.delegate.onInvite(invitation);
              });
              return;
            }

            _this6.delegate.onInvite(invitation);

            return;
          } // A common scenario occurs when the callee is currently not willing or
          // able to take additional calls at this end system.  A 486 (Busy Here)
          // SHOULD be returned in such a scenario.
          // https://tools.ietf.org/html/rfc3261#section-13.3.1.3


          invitation.reject({
            statusCode: 486
          });
        },
        onMessage: function onMessage(incomingMessageRequest) {
          if (_this6.delegate && _this6.delegate.onMessage) {
            var message = new _message.Message(incomingMessageRequest);

            _this6.delegate.onMessage(message);
          } else {
            // Accept the MESSAGE request, but do nothing with it.
            incomingMessageRequest.accept();
          }
        },
        onNotify: function onNotify(incomingNotifyRequest) {
          // NOTIFY requests are sent to inform subscribers of changes in state to
          // which the subscriber has a subscription.  Subscriptions are created
          // using the SUBSCRIBE method.  In legacy implementations, it is
          // possible that other means of subscription creation have been used.
          // However, this specification does not allow the creation of
          // subscriptions except through SUBSCRIBE requests and (for backwards-
          // compatibility) REFER requests [RFC3515].
          // https://tools.ietf.org/html/rfc6665#section-3.2
          if (_this6.delegate && _this6.delegate.onNotify) {
            var notification = new _notification.Notification(incomingNotifyRequest);

            _this6.delegate.onNotify(notification);
          } else {
            // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,
            // the use of out of dialog NOTIFY is obsolete, but...
            if (_this6.options.allowLegacyNotifications) {
              incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.
            } else {
              incomingNotifyRequest.reject({
                statusCode: 481
              });
            }
          }
        },
        onRefer: function onRefer(incomingReferRequest) {
          _this6.logger.warn("Received an out of dialog REFER request"); // TOOD: this.delegate.onRefer(...)


          if (_this6.delegate && _this6.delegate.onReferRequest) {
            _this6.delegate.onReferRequest(incomingReferRequest);
          } else {
            incomingReferRequest.reject({
              statusCode: 405
            });
          }
        },
        onRegister: function onRegister(incomingRegisterRequest) {
          _this6.logger.warn("Received an out of dialog REGISTER request"); // TOOD: this.delegate.onRegister(...)


          if (_this6.delegate && _this6.delegate.onRegisterRequest) {
            _this6.delegate.onRegisterRequest(incomingRegisterRequest);
          } else {
            incomingRegisterRequest.reject({
              statusCode: 405
            });
          }
        },
        onSubscribe: function onSubscribe(incomingSubscribeRequest) {
          _this6.logger.warn("Received an out of dialog SUBSCRIBE request"); // TOOD: this.delegate.onSubscribe(...)


          if (_this6.delegate && _this6.delegate.onSubscribeRequest) {
            _this6.delegate.onSubscribeRequest(incomingSubscribeRequest);
          } else {
            incomingSubscribeRequest.reject({
              statusCode: 405
            });
          }
        }
      };
      return new _core.UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);
    }
  }, {
    key: "initTransportCallbacks",
    value: function initTransportCallbacks() {
      var _this7 = this;

      this.transport.onConnect = function () {
        return _this7.onTransportConnect();
      };

      this.transport.onDisconnect = function (error) {
        return _this7.onTransportDisconnect(error);
      };

      this.transport.onMessage = function (message) {
        return _this7.onTransportMessage(message);
      };
    }
  }, {
    key: "onTransportConnect",
    value: function onTransportConnect() {
      if (this.state === _userAgentState.UserAgentState.Stopped) {
        return;
      }

      if (this.delegate && this.delegate.onConnect) {
        this.delegate.onConnect();
      }
    }
  }, {
    key: "onTransportDisconnect",
    value: function onTransportDisconnect(error) {
      if (this.state === _userAgentState.UserAgentState.Stopped) {
        return;
      }

      if (this.delegate && this.delegate.onDisconnect) {
        this.delegate.onDisconnect(error);
      } // Only attempt to reconnect if network/server dropped the connection.


      if (error && this.options.reconnectionAttempts > 0) {
        this.attemptReconnection();
      }
    }
  }, {
    key: "onTransportMessage",
    value: function onTransportMessage(messageString) {
      var _this8 = this;

      var message = _core.Parser.parseMessage(messageString, this.getLogger("sip.Parser"));

      if (!message) {
        this.logger.warn("Failed to parse incoming message. Dropping.");
        return;
      }

      if (this.state === _userAgentState.UserAgentState.Stopped && message instanceof _core.IncomingRequestMessage) {
        this.logger.warn("Received ".concat(message.method, " request while stopped. Dropping."));
        return;
      } // A valid SIP request formulated by a UAC MUST, at a minimum, contain
      // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,
      // and Via; all of these header fields are mandatory in all SIP
      // requests.
      // https://tools.ietf.org/html/rfc3261#section-8.1.1


      var hasMinimumHeaders = function hasMinimumHeaders() {
        var mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];

        for (var _i = 0, _mandatoryHeaders = mandatoryHeaders; _i < _mandatoryHeaders.length; _i++) {
          var header = _mandatoryHeaders[_i];

          if (!message.hasHeader(header)) {
            _this8.logger.warn("Missing mandatory header field : ".concat(header, "."));

            return false;
          }
        }

        return true;
      }; // Request Checks


      if (message instanceof _core.IncomingRequestMessage) {
        // This is port of SanityCheck.minimumHeaders().
        if (!hasMinimumHeaders()) {
          this.logger.warn("Request missing mandatory header field. Dropping.");
          return;
        } // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).
        // Custom SIP.js check to reject request from ourself (this instance of SIP.js).
        // This is port of SanityCheck.rfc3261_16_3_4().


        if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {
          this.userAgentCore.replyStateless(message, {
            statusCode: 482
          });
          return;
        } // FIXME: This should be Transport check before we get here (Section 18).
        // Custom SIP.js check to reject requests if body length wrong.
        // This is port of SanityCheck.rfc3261_18_3_request().


        var len = (0, _utils.utf8Length)(message.body);
        var contentLength = message.getHeader("content-length");

        if (contentLength && len < Number(contentLength)) {
          this.userAgentCore.replyStateless(message, {
            statusCode: 400
          });
          return;
        }
      } // Response Checks


      if (message instanceof _core.IncomingResponseMessage) {
        // This is port of SanityCheck.minimumHeaders().
        if (!hasMinimumHeaders()) {
          this.logger.warn("Response missing mandatory header field. Dropping.");
          return;
        } // Custom SIP.js check to drop responses if multiple Via headers.
        // This is port of SanityCheck.rfc3261_8_1_3_3().


        if (message.getHeaders("via").length > 1) {
          this.logger.warn("More than one Via header field present in the response. Dropping.");
          return;
        } // FIXME: This should be Transport check before we get here (Section 18).
        // Custom SIP.js check to drop responses if bad Via header.
        // This is port of SanityCheck.rfc3261_18_1_2().


        if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {
          this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
          return;
        } // FIXME: This should be Transport check before we get here (Section 18).
        // Custom SIP.js check to reject requests if body length wrong.
        // This is port of SanityCheck.rfc3261_18_3_response().


        var _len = (0, _utils.utf8Length)(message.body);

        var _contentLength = message.getHeader("content-length");

        if (_contentLength && _len < Number(_contentLength)) {
          this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
          return;
        }
      } // Handle Request


      if (message instanceof _core.IncomingRequestMessage) {
        this.userAgentCore.receiveIncomingRequestFromTransport(message);
        return;
      } // Handle Response


      if (message instanceof _core.IncomingResponseMessage) {
        this.userAgentCore.receiveIncomingResponseFromTransport(message);
        return;
      }

      throw new Error("Invalid message type.");
    }
    /**
     * Transition state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars

  }, {
    key: "transitionState",
    value: function transitionState(newState, error) {
      var _this9 = this;

      var invalidTransition = function invalidTransition() {
        throw new Error("Invalid state transition from ".concat(_this9._state, " to ").concat(newState));
      }; // Validate state transition


      switch (this._state) {
        case _userAgentState.UserAgentState.Started:
          if (newState !== _userAgentState.UserAgentState.Stopped) {
            invalidTransition();
          }

          break;

        case _userAgentState.UserAgentState.Stopped:
          if (newState !== _userAgentState.UserAgentState.Started) {
            invalidTransition();
          }

          break;

        default:
          throw new Error("Unknown state.");
      } // Update state


      this.logger.log("Transitioned from ".concat(this._state, " to ").concat(newState));
      this._state = newState;

      this._stateEventEmitter.emit(this._state);
    }
  }], [{
    key: "makeURI",
    value: function makeURI(uri) {
      return _core.Grammar.URIParse(uri);
    }
    /** Default user agent options. */

  }, {
    key: "defaultOptions",
    value: function defaultOptions() {
      return {
        allowLegacyNotifications: false,
        authorizationHa1: "",
        authorizationPassword: "",
        authorizationUsername: "",
        autoStart: false,
        autoStop: true,
        delegate: {},
        contactName: "",
        contactParams: {
          transport: "ws"
        },
        displayName: "",
        forceRport: false,
        hackAllowUnregisteredOptionTags: false,
        hackIpInContact: false,
        hackViaTcp: false,
        logBuiltinEnabled: true,
        logConfiguration: true,
        logConnector: function logConnector() {
          /* noop */
        },
        logLevel: "log",
        noAnswerTimeout: 60,
        preloadedRouteSet: [],
        reconnectionAttempts: 0,
        reconnectionDelay: 4,
        sendInitialProvisionalResponse: true,
        sessionDescriptionHandlerFactory: (0, _sessionDescriptionHandler.defaultSessionDescriptionHandlerFactory)(),
        sessionDescriptionHandlerFactoryOptions: {},
        sipExtension100rel: _userAgentOptions.SIPExtension.Unsupported,
        sipExtensionReplaces: _userAgentOptions.SIPExtension.Unsupported,
        sipExtensionExtraSupported: [],
        sipjsId: "",
        transportConstructor: _transport.Transport,
        transportOptions: {},
        uri: new _core.URI("sip", "anonymous", "anonymous.invalid"),
        userAgentString: "SIP.js/" + _version.LIBRARY_VERSION,
        viaHost: ""
      };
    }
    /**
     * Strip properties with undefined values from options.
     * This is a work around while waiting for missing vs undefined to be addressed (or not)...
     * https://github.com/Microsoft/TypeScript/issues/13195
     * @param options - Options to reduce
     */

  }, {
    key: "stripUndefinedProperties",
    value: function stripUndefinedProperties(options) {
      return Object.keys(options).reduce(function (object, key) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (options[key] !== undefined) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          object[key] = options[key];
        }

        return object;
      }, {});
    }
  }]);

  return UserAgent;
}();

exports.UserAgent = UserAgent;
},{"../core":"node_modules/sip.js/lib/core/index.js","../core/messages/utils":"node_modules/sip.js/lib/core/messages/utils.js","../platform/web/session-description-handler":"node_modules/sip.js/lib/platform/web/session-description-handler/index.js","../platform/web/transport":"node_modules/sip.js/lib/platform/web/transport/index.js","../version":"node_modules/sip.js/lib/version.js","./emitter":"node_modules/sip.js/lib/api/emitter.js","./invitation":"node_modules/sip.js/lib/api/invitation.js","./inviter":"node_modules/sip.js/lib/api/inviter.js","./message":"node_modules/sip.js/lib/api/message.js","./notification":"node_modules/sip.js/lib/api/notification.js","./user-agent-options":"node_modules/sip.js/lib/api/user-agent-options.js","./user-agent-state":"node_modules/sip.js/lib/api/user-agent-state.js"}],"node_modules/sip.js/lib/api/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _exceptions = require("./exceptions");

Object.keys(_exceptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exceptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exceptions[key];
    }
  });
});

var _ack = require("./ack");

Object.keys(_ack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ack[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ack[key];
    }
  });
});

var _bye = require("./bye");

Object.keys(_bye).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bye[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bye[key];
    }
  });
});

var _emitter = require("./emitter");

Object.keys(_emitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _emitter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _emitter[key];
    }
  });
});

var _info = require("./info");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _info[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

var _invitationAcceptOptions = require("./invitation-accept-options");

Object.keys(_invitationAcceptOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invitationAcceptOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invitationAcceptOptions[key];
    }
  });
});

var _invitationProgressOptions = require("./invitation-progress-options");

Object.keys(_invitationProgressOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invitationProgressOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invitationProgressOptions[key];
    }
  });
});

var _invitationRejectOptions = require("./invitation-reject-options");

Object.keys(_invitationRejectOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invitationRejectOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invitationRejectOptions[key];
    }
  });
});

var _invitation = require("./invitation");

Object.keys(_invitation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invitation[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invitation[key];
    }
  });
});

var _inviterCancelOptions = require("./inviter-cancel-options");

Object.keys(_inviterCancelOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviterCancelOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviterCancelOptions[key];
    }
  });
});

var _inviterInviteOptions = require("./inviter-invite-options");

Object.keys(_inviterInviteOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviterInviteOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviterInviteOptions[key];
    }
  });
});

var _inviterOptions = require("./inviter-options");

Object.keys(_inviterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviterOptions[key];
    }
  });
});

var _inviter = require("./inviter");

Object.keys(_inviter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _inviter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _inviter[key];
    }
  });
});

var _message = require("./message");

Object.keys(_message).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _message[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _message[key];
    }
  });
});

var _messagerMessageOptions = require("./messager-message-options");

Object.keys(_messagerMessageOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messagerMessageOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messagerMessageOptions[key];
    }
  });
});

var _messagerOptions = require("./messager-options");

Object.keys(_messagerOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messagerOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messagerOptions[key];
    }
  });
});

var _messager = require("./messager");

Object.keys(_messager).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _messager[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _messager[key];
    }
  });
});

var _notification = require("./notification");

Object.keys(_notification).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _notification[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _notification[key];
    }
  });
});

var _publisherOptions = require("./publisher-options");

Object.keys(_publisherOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publisherOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publisherOptions[key];
    }
  });
});

var _publisherPublishOptions = require("./publisher-publish-options");

Object.keys(_publisherPublishOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publisherPublishOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publisherPublishOptions[key];
    }
  });
});

var _publisherState = require("./publisher-state");

Object.keys(_publisherState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publisherState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publisherState[key];
    }
  });
});

var _publisherUnpublishOptions = require("./publisher-unpublish-options");

Object.keys(_publisherUnpublishOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publisherUnpublishOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publisherUnpublishOptions[key];
    }
  });
});

var _publisher = require("./publisher");

Object.keys(_publisher).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publisher[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publisher[key];
    }
  });
});

var _referral = require("./referral");

Object.keys(_referral).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _referral[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referral[key];
    }
  });
});

var _registererOptions = require("./registerer-options");

Object.keys(_registererOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registererOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registererOptions[key];
    }
  });
});

var _registererRegisterOptions = require("./registerer-register-options");

Object.keys(_registererRegisterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registererRegisterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registererRegisterOptions[key];
    }
  });
});

var _registererState = require("./registerer-state");

Object.keys(_registererState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registererState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registererState[key];
    }
  });
});

var _registererUnregisterOptions = require("./registerer-unregister-options");

Object.keys(_registererUnregisterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registererUnregisterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registererUnregisterOptions[key];
    }
  });
});

var _registerer = require("./registerer");

Object.keys(_registerer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _registerer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registerer[key];
    }
  });
});

var _sessionByeOptions = require("./session-bye-options");

Object.keys(_sessionByeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionByeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionByeOptions[key];
    }
  });
});

var _sessionDelegate = require("./session-delegate");

Object.keys(_sessionDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDelegate[key];
    }
  });
});

var _sessionDescriptionHandlerFactory = require("./session-description-handler-factory");

Object.keys(_sessionDescriptionHandlerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandlerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandlerFactory[key];
    }
  });
});

var _sessionDescriptionHandler = require("./session-description-handler");

Object.keys(_sessionDescriptionHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandler[key];
    }
  });
});

var _sessionInfoOptions = require("./session-info-options");

Object.keys(_sessionInfoOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionInfoOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionInfoOptions[key];
    }
  });
});

var _sessionInviteOptions = require("./session-invite-options");

Object.keys(_sessionInviteOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionInviteOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionInviteOptions[key];
    }
  });
});

var _sessionMessageOptions = require("./session-message-options");

Object.keys(_sessionMessageOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionMessageOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionMessageOptions[key];
    }
  });
});

var _sessionOptions = require("./session-options");

Object.keys(_sessionOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionOptions[key];
    }
  });
});

var _sessionReferOptions = require("./session-refer-options");

Object.keys(_sessionReferOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionReferOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionReferOptions[key];
    }
  });
});

var _sessionState = require("./session-state");

Object.keys(_sessionState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionState[key];
    }
  });
});

var _session = require("./session");

Object.keys(_session).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _session[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _session[key];
    }
  });
});

var _subscriberOptions = require("./subscriber-options");

Object.keys(_subscriberOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriberOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriberOptions[key];
    }
  });
});

var _subscriberSubscribeOptions = require("./subscriber-subscribe-options");

Object.keys(_subscriberSubscribeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriberSubscribeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriberSubscribeOptions[key];
    }
  });
});

var _subscriber = require("./subscriber");

Object.keys(_subscriber).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriber[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriber[key];
    }
  });
});

var _subscriptionDelegate = require("./subscription-delegate");

Object.keys(_subscriptionDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionDelegate[key];
    }
  });
});

var _subscriptionOptions = require("./subscription-options");

Object.keys(_subscriptionOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionOptions[key];
    }
  });
});

var _subscriptionState = require("./subscription-state");

Object.keys(_subscriptionState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionState[key];
    }
  });
});

var _subscriptionSubscribeOptions = require("./subscription-subscribe-options");

Object.keys(_subscriptionSubscribeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionSubscribeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionSubscribeOptions[key];
    }
  });
});

var _subscriptionUnsubscribeOptions = require("./subscription-unsubscribe-options");

Object.keys(_subscriptionUnsubscribeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscriptionUnsubscribeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscriptionUnsubscribeOptions[key];
    }
  });
});

var _subscription = require("./subscription");

Object.keys(_subscription).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _subscription[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscription[key];
    }
  });
});

var _transport = require("./transport");

Object.keys(_transport).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transport[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transport[key];
    }
  });
});

var _transportState = require("./transport-state");

Object.keys(_transportState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transportState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transportState[key];
    }
  });
});

var _userAgentDelegate = require("./user-agent-delegate");

Object.keys(_userAgentDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentDelegate[key];
    }
  });
});

var _userAgentOptions = require("./user-agent-options");

Object.keys(_userAgentOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentOptions[key];
    }
  });
});

var _userAgentState = require("./user-agent-state");

Object.keys(_userAgentState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgentState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgentState[key];
    }
  });
});

var _userAgent = require("./user-agent");

Object.keys(_userAgent).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _userAgent[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _userAgent[key];
    }
  });
});
},{"./exceptions":"node_modules/sip.js/lib/api/exceptions/index.js","./ack":"node_modules/sip.js/lib/api/ack.js","./bye":"node_modules/sip.js/lib/api/bye.js","./emitter":"node_modules/sip.js/lib/api/emitter.js","./info":"node_modules/sip.js/lib/api/info.js","./invitation-accept-options":"node_modules/sip.js/lib/api/invitation-accept-options.js","./invitation-progress-options":"node_modules/sip.js/lib/api/invitation-progress-options.js","./invitation-reject-options":"node_modules/sip.js/lib/api/invitation-reject-options.js","./invitation":"node_modules/sip.js/lib/api/invitation.js","./inviter-cancel-options":"node_modules/sip.js/lib/api/inviter-cancel-options.js","./inviter-invite-options":"node_modules/sip.js/lib/api/inviter-invite-options.js","./inviter-options":"node_modules/sip.js/lib/api/inviter-options.js","./inviter":"node_modules/sip.js/lib/api/inviter.js","./message":"node_modules/sip.js/lib/api/message.js","./messager-message-options":"node_modules/sip.js/lib/api/messager-message-options.js","./messager-options":"node_modules/sip.js/lib/api/messager-options.js","./messager":"node_modules/sip.js/lib/api/messager.js","./notification":"node_modules/sip.js/lib/api/notification.js","./publisher-options":"node_modules/sip.js/lib/api/publisher-options.js","./publisher-publish-options":"node_modules/sip.js/lib/api/publisher-publish-options.js","./publisher-state":"node_modules/sip.js/lib/api/publisher-state.js","./publisher-unpublish-options":"node_modules/sip.js/lib/api/publisher-unpublish-options.js","./publisher":"node_modules/sip.js/lib/api/publisher.js","./referral":"node_modules/sip.js/lib/api/referral.js","./registerer-options":"node_modules/sip.js/lib/api/registerer-options.js","./registerer-register-options":"node_modules/sip.js/lib/api/registerer-register-options.js","./registerer-state":"node_modules/sip.js/lib/api/registerer-state.js","./registerer-unregister-options":"node_modules/sip.js/lib/api/registerer-unregister-options.js","./registerer":"node_modules/sip.js/lib/api/registerer.js","./session-bye-options":"node_modules/sip.js/lib/api/session-bye-options.js","./session-delegate":"node_modules/sip.js/lib/api/session-delegate.js","./session-description-handler-factory":"node_modules/sip.js/lib/api/session-description-handler-factory.js","./session-description-handler":"node_modules/sip.js/lib/api/session-description-handler.js","./session-info-options":"node_modules/sip.js/lib/api/session-info-options.js","./session-invite-options":"node_modules/sip.js/lib/api/session-invite-options.js","./session-message-options":"node_modules/sip.js/lib/api/session-message-options.js","./session-options":"node_modules/sip.js/lib/api/session-options.js","./session-refer-options":"node_modules/sip.js/lib/api/session-refer-options.js","./session-state":"node_modules/sip.js/lib/api/session-state.js","./session":"node_modules/sip.js/lib/api/session.js","./subscriber-options":"node_modules/sip.js/lib/api/subscriber-options.js","./subscriber-subscribe-options":"node_modules/sip.js/lib/api/subscriber-subscribe-options.js","./subscriber":"node_modules/sip.js/lib/api/subscriber.js","./subscription-delegate":"node_modules/sip.js/lib/api/subscription-delegate.js","./subscription-options":"node_modules/sip.js/lib/api/subscription-options.js","./subscription-state":"node_modules/sip.js/lib/api/subscription-state.js","./subscription-subscribe-options":"node_modules/sip.js/lib/api/subscription-subscribe-options.js","./subscription-unsubscribe-options":"node_modules/sip.js/lib/api/subscription-unsubscribe-options.js","./subscription":"node_modules/sip.js/lib/api/subscription.js","./transport":"node_modules/sip.js/lib/api/transport.js","./transport-state":"node_modules/sip.js/lib/api/transport-state.js","./user-agent-delegate":"node_modules/sip.js/lib/api/user-agent-delegate.js","./user-agent-options":"node_modules/sip.js/lib/api/user-agent-options.js","./user-agent-state":"node_modules/sip.js/lib/api/user-agent-state.js","./user-agent":"node_modules/sip.js/lib/api/user-agent.js"}],"node_modules/sip.js/lib/platform/web/simple-user/simple-user.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleUser = void 0;

var _api = require("../../../api");

var _sessionDescriptionHandler = require("../session-description-handler");

var _transport = require("../transport");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A simple SIP user class.
 * @remarks
 * While this class is completely functional for simple use cases, it is not intended
 * to provide an interface which is suitable for most (must less all) applications.
 * While this class has many limitations (for example, it only handles a single concurrent session),
 * it is, however, intended to serve as a simple example of using the SIP.js API.
 * @public
 */
var SimpleUser = /*#__PURE__*/function () {
  /**
   * Constructs a new instance of the `SimpleUser` class.
   * @param server - SIP WebSocket Server URL.
   * @param options - Options bucket. See {@link SimpleUserOptions} for details.
   */
  function SimpleUser(server) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SimpleUser);

    this.attemptingReconnection = false;
    this.connectRequested = false;
    this.held = false;
    this.muted = false;
    this.registerer = undefined;
    this.registerRequested = false;
    this.session = undefined; // Delegate

    this.delegate = options.delegate; // Copy options

    this.options = Object.assign({}, options); // UserAgentOptions

    var userAgentOptions = Object.assign({}, options.userAgentOptions); // Transport

    if (!userAgentOptions.transportConstructor) {
      userAgentOptions.transportConstructor = _transport.Transport;
    } // TransportOptions


    if (!userAgentOptions.transportOptions) {
      userAgentOptions.transportOptions = {
        server: server
      };
    } // URI


    if (!userAgentOptions.uri) {
      // If an AOR was provided, convert it to a URI
      if (options.aor) {
        var uri = _api.UserAgent.makeURI(options.aor);

        if (!uri) {
          throw new Error("Failed to create valid URI from ".concat(options.aor));
        }

        userAgentOptions.uri = uri;
      }
    } // UserAgent


    this.userAgent = new _api.UserAgent(userAgentOptions); // UserAgent's delegate

    this.userAgent.delegate = {
      // Handle connection with server established
      onConnect: function onConnect() {
        _this.logger.log("[".concat(_this.id, "] Connected"));

        if (_this.delegate && _this.delegate.onServerConnect) {
          _this.delegate.onServerConnect();
        }

        if (_this.registerer && _this.registerRequested) {
          _this.logger.log("[".concat(_this.id, "] Registering..."));

          _this.registerer.register().catch(function (e) {
            _this.logger.error("[".concat(_this.id, "] Error occurred registering after connection with server was obtained."));

            _this.logger.error(e.toString());
          });
        }
      },
      // Handle connection with server lost
      onDisconnect: function onDisconnect(error) {
        _this.logger.log("[".concat(_this.id, "] Disconnected"));

        if (_this.delegate && _this.delegate.onServerDisconnect) {
          _this.delegate.onServerDisconnect(error);
        }

        if (_this.session) {
          _this.logger.log("[".concat(_this.id, "] Hanging up..."));

          _this.hangup() // cleanup hung calls
          .catch(function (e) {
            _this.logger.error("[".concat(_this.id, "] Error occurred hanging up call after connection with server was lost."));

            _this.logger.error(e.toString());
          });
        }

        if (_this.registerer) {
          _this.logger.log("[".concat(_this.id, "] Unregistering..."));

          _this.registerer.unregister() // cleanup invalid registrations
          .catch(function (e) {
            _this.logger.error("[".concat(_this.id, "] Error occurred unregistering after connection with server was lost."));

            _this.logger.error(e.toString());
          });
        } // Only attempt to reconnect if network/server dropped the connection.


        if (error) {
          _this.attemptReconnection();
        }
      },
      // Handle incoming invitations
      onInvite: function onInvite(invitation) {
        _this.logger.log("[".concat(_this.id, "] Received INVITE")); // Guard against a pre-existing session. This implementation only supports one session at a time.
        // However an incoming INVITE request may be received at any time and/or while in the process
        // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.


        if (_this.session) {
          _this.logger.warn("[".concat(_this.id, "] Session already in progress, rejecting INVITE..."));

          invitation.reject().then(function () {
            _this.logger.log("[".concat(_this.id, "] Rejected INVITE"));
          }).catch(function (error) {
            _this.logger.error("[".concat(_this.id, "] Failed to reject INVITE"));

            _this.logger.error(error.toString());
          });
          return;
        } // Use our configured constraints as options for any Inviter created as result of a REFER


        var referralInviterOptions = {
          sessionDescriptionHandlerOptions: {
            constraints: _this.constraints
          }
        }; // Initialize our session

        _this.initSession(invitation, referralInviterOptions); // Delegate


        if (_this.delegate && _this.delegate.onCallReceived) {
          _this.delegate.onCallReceived();
        } else {
          _this.logger.warn("[".concat(_this.id, "] No handler available, rejecting INVITE..."));

          invitation.reject().then(function () {
            _this.logger.log("[".concat(_this.id, "] Rejected INVITE"));
          }).catch(function (error) {
            _this.logger.error("[".concat(_this.id, "] Failed to reject INVITE"));

            _this.logger.error(error.toString());
          });
        }
      },
      // Handle incoming messages
      onMessage: function onMessage(message) {
        message.accept().then(function () {
          if (_this.delegate && _this.delegate.onMessageReceived) {
            _this.delegate.onMessageReceived(message.request.body);
          }
        });
      }
    }; // Use the SIP.js logger

    this.logger = this.userAgent.getLogger("sip.SimpleUser"); // Monitor network connectivity and attempt reconnection when we come online

    window.addEventListener("online", function () {
      _this.logger.log("[".concat(_this.id, "] Online"));

      _this.attemptReconnection();
    });
  }
  /**
   * Instance identifier.
   * @internal
   */


  _createClass(SimpleUser, [{
    key: "id",
    get: function get() {
      return this.options.userAgentOptions && this.options.userAgentOptions.displayName || "Anonymous";
    }
    /** The local media stream. Undefined if call not answered. */

  }, {
    key: "localMediaStream",
    get: function get() {
      var _a;

      var sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;

      if (!sdh) {
        return undefined;
      }

      if (!(sdh instanceof _sessionDescriptionHandler.SessionDescriptionHandler)) {
        throw new Error("Session description handler not instance of web SessionDescriptionHandler");
      }

      return sdh.localMediaStream;
    }
    /** The remote media stream. Undefined if call not answered. */

  }, {
    key: "remoteMediaStream",
    get: function get() {
      var _a;

      var sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;

      if (!sdh) {
        return undefined;
      }

      if (!(sdh instanceof _sessionDescriptionHandler.SessionDescriptionHandler)) {
        throw new Error("Session description handler not instance of web SessionDescriptionHandler");
      }

      return sdh.remoteMediaStream;
    }
    /**
     * The local audio track, if available.
     * @deprecated Use localMediaStream and get track from the stream.
     */

  }, {
    key: "localAudioTrack",
    get: function get() {
      var _a;

      return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {
        return track.kind === "audio";
      });
    }
    /**
     * The local video track, if available.
     * @deprecated Use localMediaStream and get track from the stream.
     */

  }, {
    key: "localVideoTrack",
    get: function get() {
      var _a;

      return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {
        return track.kind === "video";
      });
    }
    /**
     * The remote audio track, if available.
     * @deprecated Use remoteMediaStream and get track from the stream.
     */

  }, {
    key: "remoteAudioTrack",
    get: function get() {
      var _a;

      return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {
        return track.kind === "audio";
      });
    }
    /**
     * The remote video track, if available.
     * @deprecated Use remoteMediaStream and get track from the stream.
     */

  }, {
    key: "remoteVideoTrack",
    get: function get() {
      var _a;

      return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {
        return track.kind === "video";
      });
    }
    /**
     * Connect.
     * @remarks
     * Start the UserAgent's WebSocket Transport.
     */

  }, {
    key: "connect",
    value: function connect() {
      this.logger.log("[".concat(this.id, "] Connecting UserAgent..."));
      this.connectRequested = true;

      if (this.userAgent.state !== _api.UserAgentState.Started) {
        return this.userAgent.start();
      }

      return this.userAgent.reconnect();
    }
    /**
     * Disconnect.
     * @remarks
     * Stop the UserAgent's WebSocket Transport.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      this.logger.log("[".concat(this.id, "] Disconnecting UserAgent..."));
      this.connectRequested = false;
      return this.userAgent.stop();
    }
    /**
     * Return true if connected.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this.userAgent.isConnected();
    }
    /**
     * Start receiving incoming calls.
     * @remarks
     * Send a REGISTER request for the UserAgent's AOR.
     * Resolves when the REGISTER request is sent, otherwise rejects.
     */

  }, {
    key: "register",
    value: function register(registererOptions, registererRegisterOptions) {
      var _this2 = this;

      this.logger.log("[".concat(this.id, "] Registering UserAgent..."));
      this.registerRequested = true;

      if (!this.registerer) {
        this.registerer = new _api.Registerer(this.userAgent, registererOptions);
        this.registerer.stateChange.addListener(function (state) {
          switch (state) {
            case _api.RegistererState.Initial:
              break;

            case _api.RegistererState.Registered:
              if (_this2.delegate && _this2.delegate.onRegistered) {
                _this2.delegate.onRegistered();
              }

              break;

            case _api.RegistererState.Unregistered:
              if (_this2.delegate && _this2.delegate.onUnregistered) {
                _this2.delegate.onUnregistered();
              }

              break;

            case _api.RegistererState.Terminated:
              _this2.registerer = undefined;
              break;

            default:
              throw new Error("Unknown registerer state.");
          }
        });
      }

      return this.registerer.register(registererRegisterOptions).then(function () {
        return;
      });
    }
    /**
     * Stop receiving incoming calls.
     * @remarks
     * Send an un-REGISTER request for the UserAgent's AOR.
     * Resolves when the un-REGISTER request is sent, otherwise rejects.
     */

  }, {
    key: "unregister",
    value: function unregister(registererUnregisterOptions) {
      this.logger.log("[".concat(this.id, "] Unregistering UserAgent..."));
      this.registerRequested = false;

      if (!this.registerer) {
        return Promise.resolve();
      }

      return this.registerer.unregister(registererUnregisterOptions).then(function () {
        return;
      });
    }
    /**
     * Make an outgoing call.
     * @remarks
     * Send an INVITE request to create a new Session.
     * Resolves when the INVITE request is sent, otherwise rejects.
     * Use `onCallAnswered` delegate method to determine if Session is established.
     * @param destination - The target destination to call. A SIP address to send the INVITE to.
     * @param inviterOptions - Optional options for Inviter constructor.
     * @param inviterInviteOptions - Optional options for Inviter.invite().
     */

  }, {
    key: "call",
    value: function call(destination, inviterOptions, inviterInviteOptions) {
      this.logger.log("[".concat(this.id, "] Beginning Session..."));

      if (this.session) {
        return Promise.reject(new Error("Session already exists."));
      }

      var target = _api.UserAgent.makeURI(destination);

      if (!target) {
        return Promise.reject(new Error("Failed to create a valid URI from \"".concat(destination, "\"")));
      } // Use our configured constraints as InviterOptions if none provided


      if (!inviterOptions) {
        inviterOptions = {};
      }

      if (!inviterOptions.sessionDescriptionHandlerOptions) {
        inviterOptions.sessionDescriptionHandlerOptions = {};
      }

      if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {
        inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
      } // Create a new Inviter for the outgoing Session


      var inviter = new _api.Inviter(this.userAgent, target, inviterOptions); // Send INVITE

      return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(function () {
        return;
      });
    }
    /**
     * Hangup a call.
     * @remarks
     * Send a BYE request, CANCEL request or reject response to end the current Session.
     * Resolves when the request/response is sent, otherwise rejects.
     * Use `onCallTerminated` delegate method to determine if and when call is ended.
     */

  }, {
    key: "hangup",
    value: function hangup() {
      this.logger.log("[".concat(this.id, "] Hangup..."));
      return this.terminate();
    }
    /**
     * Answer an incoming call.
     * @remarks
     * Accept an incoming INVITE request creating a new Session.
     * Resolves with the response is sent, otherwise rejects.
     * Use `onCallAnswered` delegate method to determine if and when call is established.
     * @param invitationAcceptOptions - Optional options for Inviter.accept().
     */

  }, {
    key: "answer",
    value: function answer(invitationAcceptOptions) {
      this.logger.log("[".concat(this.id, "] Accepting Invitation..."));

      if (!this.session) {
        return Promise.reject(new Error("Session does not exist."));
      }

      if (!(this.session instanceof _api.Invitation)) {
        return Promise.reject(new Error("Session not instance of Invitation."));
      } // Use our configured constraints as InvitationAcceptOptions if none provided


      if (!invitationAcceptOptions) {
        invitationAcceptOptions = {};
      }

      if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {
        invitationAcceptOptions.sessionDescriptionHandlerOptions = {};
      }

      if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {
        invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;
      }

      return this.session.accept(invitationAcceptOptions);
    }
    /**
     * Decline an incoming call.
     * @remarks
     * Reject an incoming INVITE request.
     * Resolves with the response is sent, otherwise rejects.
     * Use `onCallTerminated` delegate method to determine if and when call is ended.
     */

  }, {
    key: "decline",
    value: function decline() {
      this.logger.log("[".concat(this.id, "] rejecting Invitation..."));

      if (!this.session) {
        return Promise.reject(new Error("Session does not exist."));
      }

      if (!(this.session instanceof _api.Invitation)) {
        return Promise.reject(new Error("Session not instance of Invitation."));
      }

      return this.session.reject();
    }
    /**
     * Hold call
     * @remarks
     * Send a re-INVITE with new offer indicating "hold".
     * Resolves when the re-INVITE request is sent, otherwise rejects.
     * Use `onCallHold` delegate method to determine if request is accepted or rejected.
     * See: https://tools.ietf.org/html/rfc6337
     */

  }, {
    key: "hold",
    value: function hold() {
      this.logger.log("[".concat(this.id, "] holding session..."));
      return this.setHold(true);
    }
    /**
     * Unhold call.
     * @remarks
     * Send a re-INVITE with new offer indicating "unhold".
     * Resolves when the re-INVITE request is sent, otherwise rejects.
     * Use `onCallHold` delegate method to determine if request is accepted or rejected.
     * See: https://tools.ietf.org/html/rfc6337
     */

  }, {
    key: "unhold",
    value: function unhold() {
      this.logger.log("[".concat(this.id, "] unholding session..."));
      return this.setHold(false);
    }
    /**
     * Hold state.
     * @remarks
     * True if session media is on hold.
     */

  }, {
    key: "isHeld",
    value: function isHeld() {
      return this.held;
    }
    /**
     * Mute call.
     * @remarks
     * Disable sender's media tracks.
     */

  }, {
    key: "mute",
    value: function mute() {
      this.logger.log("[".concat(this.id, "] disabling media tracks..."));
      this.setMute(true);
    }
    /**
     * Unmute call.
     * @remarks
     * Enable sender's media tracks.
     */

  }, {
    key: "unmute",
    value: function unmute() {
      this.logger.log("[".concat(this.id, "] enabling media tracks..."));
      this.setMute(false);
    }
    /**
     * Mute state.
     * @remarks
     * True if sender's media track is disabled.
     */

  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.muted;
    }
    /**
     * Send DTMF.
     * @remarks
     * Send an INFO request with content type application/dtmf-relay.
     * @param tone - Tone to send.
     */

  }, {
    key: "sendDTMF",
    value: function sendDTMF(tone) {
      this.logger.log("[".concat(this.id, "] sending DTMF...")); // As RFC 6086 states, sending DTMF via INFO is not standardized...
      //
      // Companies have been using INFO messages in order to transport
      // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are
      // proprietary and have not been standardized.
      // https://tools.ietf.org/html/rfc6086#section-2
      //
      // It is however widely supported based on this draft:
      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00
      // Validate tone

      if (!/^[0-9A-D#*,]$/.exec(tone)) {
        return Promise.reject(new Error("Invalid DTMF tone."));
      }

      if (!this.session) {
        return Promise.reject(new Error("Session does not exist."));
      } // The UA MUST populate the "application/dtmf-relay" body, as defined
      // earlier, with the button pressed and the duration it was pressed
      // for.  Technically, this actually requires the INFO to be generated
      // when the user *releases* the button, however if the user has still
      // not released a button after 5 seconds, which is the maximum duration
      // supported by this mechanism, the UA should generate the INFO at that
      // time.
      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3


      this.logger.log("[".concat(this.id, "] Sending DTMF tone: ").concat(tone));
      var dtmf = tone;
      var duration = 2000;
      var body = {
        contentDisposition: "render",
        contentType: "application/dtmf-relay",
        content: "Signal=" + dtmf + "\r\nDuration=" + duration
      };
      var requestOptions = {
        body: body
      };
      return this.session.info({
        requestOptions: requestOptions
      }).then(function () {
        return;
      });
    }
    /**
     * Send a message.
     * @remarks
     * Send a MESSAGE request.
     * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.
     */

  }, {
    key: "message",
    value: function message(destination, _message) {
      this.logger.log("[".concat(this.id, "] sending message..."));

      var target = _api.UserAgent.makeURI(destination);

      if (!target) {
        return Promise.reject(new Error("Failed to create a valid URI from \"".concat(destination, "\"")));
      }

      return new _api.Messager(this.userAgent, target, _message).message();
    }
    /** Media constraints. */

  }, {
    key: "constraints",
    get: function get() {
      var _a;

      var constraints = {
        audio: true,
        video: false
      }; // default to audio only calls

      if ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.constraints) {
        constraints = Object.assign({}, this.options.media.constraints);
      }

      return constraints;
    }
    /**
     * Attempt reconnection up to `maxReconnectionAttempts` times.
     * @param reconnectionAttempt - Current attempt number.
     */

  }, {
    key: "attemptReconnection",
    value: function attemptReconnection() {
      var _this3 = this;

      var reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var reconnectionAttempts = this.options.reconnectionAttempts || 3;
      var reconnectionDelay = this.options.reconnectionDelay || 4;

      if (!this.connectRequested) {
        this.logger.log("[".concat(this.id, "] Reconnection not currently desired"));
        return; // If intentionally disconnected, don't reconnect.
      }

      if (this.attemptingReconnection) {
        this.logger.log("[".concat(this.id, "] Reconnection attempt already in progress"));
      }

      if (reconnectionAttempt > reconnectionAttempts) {
        this.logger.log("[".concat(this.id, "] Reconnection maximum attempts reached"));
        return;
      }

      if (reconnectionAttempt === 1) {
        this.logger.log("[".concat(this.id, "] Reconnection attempt ").concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - trying"));
      } else {
        this.logger.log("[".concat(this.id, "] Reconnection attempt ").concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - trying in ").concat(reconnectionDelay, " seconds"));
      }

      this.attemptingReconnection = true;
      setTimeout(function () {
        if (!_this3.connectRequested) {
          _this3.logger.log("[".concat(_this3.id, "] Reconnection attempt ").concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - aborted"));

          _this3.attemptingReconnection = false;
          return; // If intentionally disconnected, don't reconnect.
        }

        _this3.userAgent.reconnect().then(function () {
          _this3.logger.log("[".concat(_this3.id, "] Reconnection attempt ").concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - succeeded"));

          _this3.attemptingReconnection = false;
        }).catch(function (error) {
          _this3.logger.log("[".concat(_this3.id, "] Reconnection attempt ").concat(reconnectionAttempt, " of ").concat(reconnectionAttempts, " - failed"));

          _this3.logger.error(error.message);

          _this3.attemptingReconnection = false;

          _this3.attemptReconnection(++reconnectionAttempt);
        });
      }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);
    }
    /** Helper function to remove media from html elements. */

  }, {
    key: "cleanupMedia",
    value: function cleanupMedia() {
      if (this.options.media) {
        if (this.options.media.local) {
          if (this.options.media.local.video) {
            this.options.media.local.video.srcObject = null;
            this.options.media.local.video.pause();
          }
        }

        if (this.options.media.remote) {
          if (this.options.media.remote.audio) {
            this.options.media.remote.audio.srcObject = null;
            this.options.media.remote.audio.pause();
          }

          if (this.options.media.remote.video) {
            this.options.media.remote.video.srcObject = null;
            this.options.media.remote.video.pause();
          }
        }
      }
    }
    /** Helper function to enable/disable media tracks. */

  }, {
    key: "enableReceiverTracks",
    value: function enableReceiverTracks(enable) {
      if (!this.session) {
        throw new Error("Session does not exist.");
      }

      var sessionDescriptionHandler = this.session.sessionDescriptionHandler;

      if (!(sessionDescriptionHandler instanceof _sessionDescriptionHandler.SessionDescriptionHandler)) {
        throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
      }

      var peerConnection = sessionDescriptionHandler.peerConnection;

      if (!peerConnection) {
        throw new Error("Peer connection closed.");
      }

      peerConnection.getReceivers().forEach(function (receiver) {
        if (receiver.track) {
          receiver.track.enabled = enable;
        }
      });
    }
    /** Helper function to enable/disable media tracks. */

  }, {
    key: "enableSenderTracks",
    value: function enableSenderTracks(enable) {
      if (!this.session) {
        throw new Error("Session does not exist.");
      }

      var sessionDescriptionHandler = this.session.sessionDescriptionHandler;

      if (!(sessionDescriptionHandler instanceof _sessionDescriptionHandler.SessionDescriptionHandler)) {
        throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
      }

      var peerConnection = sessionDescriptionHandler.peerConnection;

      if (!peerConnection) {
        throw new Error("Peer connection closed.");
      }

      peerConnection.getSenders().forEach(function (sender) {
        if (sender.track) {
          sender.track.enabled = enable;
        }
      });
    }
    /**
     * Setup session delegate and state change handler.
     * @param session - Session to setup
     * @param referralInviterOptions - Options for any Inviter created as result of a REFER.
     */

  }, {
    key: "initSession",
    value: function initSession(session, referralInviterOptions) {
      var _this4 = this;

      // Set session
      this.session = session; // Call session created callback

      if (this.delegate && this.delegate.onCallCreated) {
        this.delegate.onCallCreated();
      } // Setup session state change handler


      this.session.stateChange.addListener(function (state) {
        if (_this4.session !== session) {
          return; // if our session has changed, just return
        }

        _this4.logger.log("[".concat(_this4.id, "] session state changed to ").concat(state));

        switch (state) {
          case _api.SessionState.Initial:
            break;

          case _api.SessionState.Establishing:
            break;

          case _api.SessionState.Established:
            _this4.setupLocalMedia();

            _this4.setupRemoteMedia();

            if (_this4.delegate && _this4.delegate.onCallAnswered) {
              _this4.delegate.onCallAnswered();
            }

            break;

          case _api.SessionState.Terminating: // fall through

          case _api.SessionState.Terminated:
            _this4.session = undefined;

            _this4.cleanupMedia();

            if (_this4.delegate && _this4.delegate.onCallHangup) {
              _this4.delegate.onCallHangup();
            }

            break;

          default:
            throw new Error("Unknown session state.");
        }
      }); // Setup delegate

      this.session.delegate = {
        onInfo: function onInfo(info) {
          // As RFC 6086 states, sending DTMF via INFO is not standardized...
          //
          // Companies have been using INFO messages in order to transport
          // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are
          // proprietary and have not been standardized.
          // https://tools.ietf.org/html/rfc6086#section-2
          //
          // It is however widely supported based on this draft:
          // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00
          var _a; // FIXME: TODO: We should reject correctly...
          //
          // If a UA receives an INFO request associated with an Info Package that
          // the UA has not indicated willingness to receive, the UA MUST send a
          // 469 (Bad Info Package) response (see Section 11.6), which contains a
          // Recv-Info header field with Info Packages for which the UA is willing
          // to receive INFO requests.
          // https://tools.ietf.org/html/rfc6086#section-4.2.2
          // No delegate


          if (((_a = _this4.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {
            info.reject();
            return;
          } // Invalid content type


          var contentType = info.request.getHeader("content-type");

          if (!contentType || !/^application\/dtmf-relay/i.exec(contentType)) {
            info.reject();
            return;
          } // Invalid body


          var body = info.request.body.split("\r\n", 2);

          if (body.length !== 2) {
            info.reject();
            return;
          } // Invalid tone


          var tone;
          var toneRegExp = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;

          if (toneRegExp.test(body[0])) {
            tone = body[0].replace(toneRegExp, "$2");
          }

          if (!tone) {
            info.reject();
            return;
          } // Invalid duration


          var duration;
          var durationRegExp = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;

          if (durationRegExp.test(body[1])) {
            duration = parseInt(body[1].replace(durationRegExp, "$2"), 10);
          }

          if (!duration) {
            info.reject();
            return;
          }

          info.accept().then(function () {
            if (_this4.delegate && _this4.delegate.onCallDTMFReceived) {
              if (!tone || !duration) {
                throw new Error("Tone or duration undefined.");
              }

              _this4.delegate.onCallDTMFReceived(tone, duration);
            }
          }).catch(function (error) {
            _this4.logger.error(error.message);
          });
        },
        onRefer: function onRefer(referral) {
          referral.accept().then(function () {
            return _this4.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions);
          }).catch(function (error) {
            _this4.logger.error(error.message);
          });
        }
      };
    }
    /** Helper function to init send then send invite. */

  }, {
    key: "sendInvite",
    value: function sendInvite(inviter, inviterOptions, inviterInviteOptions) {
      var _this5 = this;

      // Initialize our session
      this.initSession(inviter, inviterOptions); // Send the INVITE

      return inviter.invite(inviterInviteOptions).then(function () {
        _this5.logger.log("[".concat(_this5.id, "] sent INVITE"));
      });
    }
    /**
     * Puts Session on hold.
     * @param hold - Hold on if true, off if false.
     */

  }, {
    key: "setHold",
    value: function setHold(hold) {
      var _this6 = this;

      if (!this.session) {
        return Promise.reject(new Error("Session does not exist."));
      }

      var session = this.session; // Just resolve if we are already in correct state

      if (this.held === hold) {
        return Promise.resolve();
      }

      var sessionDescriptionHandler = this.session.sessionDescriptionHandler;

      if (!(sessionDescriptionHandler instanceof _sessionDescriptionHandler.SessionDescriptionHandler)) {
        throw new Error("Session's session description handler not instance of SessionDescriptionHandler.");
      }

      var options = {
        requestDelegate: {
          onAccept: function onAccept() {
            _this6.held = hold;

            _this6.enableReceiverTracks(!_this6.held);

            _this6.enableSenderTracks(!_this6.held && !_this6.muted);

            if (_this6.delegate && _this6.delegate.onCallHold) {
              _this6.delegate.onCallHold(_this6.held);
            }
          },
          onReject: function onReject() {
            _this6.logger.warn("[".concat(_this6.id, "] re-invite request was rejected"));

            _this6.enableReceiverTracks(!_this6.held);

            _this6.enableSenderTracks(!_this6.held && !_this6.muted);

            if (_this6.delegate && _this6.delegate.onCallHold) {
              _this6.delegate.onCallHold(_this6.held);
            }
          }
        }
      }; // Session properties used to pass options to the SessionDescriptionHandler:
      //
      // 1) Session.sessionDescriptionHandlerOptions
      //    SDH options for the initial INVITE transaction.
      //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.
      //    - May be set directly at anytime.
      //    - May optionally be set via constructor option.
      //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().
      //
      // 2) Session.sessionDescriptionHandlerOptionsReInvite
      //    SDH options for re-INVITE transactions.
      //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.
      //    - May be set directly at anytime.
      //    - May optionally be set via constructor option.
      //    - May optionally be set via options passed to Session.invite().

      var sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;
      sessionDescriptionHandlerOptions.hold = hold;
      session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions; // Send re-INVITE

      return this.session.invite(options).then(function () {
        // preemptively enable/disable tracks
        _this6.enableReceiverTracks(!hold);

        _this6.enableSenderTracks(!hold && !_this6.muted);
      }).catch(function (error) {
        if (error instanceof _api.RequestPendingError) {
          _this6.logger.error("[".concat(_this6.id, "] A hold request is already in progress."));
        }

        throw error;
      });
    }
    /**
     * Puts Session on mute.
     * @param mute - Mute on if true, off if false.
     */

  }, {
    key: "setMute",
    value: function setMute(mute) {
      if (!this.session) {
        this.logger.warn("[".concat(this.id, "] A session is required to enabled/disable media tracks"));
        return;
      }

      if (this.session.state !== _api.SessionState.Established) {
        this.logger.warn("[".concat(this.id, "] An established session is required to enable/disable media tracks"));
        return;
      }

      this.muted = mute;
      this.enableSenderTracks(!this.held && !this.muted);
    }
    /** Helper function to attach local media to html elements. */

  }, {
    key: "setupLocalMedia",
    value: function setupLocalMedia() {
      var _this7 = this;

      var _a, _b;

      if (!this.session) {
        throw new Error("Session does not exist.");
      }

      var mediaElement = (_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.local) === null || _b === void 0 ? void 0 : _b.video;

      if (mediaElement) {
        var localStream = this.localMediaStream;

        if (!localStream) {
          throw new Error("Local media stream undefiend.");
        }

        mediaElement.srcObject = localStream;
        mediaElement.volume = 0;
        mediaElement.play().catch(function (error) {
          _this7.logger.error("[".concat(_this7.id, "] Failed to play local media"));

          _this7.logger.error(error.message);
        });
      }
    }
    /** Helper function to attach remote media to html elements. */

  }, {
    key: "setupRemoteMedia",
    value: function setupRemoteMedia() {
      var _this8 = this;

      var _a, _b, _c, _d;

      if (!this.session) {
        throw new Error("Session does not exist.");
      }

      var mediaElement = ((_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.video) || ((_d = (_c = this.options.media) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.audio);

      if (mediaElement) {
        var remoteStream = this.remoteMediaStream;

        if (!remoteStream) {
          throw new Error("Remote media stream undefiend.");
        }

        mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action

        mediaElement.srcObject = remoteStream;
        mediaElement.play().catch(function (error) {
          _this8.logger.error("[".concat(_this8.id, "] Failed to play remote media"));

          _this8.logger.error(error.message);
        });

        remoteStream.onaddtrack = function () {
          _this8.logger.log("[".concat(_this8.id, "] Remote media onaddtrack"));

          mediaElement.load(); // Safari hack, as it doesn't work otheriwse

          mediaElement.play().catch(function (error) {
            _this8.logger.error("[".concat(_this8.id, "] Failed to play remote media"));

            _this8.logger.error(error.message);
          });
        };
      }
    }
    /**
     * End a session.
     * @remarks
     * Send a BYE request, CANCEL request or reject response to end the current Session.
     * Resolves when the request/response is sent, otherwise rejects.
     * Use `onCallTerminated` delegate method to determine if and when Session is terminated.
     */

  }, {
    key: "terminate",
    value: function terminate() {
      var _this9 = this;

      this.logger.log("[".concat(this.id, "] Terminating..."));

      if (!this.session) {
        return Promise.reject(new Error("Session does not exist."));
      }

      switch (this.session.state) {
        case _api.SessionState.Initial:
          if (this.session instanceof _api.Inviter) {
            return this.session.cancel().then(function () {
              _this9.logger.log("[".concat(_this9.id, "] Inviter never sent INVITE (canceled)"));
            });
          } else if (this.session instanceof _api.Invitation) {
            return this.session.reject().then(function () {
              _this9.logger.log("[".concat(_this9.id, "] Invitation rejected (sent 480)"));
            });
          } else {
            throw new Error("Unknown session type.");
          }

        case _api.SessionState.Establishing:
          if (this.session instanceof _api.Inviter) {
            return this.session.cancel().then(function () {
              _this9.logger.log("[".concat(_this9.id, "] Inviter canceled (sent CANCEL)"));
            });
          } else if (this.session instanceof _api.Invitation) {
            return this.session.reject().then(function () {
              _this9.logger.log("[".concat(_this9.id, "] Invitation rejected (sent 480)"));
            });
          } else {
            throw new Error("Unknown session type.");
          }

        case _api.SessionState.Established:
          return this.session.bye().then(function () {
            _this9.logger.log("[".concat(_this9.id, "] Session ended (sent BYE)"));
          });

        case _api.SessionState.Terminating:
          break;

        case _api.SessionState.Terminated:
          break;

        default:
          throw new Error("Unknown state");
      }

      this.logger.log("[".concat(this.id, "] Terminating in state ").concat(this.session.state, ", no action taken"));
      return Promise.resolve();
    }
  }]);

  return SimpleUser;
}();

exports.SimpleUser = SimpleUser;
},{"../../../api":"node_modules/sip.js/lib/api/index.js","../session-description-handler":"node_modules/sip.js/lib/platform/web/session-description-handler/index.js","../transport":"node_modules/sip.js/lib/platform/web/transport/index.js"}],"node_modules/sip.js/lib/platform/web/simple-user/simple-user-delegate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/simple-user/simple-user-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/sip.js/lib/platform/web/simple-user/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _simpleUser = require("./simple-user");

Object.keys(_simpleUser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _simpleUser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _simpleUser[key];
    }
  });
});

var _simpleUserDelegate = require("./simple-user-delegate");

Object.keys(_simpleUserDelegate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _simpleUserDelegate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _simpleUserDelegate[key];
    }
  });
});

var _simpleUserOptions = require("./simple-user-options");

Object.keys(_simpleUserOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _simpleUserOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _simpleUserOptions[key];
    }
  });
});
},{"./simple-user":"node_modules/sip.js/lib/platform/web/simple-user/simple-user.js","./simple-user-delegate":"node_modules/sip.js/lib/platform/web/simple-user/simple-user-delegate.js","./simple-user-options":"node_modules/sip.js/lib/platform/web/simple-user/simple-user-options.js"}],"node_modules/sip.js/lib/platform/web/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _modifiers = require("./modifiers");

Object.keys(_modifiers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _modifiers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modifiers[key];
    }
  });
});

var _sessionDescriptionHandler = require("./session-description-handler");

Object.keys(_sessionDescriptionHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sessionDescriptionHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionDescriptionHandler[key];
    }
  });
});

var _simpleUser = require("./simple-user");

Object.keys(_simpleUser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _simpleUser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _simpleUser[key];
    }
  });
});

var _transport = require("./transport");

Object.keys(_transport).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transport[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transport[key];
    }
  });
});
},{"./modifiers":"node_modules/sip.js/lib/platform/web/modifiers/index.js","./session-description-handler":"node_modules/sip.js/lib/platform/web/session-description-handler/index.js","./simple-user":"node_modules/sip.js/lib/platform/web/simple-user/index.js","./transport":"node_modules/sip.js/lib/platform/web/transport/index.js"}],"src/index.ts":[function(require,module,exports) {
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var web_1 = require("sip.js/lib/platform/web"); // Helper function to get an HTML audio element


function getAudioElement(id) {
  var el = document.getElementById(id);

  if (!(el instanceof HTMLAudioElement)) {
    throw new Error("Element \"" + id + "\" not found or not an audio element.");
  }

  return el;
} // Helper function to wait


function wait(ms) {
  return __awaiter(this, void 0, Promise, function () {
    return __generator(this, function (_a) {
      return [2
      /*return*/
      , new Promise(function (resolve) {
        setTimeout(resolve, ms);
      })];
    });
  });
} // Main function


function main() {
  return __awaiter(this, void 0, Promise, function () {
    var server, destination, aor, authorizationUsername, authorizationPassword, options, simpleUser, error_1;

    var _this = this;

    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          server = "wss://3frontoffice.nr.tre.se";
          destination = "sip:00923235037548@3kontaktpartnernr.dk";
          aor = "sip:device.a23995751@3kontaktpartnernr.dk";
          authorizationUsername = "device.a23995751";
          authorizationPassword = "Arooj123";
          options = {
            aor: aor,
            media: {
              remote: {
                audio: getAudioElement("remoteAudio")
              }
            },
            userAgentOptions: {
              authorizationPassword: authorizationPassword,
              authorizationUsername: authorizationUsername
            }
          };
          simpleUser = new web_1.SimpleUser(server, options); // Supply delegate to handle inbound calls (optional)

          simpleUser.delegate = {
            onCallReceived: function onCallReceived() {
              return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4
                      /*yield*/
                      , simpleUser.answer()];

                    case 1:
                      _a.sent();

                      return [2
                      /*return*/
                      ];
                  }
                });
              });
            }
          };
          _a.label = 1;

        case 1:
          _a.trys.push([1, 5,, 6]); // Connect to server


          return [4
          /*yield*/
          , simpleUser.connect()];

        case 2:
          // Connect to server
          _a.sent(); // Register to receive inbound calls (optional)


          return [4
          /*yield*/
          , simpleUser.register()];

        case 3:
          // Register to receive inbound calls (optional)
          _a.sent(); // Place call to the destination


          return [4
          /*yield*/
          , simpleUser.call(destination)];

        case 4:
          // Place call to the destination
          _a.sent();

          return [3
          /*break*/
          , 6];

        case 5:
          error_1 = _a.sent();
          console.log("________error");
          console.log(error_1);
          return [3
          /*break*/
          , 6];

        case 6:
          return [2
          /*return*/
          ];
      }
    });
  });
} // Run it


main().then(function () {
  return console.log("Success");
}).catch(function (error) {
  return console.error("Failure", error);
});
},{"sip.js/lib/platform/web":"node_modules/sip.js/lib/platform/web/index.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "65116" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.ts"], null)
//# sourceMappingURL=/src.f10117fe.js.map